var tipuesearch = {"pages":[{"title":" FRTС project ","text":"FRTС project Код FRTC Note Тут что-то про него надо написать This is a project which I wrote. This file will provide the documents. I'm writing the body of the text here. It contains an overall description of the project. It might explain how to go about installing/compiling it. It might provide a change-log for the code. FRTC Maybe it will talk about the history and/or motivation for this software. Note You can include any notes (or bugs, warnings, or todos) like so. Bug You can have multi-paragraph versions of these too! That means you can include ordered lists\nunordered lists\nimages\netc.\nIsn't that cool? Bug Hey I'm doing it again... This ones ends mid... ...paragraph. You can have as many paragraphs as you like here and can use headlines, links, images, etc. Basically, you can use anything in Markdown and Markdown-Extra. Furthermore, you can insert LaTeX into your documentation. So, for example, you can provide inline math using like or math on its own line like or You can even use LaTeX environments! So you can get numbered equations like this: So let your imagination run wild. As you can tell, I'm more or less just filling in space now. This will be the last sentence Developer Info Popov's Lab","tags":"home","loc":"index.html"},{"title":"Timer – FRTС project ","text":"type, public :: Timer Components Type Visibility Attributes Name Initial real(kind=wp), public :: start_time real(kind=wp), public :: end_time real(kind=wp), public :: elapsed_time real(kind=wp), public :: plasma_time character(len=120), public :: file_name Type-Bound Procedures procedure, public :: start => Time_start public  subroutine Time_start (this, fn, pt) Arguments Type Intent Optional Attributes Name class( Timer ), intent(inout) :: this character(len=*), intent(in) :: fn real(kind=wp), intent(in) :: pt procedure, public :: stop => Time_stop public  subroutine Time_stop (this) Arguments Type Intent Optional Attributes Name class( Timer ), intent(inout) :: this procedure, public :: stop_and_save => Time_stop_and_save public  subroutine Time_stop_and_save (this) Arguments Type Intent Optional Attributes Name class( Timer ), intent(inout) :: this","tags":"","loc":"type\\timer.html"},{"title":"FokkerPlanck1D – FRTС project ","text":"type, public :: FokkerPlanck1D solver of FP eq Components Type Visibility Attributes Name Initial real(kind=dp), public :: enorm = 0 электрическое поле real(kind=dp), public :: v_lim = 0 верхняя граница скорости электронов real(kind=dp), public, allocatable :: v (:) сетка скоростей real(kind=dp), public, allocatable :: f (:) распределение integer, public :: i0 = 0 size of distribution grid real(kind=dp), public :: alfa2 = 0 поле со знаком integer, public :: n = 0 size of local grid real(kind=dp), public :: h = 0 step of local grid real(kind=dp), public, allocatable :: d1 (:) диффузия real(kind=dp), public, allocatable :: d2 (:) диффузия real(kind=dp), public, allocatable :: d3 (:) диффузия Constructor public        interface FokkerPlanck1D public  function FokkerPlanck1D_constructor (e, v_lim, v, f) result(this) конструктор для FokkerPlanck1D Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D ) Type-Bound Procedures procedure, public :: print => FokkerPlanck1D_print public  subroutine FokkerPlanck1D_print (this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(in) :: this procedure, public :: solve_time_step => FokkerPlanck1D_solve_time_step public  subroutine FokkerPlanck1D_solve_time_step (this, dt, nt) !!!!!!!!!!   solve problem   !!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in) :: dt integer, intent(in) :: nt procedure, public :: init_zero_diffusion => FokkerPlanck1D_init_zero_diffusion public  subroutine FokkerPlanck1D_init_zero_diffusion (this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this procedure, public :: init_diffusion => FokkerPlanck1D_init_diffusion public  subroutine FokkerPlanck1D_init_diffusion (this, dif) инициализация диффузии для схемы савельева Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in), dimension(:) :: dif","tags":"","loc":"type\\fokkerplanck1d.html"},{"title":"FluxSurface – FRTС project ","text":"type, public :: FluxSurface класс магнитной поверхности Components Type Visibility Attributes Name Initial integer, public :: index номер магнитной поверхности real(kind=wp), public :: r радиус real(kind=wp), public :: vmax vmax=cltn/vto real(kind=wp), public :: vt наверно тепловая скорость электронов????? vt=fvt(r) integer, public :: ipt размер vgrid real(kind=wp), public, allocatable :: vgrid (:) real(kind=wp), public, allocatable :: vr_grid (:) бываший vrj real(kind=wp), public, allocatable :: diffusion (:) бывший dijk(i,j,k) или dj(i)","tags":"","loc":"type\\fluxsurface.html"},{"title":"TrajectoryPoint – FRTС project ","text":"type, public :: TrajectoryPoint тип для хранения точки тректории Components Type Visibility Attributes Name Initial real(kind=wp), public :: dland real(kind=wp), public :: dcoll real(kind=wp), public :: perpn real(kind=wp), public :: dalf real(kind=wp), public :: vel real(kind=wp), public :: tetai real(kind=wp), public :: xnpar real(kind=wp), public :: rho real(kind=wp), public :: vthc real(kind=wp), public :: poloidn integer, public :: izz integer, public :: iww integer, public :: jrad integer, public :: driver value = 2 or 4, где была создана точка в driver2 или driver4","tags":"","loc":"type\\trajectorypoint.html"},{"title":"Trajectory – FRTС project ","text":"type, public :: Trajectory Components Type Visibility Attributes Name Initial integer, public :: size size of Trajectory real(kind=wp), public :: tetin real(kind=wp), public :: xmin real(kind=wp), public :: rin real(kind=wp), public :: yn3 real(kind=wp), public :: pow integer, public :: irs integer, public :: iw integer, public :: izn integer, public :: spectrum_point_index integer, public :: mbad integer, public :: nrefj real(kind=wp), public :: tetzap real(kind=wp), public :: xmzap real(kind=wp), public :: rzap real(kind=wp), public :: yn3zap real(kind=wp), public :: powexit integer, public :: irszap integer, public :: iwzap integer, public :: iznzap type( TrajectoryPoint ), public, allocatable :: points (:) Type-Bound Procedures procedure, public :: init => init_method public  subroutine init_method (this, theta, index) инициализация траетории Arguments Type Intent Optional Attributes Name class( Trajectory ), intent(inout) :: this real(kind=wp), intent(in) :: theta integer, intent(in) :: index procedure, public :: reset => reset_method public  subroutine reset_method (this, index) сброс счетчика Arguments Type Intent Optional Attributes Name class( Trajectory ), intent(inout) :: this integer, intent(in) :: index procedure, public :: add_point => add_point_method public  subroutine add_point_method (this, tpoint) добавляение новой точнки траектории Arguments Type Intent Optional Attributes Name class( Trajectory ), intent(inout) :: this class( TrajectoryPoint ), intent(in) :: tpoint procedure, public :: write_info => write_info_method public  subroutine write_info_method (this, iu) сохранение в файл информации о траектории Arguments Type Intent Optional Attributes Name class( Trajectory ), intent(inout) :: this integer, intent(in) :: iu","tags":"","loc":"type\\trajectory.html"},{"title":"DrivenCurrent – FRTС project ","text":"type, public :: DrivenCurrent Components Type Visibility Attributes Name Initial real(kind=wp), public :: cu ??  может лучше cuj real(kind=wp), public :: cu0 ??              cujoh real(kind=wp), public :: c ?? real(kind=wp), public :: c0 ?? real(kind=wp), public, dimension(:), allocatable :: outj outj(i)  = LH driven current density, MA/m&#94;2 real(kind=wp), public, dimension(:), allocatable :: ohj integer, public :: grid_size Constructor public        interface DrivenCurrent public  function DrivenCurrent_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( DrivenCurrent ) Type-Bound Procedures procedure, public :: evaluate => DrivenCurrent_evaluate public  subroutine DrivenCurrent_evaluate (this, ROC) Arguments Type Intent Optional Attributes Name class( DrivenCurrent ), intent(inout) :: this real(kind=wp), intent(in) :: ROC","tags":"","loc":"type\\drivencurrent.html"},{"title":"DrivenCurrentResult – FRTС project ","text":"type, public :: DrivenCurrentResult Components Type Visibility Attributes Name Initial real(kind=wp), public :: cup real(kind=wp), public :: cp real(kind=wp), public :: cum real(kind=wp), public :: cm real(kind=wp), public :: cup0 real(kind=wp), public :: cp0 real(kind=wp), public :: cum0 real(kind=wp), public :: cm0 Constructor public        interface DrivenCurrentResult public  function DrivenCurrentResult_constructor (positive_dc, negative_dc) result(this) Arguments Type Intent Optional Attributes Name type( DrivenCurrent ), intent(in) :: positive_dc type( DrivenCurrent ), intent(in) :: negative_dc Return Value type( DrivenCurrentResult ) Type-Bound Procedures procedure, public :: print => driven_current_result_print public  subroutine driven_current_result_print (this, time) Arguments Type Intent Optional Attributes Name class( DrivenCurrentResult ), intent(in) :: this real(kind=wp), intent(in) :: time procedure, public :: save => driven_current_result_save public  subroutine driven_current_result_save (this, time) Arguments Type Intent Optional Attributes Name class( DrivenCurrentResult ), intent(in) :: this real(kind=wp), intent(in) :: time","tags":"","loc":"type\\drivencurrentresult.html"},{"title":"IterationResult – FRTС project ","text":"type, public :: IterationResult Components Type Visibility Attributes Name Initial integer, public :: number iteration number 'iteration=',iterat integer, public :: spectr_direction 'ispectr=',ispectr real(kind=wp), public :: P_launched P_launched, MW=',plaun real(kind=wp), public :: P_landau 'P_landau, MW=',ol real(kind=wp), public :: P_coll 'P_coll, MW=',oc real(kind=wp), public :: P_alph 'P_alph, MW=',oa real(kind=wp), public :: alphas_power 'Alphas power, MW=',fuspow real(kind=wp), public :: P_fast real(kind=wp), public :: P_lost real(kind=wp), public :: P_not_accounted real(kind=wp), public :: P_landau_strong_absorption real(kind=wp), public :: P_landau_weak_absorption real(kind=wp), public :: P_turns real(kind=wp), public :: efficiency real(kind=wp), public :: avedens real(kind=wp), public :: r0 real(kind=wp), public :: eta_eff real(kind=wp), public :: residual невязка 'nevyazka=', pchg Type-Bound Procedures procedure, public :: print => iteration_result_print public  subroutine iteration_result_print (this) Arguments Type Intent Optional Attributes Name class( IterationResult ), intent(in) :: this procedure, public :: save => iteration_result_save public  subroutine iteration_result_save (this, time_stamp) save Iteration Result to file Arguments Type Intent Optional Attributes Name class( IterationResult ), intent(in) :: this real(kind=wp), intent(in) :: time_stamp","tags":"","loc":"type\\iterationresult.html"},{"title":"SpectrumPoint – FRTС project ","text":"type, public :: SpectrumPoint Components Type Visibility Attributes Name Initial real(kind=wp), public :: Ntor Ntau=-Ntor real(kind=wp), public :: Npol Ntet=Npol real(kind=wp), public :: power power","tags":"","loc":"type\\spectrumpoint.html"},{"title":"Spectrum – FRTС project ","text":"type, public :: Spectrum Components Type Visibility Attributes Name Initial integer, public :: size size of spectrum real(kind=wp), public :: input_power power of spectrum real(kind=wp), public :: power_ratio доля входной мощности real(kind=wp), public :: max_power real(kind=wp), public :: sum_power суммарная power integer, public :: direction направление спектра   +1 или -1 или 0 - полный type( SpectrumPoint ), public, allocatable :: data (:) Constructor public        interface Spectrum public  function spectrum_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( Spectrum ) Type-Bound Procedures procedure, public :: get_positive_part => get_positive_part_method public  function get_positive_part_method (this) result(spectr) Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(in) :: this Return Value type( Spectrum ) procedure, public :: get_negative_part => get_negative_part_method public  function get_negative_part_method (this) result(spectr) Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(in) :: this Return Value type( Spectrum ) procedure, public :: calc_max_power => calc_max_power_method public  subroutine calc_max_power_method (this) Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(inout) :: this procedure, public :: normalization => normalization_method public  subroutine normalization_method (this) Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(inout) :: this procedure, public :: integral_trapez => integral_trapez_method public  function integral_trapez_method (this) result(sum) вычисление полной мощности спектра\nинтегрирование методом трапеций Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(in) :: this Return Value real(kind=wp) procedure, public :: write => write_spectrum public  subroutine write_spectrum (this, spectrum_name) write spectrum to file Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(inout) :: this character(len=*), intent(in) :: spectrum_name","tags":"","loc":"type\\spectrum.html"},{"title":"Iderivs_func – FRTС project","text":"interface public  subroutine Iderivs_func(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y (:) real(kind=wp), intent(inout) :: dydx (:)","tags":"","loc":"interface\\iderivs_func.html"},{"title":"drivencurrent95 – FRTС project","text":"subroutine drivencurrent95(outj, sigmaj, UPL, NRD, NA1, TIME, TAU, ROC, RTOR, GP2) Uses FokkerPlanck_module driven_current_module outj(i)  = LH driven current density, MA/m&#94;2\n   dndt(i)  = d&#94;2Jr1/dt&#94;2/E, MA/m&#94;2/sec&#94;2/(V/m), ~runaway d(el.density)/dt/E\n   djdt(i)  = dJr2/dt, time drivative of runaway current Jr2, MA/m&#94;2/sec\n   outjrun(i)  = LH driven runaway current density, MA/m&#94;2\n   outnerun(i) = runaway electron density/10&#94;19 m&#94;-3 variant\n!!       write( , ) i,outj(i) Arguments Type Intent Optional Attributes Name real(kind=8) :: outj (NRD) real(kind=8) :: sigmaj (NRD) double precision :: UPL (NRD) integer :: NRD integer :: NA1 double precision :: TIME double precision :: TAU double precision :: ROC double precision :: RTOR double precision :: GP2","tags":"","loc":"proc\\drivencurrent95.html"},{"title":"lhcurrent – FRTС project","text":"subroutine lhcurrent(driven_current, ispectr) Uses plasma math_module maxwell rt_parameters driven_current_module lock_module implicit real 8 (a-h,o-z)\nwrite( , )\nwrite( , )'ccur',ccur,' curdir=',curdir,' nr=',nr\nwrite( ,*)'cu_out, MA=',cu_out,' cfull, A=',cfull\n     close(111) Arguments Type Intent Optional Attributes Name type( DrivenCurrent ), intent(inout) :: driven_current integer, intent(in) :: ispectr","tags":"","loc":"proc\\lhcurrent.html"},{"title":"sys_time – FRTС project","text":"public  function sys_time() Arguments None Return Value real(kind=wp)","tags":"","loc":"proc\\sys_time.html"},{"title":"Time_start – FRTС project","text":"public  subroutine Time_start(this, fn, pt) Type Bound Timer Arguments Type Intent Optional Attributes Name class( Timer ), intent(inout) :: this character(len=*), intent(in) :: fn real(kind=wp), intent(in) :: pt","tags":"","loc":"proc\\time_start.html"},{"title":"Time_stop – FRTС project","text":"public  subroutine Time_stop(this) Type Bound Timer Arguments Type Intent Optional Attributes Name class( Timer ), intent(inout) :: this","tags":"","loc":"proc\\time_stop.html"},{"title":"Time_stop_and_save – FRTС project","text":"public  subroutine Time_stop_and_save(this) Type Bound Timer Arguments Type Intent Optional Attributes Name class( Timer ), intent(inout) :: this","tags":"","loc":"proc\\time_stop_and_save.html"},{"title":"calculate_metrics – FRTС project","text":"public  subroutine calculate_metrics(pa, ptet) Uses plasma rt_parameters constants approximation Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: pa real(kind=wp), intent(in) :: ptet","tags":"","loc":"proc\\calculate_metrics.html"},{"title":"calculate_dielectric_tensor – FRTС project","text":"public  subroutine calculate_dielectric_tensor(pa) Uses plasma rt_parameters constants calculate components of dielectric tensor Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: pa","tags":"","loc":"proc\\calculate_dielectric_tensor.html"},{"title":"calculate_dispersion_equation – FRTС project","text":"public  subroutine calculate_dispersion_equation(yn2, yn3) Uses plasma rt_parameters constants dielectric_tensor Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: yn2 real(kind=wp), intent(in) :: yn3","tags":"","loc":"proc\\calculate_dispersion_equation.html"},{"title":"calculate_partial_derivatives – FRTС project","text":"public  subroutine calculate_partial_derivatives(yn2, yn3, dl1, ynpopq, al, bl, dl2, prt, prm) Uses plasma dielectric_tensor constants dispersion_equation rt_parameters metrics Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: yn2 real(kind=wp), intent(in) :: yn3 real(kind=wp), intent(in) :: dl1 real(kind=wp), intent(in) :: ynpopq real(kind=wp), intent(in) :: al real(kind=wp), intent(in) :: bl real(kind=wp), intent(in) :: dl2 real(kind=wp), intent(out) :: prt real(kind=wp), intent(out) :: prm","tags":"","loc":"proc\\calculate_partial_derivatives.html"},{"title":"zatukh – FRTС project","text":"public  function zatukh(psy, j, u, n) Uses constants Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: psy integer, intent(in) :: j real(kind=wp), intent(in) :: u (:,:) integer, intent(in) :: n Return Value real(kind=wp)","tags":"","loc":"proc\\zatukh.html"},{"title":"calculate_decrements – FRTС project","text":"public  subroutine calculate_decrements(pa, yn2, ptet, yn3, ynpopq, xnr, jr, izn) Uses iterator_mod plasma constants source_new_mod rt_parameters dispersion_equation dielectric_tensor metrics pdec1=-pdecv*dfdv Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: pa real(kind=wp), intent(in) :: yn2 real(kind=wp), intent(in) :: ptet real(kind=wp), intent(in) :: yn3 real(kind=wp), intent(in) :: ynpopq real(kind=wp), intent(in) :: xnr integer, intent(in) :: jr integer, intent(in) :: izn","tags":"","loc":"proc\\calculate_decrements.html"},{"title":"dhdomega – FRTС project","text":"public  function dhdomega(rho, theta, yn1, yn2) result(znak) Uses decrements вычисляет znakstart\n!!!\nw*dH/dw=wdhdw: Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: rho real(kind=wp), intent(in) :: theta real(kind=wp), intent(inout) :: yn1 real(kind=wp), intent(in) :: yn2 Return Value real(kind=wp)","tags":"","loc":"proc\\dhdomega.html"},{"title":"disp2_ider0 – FRTС project","text":"public  subroutine disp2_ider0(pa, yn2, ptet, xnro) Uses constants rt_parameters dispersion_equation dielectric_tensor metrics Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: pa real(kind=wp), intent(in) :: yn2 real(kind=wp), intent(in) :: ptet real(kind=wp), intent(out) :: xnro","tags":"","loc":"proc\\disp2_ider0.html"},{"title":"disp2 – FRTС project","text":"public  subroutine disp2(pa, yn2, ptet, xnro, prt, prm) Uses constants rt_parameters dispersion_equation decrements partial_derivatives dielectric_tensor metrics Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: pa real(kind=wp), intent(in) :: yn2 real(kind=wp), intent(in) :: ptet real(kind=wp), intent(out) :: xnro real(kind=wp), intent(out) :: prt real(kind=wp), intent(out) :: prm","tags":"","loc":"proc\\disp2.html"},{"title":"disp2_iroot3 – FRTС project","text":"public  subroutine disp2_iroot3(pa, yn2, ptet, xnro, pg1, pg2, pg3, pg4) Uses constants rt_parameters dispersion_equation dielectric_tensor metrics Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: pa real(kind=wp), intent(in) :: yn2 real(kind=wp), intent(in) :: ptet real(kind=wp), intent(in) :: xnro real(kind=wp), intent(out) :: pg1 real(kind=wp), intent(out) :: pg2 real(kind=wp), intent(out) :: pg3 real(kind=wp), intent(out) :: pg4","tags":"","loc":"proc\\disp2_iroot3.html"},{"title":"disp2_iroot2 – FRTС project","text":"public  subroutine disp2_iroot2(pa, yn2, ptet, prt, prm) Uses constants rt_parameters dispersion_equation decrements dielectric_tensor metrics !!!\nold variant: !!!!!!!!!!!! new variant: Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: pa real(kind=wp), intent(in) :: yn2 real(kind=wp), intent(in) :: ptet real(kind=wp), intent(out) :: prt real(kind=wp), intent(out) :: prm","tags":"","loc":"proc\\disp2_iroot2.html"},{"title":"disp4 – FRTС project","text":"public  subroutine disp4(in_pa, ptet, xnr, yn2) Uses plasma approximation constants source_new_mod rt_parameters dispersion_equation decrements metrics !!!\n      pn=fn1(pa,fnr)\n      pn=fn2(pa,fnr,fnrr)\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n      dl=bs 2-4d0 as bs Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: in_pa real(kind=wp), intent(in) :: ptet real(kind=wp), intent(inout) :: xnr real(kind=wp), intent(in) :: yn2","tags":"","loc":"proc\\disp4.html"},{"title":"extd4 – FRTС project","text":"public  subroutine extd4(x, y, dydx) Uses decrements !!! Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y (:) real(kind=wp), intent(inout) :: dydx (:)","tags":"","loc":"proc\\extd4.html"},{"title":"fokkerplanck_compute – FRTС project","text":"public  subroutine fokkerplanck_compute(time, TAU) Uses utils plasma writer_module maxwell FokkerPlanck1D_mod rt_parameters Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: time real(kind=wp), intent(in) :: TAU","tags":"","loc":"proc\\fokkerplanck_compute.html"},{"title":"init_diffusion – FRTС project","text":"public  subroutine init_diffusion(h, n, vj, dj, d1, d2, d3) Uses lock_module Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: h integer, intent(in) :: n real(kind=wp), intent(in), dimension(:) :: vj real(kind=wp), intent(in), dimension(:) :: dj real(kind=wp), intent(out), dimension(:) :: d1 real(kind=wp), intent(out), dimension(:) :: d2 real(kind=wp), intent(out), dimension(:) :: d3","tags":"","loc":"proc\\init_diffusion.html"},{"title":"fn – FRTС project","text":"public  function fn(x) Uses spline_module constants plasma  density,  cm&#94;-3 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp)","tags":"","loc":"proc\\fn.html"},{"title":"fvt – FRTС project","text":"public  function fvt(r) нет описания Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r Return Value real(kind=wp)","tags":"","loc":"proc\\fvt.html"},{"title":"fn1 – FRTС project","text":"public  function fn1(x, fnp) Uses spline_module constants plasma density and its derivative Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(out) :: fnp Return Value real(kind=wp)","tags":"","loc":"proc\\fn1.html"},{"title":"fn2 – FRTС project","text":"public  function fn2(r, fnp, fnpp) Uses chebyshev constants plasma density and its first and second derivatives Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r real(kind=wp), intent(out) :: fnp real(kind=wp), intent(out) :: fnpp Return Value real(kind=wp)","tags":"","loc":"proc\\fn2.html"},{"title":"ft – FRTС project","text":"public  function ft(x) Uses spline_module constants electron temperature, erg\n     ft=y            ! kev Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp)","tags":"","loc":"proc\\ft.html"},{"title":"fti – FRTС project","text":"public  function fti(x) Uses spline_module constants ion temperature, kev Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp)","tags":"","loc":"proc\\fti.html"},{"title":"zefff – FRTС project","text":"public  function zefff(x) Uses spline_module constants z_effective profile Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp)","tags":"","loc":"proc\\zefff.html"},{"title":"obeom – FRTС project","text":"public  function obeom(ptet, pa) Uses constants approximation Arguments Type Intent Optional Attributes Name real :: ptet real :: pa Return Value real(kind=wp)","tags":"","loc":"proc\\obeom.html"},{"title":"ploshad – FRTС project","text":"public  function ploshad(ptet, pa) Uses constants approximation Arguments Type Intent Optional Attributes Name real :: ptet real :: pa Return Value real(kind=wp)","tags":"","loc":"proc\\ploshad.html"},{"title":"gaussint – FRTС project","text":"public  function gaussint(f, a, b, r, eps) что-то про гаусс Arguments Type Intent Optional Attributes Name real(kind=wp) :: f real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: r real(kind=wp) :: eps Return Value real(kind=wp)","tags":"","loc":"proc\\gaussint.html"},{"title":"init_plasma – FRTС project","text":"public  subroutine init_plasma(NA1, ABC, BTOR, RTOR, UPDWN, GP2, AMETR, RHO, SHIF, ELON, TRIA, MU, NE, TE, TI, ZEF, UPL) Uses approximation math_module constants spline_module chebyshev rt_parameters variant\n amy=(btor/q) rho (drho/dr) is a function of \"minor radius\" r=rh(i).\n Poloidal magnetic field: B_pol=amy(r)*sqrt(g22/g), where g is\n determinant of 3D metric tensor and g22 is the (22) element of\n the tensor, normalized on ABC&#94;4 and ABC&#94;2, correspondingly. Polinomial approximation of the amy(r): !!!!!!!!!!!!! spline approximation of plasma profiles !!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name integer, intent(in) :: NA1 real(kind=wp), intent(in) :: ABC real(kind=wp), intent(in) :: BTOR real(kind=wp), intent(in) :: RTOR real(kind=wp), intent(in) :: UPDWN real(kind=wp), intent(in) :: GP2 real(kind=wp), dimension(*) :: AMETR real(kind=wp), dimension(*) :: RHO real(kind=wp), dimension(*) :: SHIF real(kind=wp), dimension(*) :: ELON real(kind=wp), dimension(*) :: TRIA real(kind=wp), dimension(*) :: MU real(kind=wp), dimension(*) :: NE real(kind=wp), dimension(*) :: TE real(kind=wp), dimension(*) :: TI real(kind=wp), dimension(*) :: ZEF real(kind=wp), dimension(*) :: UPL","tags":"","loc":"proc\\init_plasma.html"},{"title":"init_parameters – FRTС project","text":"public  subroutine init_parameters() Uses rt_parameters constants approximation !!!!!!      ptkev=ft(zero)/0.16d-8  !Te in keV\n      ccurnr=pqe pqe 0.333d-9/pme Arguments None","tags":"","loc":"proc\\init_parameters.html"},{"title":"write_plasma – FRTС project","text":"public  subroutine write_plasma(time_stamp) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: time_stamp","tags":"","loc":"proc\\write_plasma.html"},{"title":"write_lcms – FRTС project","text":"public  subroutine write_lcms() Uses constants approximation write lcms Arguments None","tags":"","loc":"proc\\write_lcms.html"},{"title":"find_volums_and_surfaces – FRTС project","text":"public  subroutine find_volums_and_surfaces() Uses rt_parameters constants Arguments None","tags":"","loc":"proc\\find_volums_and_surfaces.html"},{"title":"calc_enorm – FRTС project","text":"public  subroutine calc_enorm() Uses constants maxwell rt_parameters spline_module lock_module fst(j)=pn xlogj c0 4/pi4/vt 3 Arguments None","tags":"","loc":"proc\\calc_enorm.html"},{"title":"init_maxwell – FRTС project","text":"public  subroutine init_maxwell() Uses spline_module rt_parameters constants maxwell Arguments None","tags":"","loc":"proc\\init_maxwell.html"},{"title":"rplusk – FRTС project","text":"public  function rplusk(x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp)","tags":"","loc":"proc\\rplusk.html"},{"title":"rplusk2 – FRTС project","text":"public  function rplusk2(x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp)","tags":"","loc":"proc\\rplusk2.html"},{"title":"rmink – FRTС project","text":"public  function rmink(x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp)","tags":"","loc":"proc\\rmink.html"},{"title":"rmink2 – FRTС project","text":"public  function rmink2(x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp)","tags":"","loc":"proc\\rmink2.html"},{"title":"rs – FRTС project","text":"public  function rs(x, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp)","tags":"","loc":"proc\\rs.html"},{"title":"qf – FRTС project","text":"public  function qf(x) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp)","tags":"","loc":"proc\\qf.html"},{"title":"k2 – FRTС project","text":"public  function k2(x, dif) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif Return Value real(kind=wp)","tags":"","loc":"proc\\k2.html"},{"title":"kinv – FRTС project","text":"public  function kinv(x, dif) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif Return Value real(kind=wp)","tags":"","loc":"proc\\kinv.html"},{"title":"kinv2 – FRTС project","text":"public  function kinv2(x, dif) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif Return Value real(kind=wp)","tags":"","loc":"proc\\kinv2.html"},{"title":"savelyev_solver – FRTС project","text":"public  subroutine savelyev_solver(alfa2, nt, h, dt, n, ybeg, yend, d1, d2, d3, y) разностная схема Савельева для уравнения Фоккера-Планка Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 integer, intent(in) :: nt real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: d1 (n+1) real(kind=wp), intent(in) :: d2 (n+1) real(kind=wp), intent(in) :: d3 (n+1) real(kind=wp), intent(inout) :: y (n)","tags":"","loc":"proc\\savelyev_solver.html"},{"title":"savelyev_abccoef – FRTС project","text":"public  subroutine savelyev_abccoef(alfa2, a, b, c, f, y, dt, n, ybeg, yend, xx, h, d1, d2, d3) -- fill abc matrix Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 real(kind=wp), intent(inout) :: a (n) real(kind=wp), intent(inout) :: b (n) real(kind=wp), intent(inout) :: c (n) real(kind=wp), intent(inout) :: f (n) real(kind=wp), intent(inout) :: y (n) real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: xx (n+1) real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: d1 (n+1) real(kind=wp), intent(in) :: d2 (n+1) real(kind=wp), intent(in) :: d3 (n+1)","tags":"","loc":"proc\\savelyev_abccoef.html"},{"title":"tridag – FRTС project","text":"public  subroutine tridag(a, b, c, r, u, n) создает трехдиагональнйю матрицу Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (n) real(kind=wp), intent(in) :: b (n) real(kind=wp), intent(in) :: c (n) real(kind=wp), intent(in) :: r (n) real(kind=wp), intent(inout) :: u (n) integer, intent(in) :: n","tags":"","loc":"proc\\tridag.html"},{"title":"init_trajectory – FRTС project","text":"public  subroutine init_trajectory() Uses driver_module constants Arguments None","tags":"","loc":"proc\\init_trajectory.html"},{"title":"view – FRTС project","text":"public  subroutine view(tview, ispectr, nnz, ntet) Uses driver_module iterator_mod approximation constants rt_parameters trajectory_data decrements plasma !writing trajectories into a file\n          pintld=-dland(i) (dflf+dfrt)/2d0\n          pdec1=-pdecv df Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: tview integer, intent(in) :: ispectr integer, intent(in) :: nnz integer, intent(in) :: ntet","tags":"","loc":"proc\\view.html"},{"title":"tracing – FRTС project","text":"public  subroutine tracing(traj, nmax, nb1, nb2, pabs) Uses constants rt_parameters dispersion_equation trajectory_data driver_module dispersion_module Arguments Type Intent Optional Attributes Name class( Trajectory ), intent(inout) :: traj integer, intent(inout) :: nmax integer, intent(inout) :: nb1 integer, intent(inout) :: nb2 real(kind=wp), intent(in) :: pabs","tags":"","loc":"proc\\tracing.html"},{"title":"FokkerPlanck1D_constructor – FRTС project","text":"public  function FokkerPlanck1D_constructor(e, v_lim, v, f) result(this) конструктор для FokkerPlanck1D Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D )","tags":"","loc":"proc\\fokkerplanck1d_constructor.html"},{"title":"FokkerPlanck1D_print – FRTС project","text":"public  subroutine FokkerPlanck1D_print(this) Type Bound FokkerPlanck1D Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(in) :: this","tags":"","loc":"proc\\fokkerplanck1d_print.html"},{"title":"FokkerPlanck1D_init_zero_diffusion – FRTС project","text":"public  subroutine FokkerPlanck1D_init_zero_diffusion(this) Type Bound FokkerPlanck1D Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this","tags":"","loc":"proc\\fokkerplanck1d_init_zero_diffusion.html"},{"title":"FokkerPlanck1D_init_diffusion – FRTС project","text":"public  subroutine FokkerPlanck1D_init_diffusion(this, dif) Uses lock_module инициализация диффузии для схемы савельева Type Bound FokkerPlanck1D Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in), dimension(:) :: dif","tags":"","loc":"proc\\fokkerplanck1d_init_diffusion.html"},{"title":"FokkerPlanck1D_solve_time_step – FRTС project","text":"public  subroutine FokkerPlanck1D_solve_time_step(this, dt, nt) Uses lock_module !!!!!!!!!!   solve problem   !!!!!!!!!!!!!!!!!!!!!!!!!! Type Bound FokkerPlanck1D Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in) :: dt integer, intent(in) :: nt","tags":"","loc":"proc\\fokkerplanck1d_solve_time_step.html"},{"title":"burying_procedure – FRTС project","text":"public  subroutine burying_procedure(v, f0, df0) Uses math_module процедура закапывания Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (:) real(kind=8), intent(inout) :: f0 (:) real(kind=8), intent(inout), optional :: df0 (:)","tags":"","loc":"proc\\burying_procedure.html"},{"title":"FokkerPlanck1D – FRTС project","text":"public interface FokkerPlanck1D Module Procedures public  function FokkerPlanck1D_constructor (e, v_lim, v, f) result(this) конструктор для FokkerPlanck1D Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D )","tags":"","loc":"interface\\fokkerplanck1d.html"},{"title":"diff – FRTС project","text":"public  subroutine diff(x, y, n, dy) Arguments Type Intent Optional Attributes Name real :: x real :: y integer :: n real :: dy","tags":"","loc":"proc\\diff.html"},{"title":"integral – FRTС project","text":"public  subroutine integral(ibeg, iend, x, y, fout) Arguments Type Intent Optional Attributes Name integer :: ibeg integer :: iend real :: x real :: y real :: fout","tags":"","loc":"proc\\integral.html"},{"title":"fsmoth4 – FRTС project","text":"public  subroutine fsmoth4(x, y, n, ys) Uses constants approximation Arguments Type Intent Optional Attributes Name real :: x real :: y integer, intent(in) :: n real :: ys","tags":"","loc":"proc\\fsmoth4.html"},{"title":"polin – FRTС project","text":"public  function polin(k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=wp) :: x Return Value real(kind=wp)","tags":"","loc":"proc\\polin.html"},{"title":"polin1 – FRTС project","text":"public  function polin1(k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=wp) :: x Return Value real(kind=wp)","tags":"","loc":"proc\\polin1.html"},{"title":"polin2 – FRTС project","text":"public  function polin2(k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=wp) :: x Return Value real(kind=wp)","tags":"","loc":"proc\\polin2.html"},{"title":"fdf – FRTС project","text":"public  function fdf(x, c, n, df) result(p) вычисление значения полинома и его производной Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: c (n) integer, intent(in) :: n real(kind=wp), intent(out) :: df Return Value real(kind=wp)","tags":"","loc":"proc\\fdf.html"},{"title":"fdfddf – FRTС project","text":"public  function fdfddf(x, c, n, df, ddf) вычисление значения полинома и первой и второй производной Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: c (n) integer, intent(in) :: n real(kind=wp), intent(out) :: df real(kind=wp), intent(out) :: ddf Return Value real(kind=wp)","tags":"","loc":"proc\\fdfddf.html"},{"title":"approx – FRTС project","text":"public  subroutine approx(x, y, n, f, m, b) the data to be approximated. number of points in the input data. number of coefficients of decomposition\n       over base functions : found decomposition coefficients Arguments Type Intent Optional Attributes Name real(kind=wp) :: x (n) real(kind=wp) :: y (n) integer :: n real :: f integer :: m real(kind=wp) :: b (*)","tags":"","loc":"proc\\approx.html"},{"title":"ludcmp – FRTС project","text":"public  subroutine ludcmp(a, n, np, indx, d) Arguments Type Intent Optional Attributes Name real(kind=wp) :: a (np,np) integer :: n integer :: np real(kind=wp) :: indx (n) real :: d","tags":"","loc":"proc\\ludcmp.html"},{"title":"lubksb – FRTС project","text":"public  subroutine lubksb(a, n, np, indx, b) Arguments Type Intent Optional Attributes Name real(kind=wp) :: a (np,np) integer :: n integer :: np real(kind=wp) :: indx (n) real(kind=wp) :: b (n)","tags":"","loc":"proc\\lubksb.html"},{"title":"binary_write_array – FRTС project","text":"public  subroutine binary_write_array(v, a, time, array_name) сохраняет массивы расределения и скорости Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: v (:,:) real(kind=wp), intent(in) :: a (:,:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name","tags":"","loc":"proc\\binary_write_array.html"},{"title":"write_v_array – FRTС project","text":"public  subroutine write_v_array(v, a, time, array_name) сохраняет массивы расределения и скорости Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: v (:,:) real(kind=wp), intent(in) :: a (:,:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name","tags":"","loc":"proc\\write_v_array.html"},{"title":"write_x_array – FRTС project","text":"public  subroutine write_x_array(x, arr, time, array_name) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:,:) real(kind=wp), intent(in) :: arr (:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name","tags":"","loc":"proc\\write_x_array.html"},{"title":"write_matrix – FRTС project","text":"public  subroutine write_matrix(arr, time, array_name) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: arr (:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name","tags":"","loc":"proc\\write_matrix.html"},{"title":"write_array – FRTС project","text":"public  subroutine write_array(arr, N, array_name) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: arr (*) integer, intent(in) :: N character(len=*), intent(in) :: array_name","tags":"","loc":"proc\\write_array.html"},{"title":"write_distribution – FRTС project","text":"public  subroutine write_distribution(arr, N, time) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: arr (*) integer, intent(in) :: N real(kind=wp), intent(in) :: time","tags":"","loc":"proc\\write_distribution.html"},{"title":"source_new – FRTС project","text":"public  subroutine source_new(r, out) Uses lock_module Arguments Type Intent Optional Attributes Name real :: r real :: out","tags":"","loc":"proc\\source_new.html"},{"title":"distr – FRTС project","text":"public  subroutine distr(vz, j, ifound, fder) Uses lock_module Arguments Type Intent Optional Attributes Name real(kind=8) :: vz integer, intent(in) :: j integer, intent(inout) :: ifound real(kind=8) :: fder","tags":"","loc":"proc\\distr.html"},{"title":"ourlhcd2017 – FRTС project","text":"public  subroutine ourlhcd2017(spectr, outpe, pe_out) Uses iteration_result_mod maxwell approximation current math_module trajectory_module source_new_mod manager_mod lock_module dispersion_module plasma iterator_mod spectrum_mod decrements spline_module chebyshev driven_current_module rt_parameters constants !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!sav2008       pn=fn(r)\n       pn=fn1(r,fnr)\n       pn=fn2(r,fnr,fnrr) !sav2008\n!!!!!!!read data !!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!sign of driven current in right coordinate system {dro,dteta,dfi}:\n!!!curdir=+1.0 for current drive in positive direction \"dfi\"\n!!!curdir=-1.0 for current drive in negative direction \"dfi\"\n!!!spectrum Nz>0 is along dfi>0 and Nz<0 is along dfi<0\n!!!it is also OK if Npar is used instead of Nz, but for Btor>0, that is along dfi>0\n      curdir=-dble(ispectr)\n!!!!!!!!!!!!! begin iterations !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n   find nevyazka !!!!!!! prepare to the next iteration !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!      if(q_cond.le.pabs0.and.pchg.lt.pgiter) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!                         and multiplied by 10&#94;-10 in dfind()\n!old       dconst=vt0/(cnyfoc pme pn 2)\n!        dj(i)=dql(i,j) dconst vto !D_normir\n!         call linf(vrj,dj,vij(i,j),ddout,klo,khi)\n         if(ddout.le.1.d0) ddout=zero Arguments Type Intent Optional Attributes Name type( Spectrum ) :: spectr real(kind=8), dimension(*) :: outpe real(kind=8) :: pe_out","tags":"","loc":"proc\\ourlhcd2017.html"},{"title":"init_iteration – FRTС project","text":"public  subroutine init_iteration() Uses iterator_mod current constants rt_parameters plasma Arguments None","tags":"","loc":"proc\\init_iteration.html"},{"title":"gridvel – FRTС project","text":"public  subroutine gridvel(v1, v2, vmax, cdel, ni1, ni2, ipt1, kpt3, vrj) v12<v<=v2 Arguments Type Intent Optional Attributes Name double precision :: v1 double precision :: v2 double precision :: vmax double precision :: cdel integer :: ni1 integer :: ni2 integer :: ipt1 integer :: kpt3 double precision :: vrj (*)","tags":"","loc":"proc\\gridvel.html"},{"title":"recalculate_f_for_a_new_mesh – FRTС project","text":"public  subroutine recalculate_f_for_a_new_mesh(ispectr) Uses iterator_mod current lock_module constants maxwell rt_parameters plasma recalculate f' for a new mesh\n!         if(vrj(i).gt.vvj(i0)) exit Arguments Type Intent Optional Attributes Name integer, intent(in) :: ispectr","tags":"","loc":"proc\\recalculate_f_for_a_new_mesh.html"},{"title":"alphas – FRTС project","text":"public  subroutine alphas(d, u, j, kmax, g) Uses decrements constants Arguments Type Intent Optional Attributes Name real :: d real :: u integer, intent(in) :: j integer, intent(in) :: kmax real :: g","tags":"","loc":"proc\\alphas.html"},{"title":"rkqc – FRTС project","text":"public  subroutine rkqc(y, dydx, n, x, htry, eps, yscal, hdid, hnext, derivs) Uses constants Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: y (n) real(kind=wp), intent(inout) :: dydx (n) integer, intent(in) :: n real(kind=wp), intent(inout) :: x real(kind=wp), intent(in) :: htry real(kind=wp), intent(in) :: eps real(kind=wp), intent(in) :: yscal (n) real(kind=wp), intent(inout) :: hdid real(kind=wp), intent(inout) :: hnext procedure( Iderivs_func ) :: derivs","tags":"","loc":"proc\\rkqc.html"},{"title":"rk4 – FRTС project","text":"public  subroutine rk4(y, dydx, n, x, h, yout, derivs) Arguments Type Intent Optional Attributes Name real :: y real :: dydx integer, intent(in) :: n real :: x real :: h real :: yout procedure( Iderivs_func ) :: derivs","tags":"","loc":"proc\\rk4.html"},{"title":"runge_kutta_qs – FRTС project","text":"public  subroutine runge_kutta_qs(y, dydx, n, x, htry, eps, yscal, hdid, hnext, derivs) метод рунге-кутта Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: y (n) real(kind=wp), intent(inout) :: dydx (n) integer, intent(in) :: n real(kind=wp), intent(inout) :: x real(kind=wp), intent(in) :: htry real(kind=wp), intent(in) :: eps real(kind=wp), intent(in) :: yscal (n) real(kind=wp), intent(inout) :: hdid real(kind=wp), intent(inout) :: hnext procedure( Iderivs_func ) :: derivs","tags":"","loc":"proc\\runge_kutta_qs.html"},{"title":"rkck – FRTС project","text":"public  subroutine rkck(y, dydx, n, x, h, yout, yerr, derivs) метод рунге-кутта, нужны подробности Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: y (n) real(kind=wp), intent(in) :: dydx (n) integer, intent(in) :: n real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: h real(kind=wp), intent(out) :: yout (n) real(kind=wp), intent(out) :: yerr (n) procedure( Iderivs_func ) :: derivs","tags":"","loc":"proc\\rkck.html"},{"title":"find_achieved_radial_points – FRTС project","text":"public  subroutine find_achieved_radial_points(nvpt) Uses rt_parameters find achieved radial points jbeg-jend Arguments Type Intent Optional Attributes Name integer, intent(in) :: nvpt","tags":"","loc":"proc\\find_achieved_radial_points.html"},{"title":"dfind – FRTС project","text":"public  subroutine dfind(j, i, v, powpr, pil, pic, pia, df, decv, refr, vlf, vrt, ifast) Uses plasma rt_parameters constants pchgl=powpr*(1.d0-dexp(-2d0*pil))\n   pchgc=powpr*dexp(-2d0*pil)*dabs(-2d0*pic)\n   pchga=powpr*dexp(-2d0*pil)*dabs(-2d0*pia) !        adde=zze (dd/dens(j)) weight\n!        e2perp(i,j)=e2perp(i,j)+adde Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: i real(kind=wp), intent(in) :: v real(kind=wp), intent(in) :: powpr real(kind=wp), intent(in) :: pil real(kind=wp), intent(in) :: pic real(kind=wp), intent(in) :: pia real(kind=wp), intent(in) :: df real(kind=wp), intent(in) :: decv real(kind=wp), intent(in) :: refr real(kind=wp), intent(in) :: vlf real(kind=wp), intent(in) :: vrt integer, intent(in) :: ifast","tags":"","loc":"proc\\dfind.html"},{"title":"linf – FRTС project","text":"public  subroutine linf(x, y, t, fout, klo, khi) линейная аппроксимация\nTODO будет удобнее если переделать в функцию Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (*) real(kind=wp), intent(in) :: y (*) real(kind=wp), intent(in) :: t real(kind=wp), intent(out) :: fout integer, intent(in) :: klo integer, intent(in) :: khi","tags":"","loc":"proc\\linf.html"},{"title":"lock – FRTС project","text":"public  subroutine lock(xa, n, x, klo, khi, ierr) что делает? Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xa (*) integer, intent(in) :: n real(kind=wp), intent(in) :: x integer, intent(inout) :: klo integer, intent(inout) :: khi integer, intent(inout) :: ierr","tags":"","loc":"proc\\lock.html"},{"title":"lock2 – FRTС project","text":"public  subroutine lock2(xa, n, x, klo, khi, ierr) Uses constants что делает Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xa (*) integer, intent(in) :: n real(kind=wp), intent(in) :: x integer, intent(inout) :: klo integer, intent(inout) :: khi integer, intent(inout) :: ierr","tags":"","loc":"proc\\lock2.html"},{"title":"show_constants – FRTС project","text":"public  subroutine show_constants() Arguments None","tags":"","loc":"proc\\show_constants.html"},{"title":"show_parameters – FRTС project","text":"public  subroutine show_parameters() Arguments None","tags":"","loc":"proc\\show_parameters.html"},{"title":"read_parameters – FRTС project","text":"public  subroutine read_parameters(file_name) !!!!!!!!!!!  read  physical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read parameters for alphas calculation !!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read  numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read grill parameters and input LH spectrum !!!!!!!!!!!!\n!!!!!!!!!!! checking initial parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name character(len=*) :: file_name","tags":"","loc":"proc\\read_parameters.html"},{"title":"dql1 – FRTС project","text":"public  function dql1(ifound, jfoundr, pabs) result(powccc) Uses iterator_mod current constants rt_parameters decrements dispersion_module plasma pintld=-pintld4*dfdv Arguments Type Intent Optional Attributes Name integer, intent(in) :: ifound integer, intent(in) :: jfoundr real(kind=wp), intent(in) :: pabs Return Value real(kind=wp)","tags":"","loc":"proc\\dql1.html"},{"title":"memorize_trajectory_point4 – FRTС project","text":"public  subroutine memorize_trajectory_point4(ro, theta) Uses decrements rt_parameters Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ro real(kind=wp), intent(in) :: theta","tags":"","loc":"proc\\memorize_trajectory_point4.html"},{"title":"memorize_trajectory_point – FRTС project","text":"public  subroutine memorize_trajectory_point(vz, j, ro, powccc, driver) Uses decrements dispersion_module trajectory_data plasma memorize trajectory point Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vz integer, intent(in) :: j real(kind=wp), intent(in) :: ro real(kind=wp), intent(in) :: powccc integer, intent(in) :: driver","tags":"","loc":"proc\\memorize_trajectory_point.html"},{"title":"driver2 – FRTС project","text":"public  subroutine driver2(ystart, x1, x2, xsav, hmin, h1, pabs) Uses constants rt_parameters dispersion_equation decrements dispersion_module solve eqs. starting from xbeg\nystart(1) = tet\nystart(2) = xm\nx1 = xbeg rini\nx2 = xend Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ystart (2) real(kind=wp), intent(in) :: x1 real(kind=wp), intent(inout) :: x2 real(kind=wp), intent(inout) :: xsav real(kind=wp), intent(in) :: hmin real(kind=wp), intent(in) :: h1 real(kind=wp), intent(in) :: pabs","tags":"","loc":"proc\\driver2.html"},{"title":"extd2 – FRTС project","text":"public  subroutine extd2(x, y, dydx) Uses dispersion_module Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y (:) real(kind=wp), intent(inout) :: dydx (:)","tags":"","loc":"proc\\extd2.html"},{"title":"difeq – FRTС project","text":"public  subroutine difeq(y, dydx, nv, x, htry, eps, yscal, hdid, hnext, derivs) Uses runge_kutta_module rt_parameters ! зачем save ????? Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: y (nv) real(kind=wp), intent(in) :: dydx (nv) integer, intent(in) :: nv real(kind=wp), intent(inout) :: x real(kind=wp), intent(in) :: htry real(kind=wp), intent(in) :: eps real(kind=wp), intent(inout) :: yscal (nv) real(kind=wp), intent(inout) :: hdid real(kind=wp), intent(inout) :: hnext procedure( Iderivs_func ) :: derivs","tags":"","loc":"proc\\difeq.html"},{"title":"mmid – FRTС project","text":"public  subroutine mmid(y, dydx, nvar, xs, htot, nstep, yout, derivs) Uses runge_kutta_module dispersion_module Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: y (nvar) real(kind=wp), intent(in) :: dydx (nvar) integer, intent(in) :: nvar real(kind=wp), intent(in) :: xs real(kind=wp), intent(in) :: htot integer, intent(in) :: nstep real(kind=wp), intent(inout) :: yout (nvar) procedure( Iderivs_func ) :: derivs","tags":"","loc":"proc\\mmid.html"},{"title":"rzextr – FRTС project","text":"public  subroutine rzextr(iest, xest, yest, yz, dy, nv) rational extrapolation\nзачем save ???? Arguments Type Intent Optional Attributes Name integer, intent(in) :: iest real(kind=wp), intent(in) :: xest real(kind=wp), intent(in) :: yest (nv) real(kind=wp), intent(inout) :: yz (nv) real(kind=wp), intent(inout) :: dy (nv) integer, intent(in) :: nv","tags":"","loc":"proc\\rzextr.html"},{"title":"pzextr – FRTС project","text":"public  subroutine pzextr(iest, xest, yest, yz, dy, nv) polynomial extrapolation Arguments Type Intent Optional Attributes Name integer :: iest double precision :: xest double precision :: yest (nv) double precision :: yz (nv) double precision :: dy (nv) integer :: nv","tags":"","loc":"proc\\pzextr.html"},{"title":"driver4 – FRTС project","text":"public  subroutine driver4(ystart, x1, x2, rexi, hmin, derivs) Uses runge_kutta_module dispersion_module rt_parameters constants var        if(dabs(dydx(3)).ne.zero) h=dabs(hmin1/dydx(3))/hdrob1\n    if(dabs(y(3)-rexi).gt.rrange.or.nstp.eq.maxstep4) then  ! exit !sav2008 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ystart (:) real(kind=wp), intent(inout) :: x1 real(kind=wp), intent(inout) :: x2 real(kind=wp), intent(in) :: rexi real(kind=wp), intent(in) :: hmin procedure( Iderivs_func ) :: derivs","tags":"","loc":"proc\\driver4.html"},{"title":"init_method – FRTС project","text":"public  subroutine init_method(this, theta, index) инициализация траетории Type Bound Trajectory Arguments Type Intent Optional Attributes Name class( Trajectory ), intent(inout) :: this real(kind=wp), intent(in) :: theta integer, intent(in) :: index","tags":"","loc":"proc\\init_method.html"},{"title":"reset_method – FRTС project","text":"public  subroutine reset_method(this, index) сброс счетчика Type Bound Trajectory Arguments Type Intent Optional Attributes Name class( Trajectory ), intent(inout) :: this integer, intent(in) :: index","tags":"","loc":"proc\\reset_method.html"},{"title":"add_point_method – FRTС project","text":"public  subroutine add_point_method(this, tpoint) добавляение новой точнки траектории Type Bound Trajectory Arguments Type Intent Optional Attributes Name class( Trajectory ), intent(inout) :: this class( TrajectoryPoint ), intent(in) :: tpoint","tags":"","loc":"proc\\add_point_method.html"},{"title":"write_info_method – FRTС project","text":"public  subroutine write_info_method(this, iu) сохранение в файл информации о траектории Type Bound Trajectory Arguments Type Intent Optional Attributes Name class( Trajectory ), intent(inout) :: this integer, intent(in) :: iu","tags":"","loc":"proc\\write_info_method.html"},{"title":"chang_cooper_solver – FRTС project","text":"public  subroutine chang_cooper_solver(alfa2, nt, h, dt, n, ybeg, yend, d1, d2, d3, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 integer, intent(in) :: nt real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: d1 (n+1) real(kind=wp), intent(in) :: d2 (n+1) real(kind=wp), intent(in) :: d3 (n+1) real(kind=wp), intent(inout) :: y (n+2)","tags":"","loc":"proc\\chang_cooper_solver.html"},{"title":"chang_cooper_abcoef – FRTС project","text":"public  subroutine chang_cooper_abcoef(alfa2, a, b, c, f, y, dt, n, ybeg, yend, xx, h, df) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 real(kind=wp), intent(inout) :: a (n) real(kind=wp), intent(inout) :: b (n) real(kind=wp), intent(inout) :: c (n) real(kind=wp), intent(inout) :: f (n) real(kind=wp), intent(inout) :: y (n+2) real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: xx (n+1) real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: df (n+1)","tags":"","loc":"proc\\chang_cooper_abcoef.html"},{"title":"manager – FRTС project","text":"public  subroutine manager(iterat, iw0, ntet, spectr) Uses iterator_mod trajectory_module constants rt_parameters spectrum_mod trajectory_data driver_module dispersion_module plasma Arguments Type Intent Optional Attributes Name integer :: iterat integer :: iw0 integer :: ntet type( Spectrum ) :: spectr","tags":"","loc":"proc\\manager.html"},{"title":"rini – FRTС project","text":"public  subroutine rini(traj, point, iw0) Uses constants rt_parameters spectrum_mod trajectory_data driver_module dispersion_module metrics Arguments Type Intent Optional Attributes Name class( Trajectory ), intent(inout) :: traj type( SpectrumPoint ), intent(in) :: point integer, intent(in) :: iw0","tags":"","loc":"proc\\rini.html"},{"title":"dqliter – FRTС project","text":"public  subroutine dqliter(dltpow, traj, h, powexit, iout) Uses driver_module iterator_mod plasma current constants trajectory_data decrements rt_parameters !old variant\n!       call raspr(v,abs(jr),iv,df)\n!       if(iv.eq.0) iv=1\n!!!!!!!!!!!!!!!!!!!!!!!!\n       dfsr=v df (vrt-vlf)\n       vsr=v (vrt-vlf)\n        pintld=-dland(i) (dflf+dfrt)/2d0\n        pdec1=-pdecv*df Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: dltpow type( Trajectory ), intent(in), pointer :: traj real(kind=wp), intent(in) :: h real(kind=wp), intent(out) :: powexit integer, intent(inout) :: iout","tags":"","loc":"proc\\dqliter.html"},{"title":"DrivenCurrent_constructor – FRTС project","text":"public  function DrivenCurrent_constructor(size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( DrivenCurrent )","tags":"","loc":"proc\\drivencurrent_constructor.html"},{"title":"DrivenCurrentResult_constructor – FRTС project","text":"public  function DrivenCurrentResult_constructor(positive_dc, negative_dc) result(this) Arguments Type Intent Optional Attributes Name type( DrivenCurrent ), intent(in) :: positive_dc type( DrivenCurrent ), intent(in) :: negative_dc Return Value type( DrivenCurrentResult )","tags":"","loc":"proc\\drivencurrentresult_constructor.html"},{"title":"DrivenCurrent_evaluate – FRTС project","text":"public  subroutine DrivenCurrent_evaluate(this, ROC) Uses constants Type Bound DrivenCurrent Arguments Type Intent Optional Attributes Name class( DrivenCurrent ), intent(inout) :: this real(kind=wp), intent(in) :: ROC","tags":"","loc":"proc\\drivencurrent_evaluate.html"},{"title":"driven_current_result_print – FRTС project","text":"public  subroutine driven_current_result_print(this, time) Type Bound DrivenCurrentResult Arguments Type Intent Optional Attributes Name class( DrivenCurrentResult ), intent(in) :: this real(kind=wp), intent(in) :: time","tags":"","loc":"proc\\driven_current_result_print.html"},{"title":"driven_current_result_save – FRTС project","text":"public  subroutine driven_current_result_save(this, time) Type Bound DrivenCurrentResult Arguments Type Intent Optional Attributes Name class( DrivenCurrentResult ), intent(in) :: this real(kind=wp), intent(in) :: time","tags":"","loc":"proc\\driven_current_result_save.html"},{"title":"DrivenCurrent – FRTС project","text":"public interface DrivenCurrent Module Procedures public  function DrivenCurrent_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( DrivenCurrent )","tags":"","loc":"interface\\drivencurrent.html"},{"title":"DrivenCurrentResult – FRTС project","text":"public interface DrivenCurrentResult Module Procedures public  function DrivenCurrentResult_constructor (positive_dc, negative_dc) result(this) Arguments Type Intent Optional Attributes Name type( DrivenCurrent ), intent(in) :: positive_dc type( DrivenCurrent ), intent(in) :: negative_dc Return Value type( DrivenCurrentResult )","tags":"","loc":"interface\\drivencurrentresult.html"},{"title":"iteration_result_print – FRTС project","text":"public  subroutine iteration_result_print(this) Type Bound IterationResult Arguments Type Intent Optional Attributes Name class( IterationResult ), intent(in) :: this","tags":"","loc":"proc\\iteration_result_print.html"},{"title":"iteration_result_save – FRTС project","text":"public  subroutine iteration_result_save(this, time_stamp) save Iteration Result to file Type Bound IterationResult Arguments Type Intent Optional Attributes Name class( IterationResult ), intent(in) :: this real(kind=wp), intent(in) :: time_stamp","tags":"","loc":"proc\\iteration_result_save.html"},{"title":"spectrum_constructor – FRTС project","text":"public  function spectrum_constructor(size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( Spectrum )","tags":"","loc":"proc\\spectrum_constructor.html"},{"title":"integral_trapez_method – FRTС project","text":"public  function integral_trapez_method(this) result(sum) вычисление полной мощности спектра\nинтегрирование методом трапеций Type Bound Spectrum Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(in) :: this Return Value real(kind=wp)","tags":"","loc":"proc\\integral_trapez_method.html"},{"title":"get_positive_part_method – FRTС project","text":"public  function get_positive_part_method(this) result(spectr) Type Bound Spectrum Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(in) :: this Return Value type( Spectrum )","tags":"","loc":"proc\\get_positive_part_method.html"},{"title":"get_negative_part_method – FRTС project","text":"public  function get_negative_part_method(this) result(spectr) Type Bound Spectrum Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(in) :: this Return Value type( Spectrum )","tags":"","loc":"proc\\get_negative_part_method.html"},{"title":"read_spectrum – FRTС project","text":"public  function read_spectrum(file_name) result(spectr) Arguments Type Intent Optional Attributes Name character(len=*), value :: file_name Return Value type( Spectrum )","tags":"","loc":"proc\\read_spectrum.html"},{"title":"make_spline_approximation – FRTС project","text":"public  function make_spline_approximation(spectr) result(appx_spectr) Uses spline_module rt_parameters constants approximation of input LH spectrum Arguments Type Intent Optional Attributes Name type( Spectrum ), intent(in) :: spectr Return Value type( Spectrum )","tags":"","loc":"proc\\make_spline_approximation.html"},{"title":"calc_max_power_method – FRTС project","text":"public  subroutine calc_max_power_method(this) Uses rt_parameters constants Type Bound Spectrum Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(inout) :: this","tags":"","loc":"proc\\calc_max_power_method.html"},{"title":"normalization_method – FRTС project","text":"public  subroutine normalization_method(this) Uses rt_parameters constants Type Bound Spectrum Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(inout) :: this","tags":"","loc":"proc\\normalization_method.html"},{"title":"write_spectrum – FRTС project","text":"public  subroutine write_spectrum(this, spectrum_name) write spectrum to file Type Bound Spectrum Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(inout) :: this character(len=*), intent(in) :: spectrum_name","tags":"","loc":"proc\\write_spectrum.html"},{"title":"divide_spectrum – FRTС project","text":"public  subroutine divide_spectrum(spectr, pos_spectr, neg_spectr) деление спектра на две части Arguments Type Intent Optional Attributes Name type( Spectrum ), intent(in) :: spectr type( Spectrum ), intent(out) :: pos_spectr type( Spectrum ), intent(out) :: neg_spectr","tags":"","loc":"proc\\divide_spectrum.html"},{"title":"Spectrum – FRTС project","text":"public interface Spectrum Module Procedures public  function spectrum_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( Spectrum )","tags":"","loc":"interface\\spectrum.html"},{"title":"chebev – FRTС project","text":"public  function chebev(a, b, c, m, x) Chebyshev evaluation: All arguments are input. \nc(1:m) is an array of Chebyshev coefficients, the first m elements \nof c output from chebft (which must have been called with\nthe same a and b). The Chebyshev polynomial evaluated\nand the result is returned as the function value. Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: c (m) integer :: m real(kind=wp) :: x Return Value real(kind=wp)","tags":"","loc":"proc\\chebev.html"},{"title":"chebft1 – FRTС project","text":"public  subroutine chebft1(a, b, c, n, func) Chebyshev fit: Given a function func, lower and upper limits\nof the interval [a,b], and a maximum degree n, this routine \ncomputes the n coefficients c(k) such that func(x) approximately =\nSUMM_(k=1)&#94;(k=n)[c(k)*T(k-1)(y)]-c(1)/2, where y and x are related by\n(5.8.10). This routine is to be used with moderately large n \n(e.g., 30 or 50), the array of cs subsequently to be truncated\nat the smaller value m such that c(m+1) and subsequent elements \nare negligible. Parameters: Maximum expected value of n, and ð. Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: c (n) integer :: n real :: func","tags":"","loc":"proc\\chebft1.html"},{"title":"chder – FRTС project","text":"public  subroutine chder(a, b, c, cder, n) Given a,b,c(1:n), as output from routine chebft(), and given n, \nthe desired degree of approximation (length of c to be used), \nthis routine returns the array cder(1:n), the Chebyshev \ncoefficients of the derivative of the function whose coefficients \nare c(1:n). Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: c (n) real(kind=wp) :: cder (n) integer :: n","tags":"","loc":"proc\\chder.html"},{"title":"currlhcd – FRTС project","text":"public  function currlhcd(v, f) result(curs) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: v (:) real(kind=wp), intent(in) :: f (:) Return Value real(kind=wp)","tags":"","loc":"proc\\currlhcd.html"},{"title":"create_vt_grid – FRTС project","text":"public  function create_vt_grid(vclt) result(vt_grid) создание сетки тепловых скоростей Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt Return Value real(kind=wp), (i0)","tags":"","loc":"proc\\create_vt_grid.html"},{"title":"funmaxwell – FRTС project","text":"public  function funmaxwell(v, dfunmaxwell) распределение Максвелла и его производная Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: dfunmaxwell Return Value real(kind=wp)","tags":"","loc":"proc\\funmaxwell.html"},{"title":"fmaxw_classic – FRTС project","text":"public  function fmaxw_classic(v, alfa2, dfmaxw) распределение Максвелла с альфа-частицами и его производная Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 real(kind=wp) :: dfmaxw Return Value real(kind=wp)","tags":"","loc":"proc\\fmaxw_classic.html"},{"title":"fmaxw_ext – FRTС project","text":"public  function fmaxw_ext(v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 real(kind=wp) :: dfmaxw Return Value real(kind=wp)","tags":"","loc":"proc\\fmaxw_ext.html"},{"title":"fmaxw – FRTС project","text":"public  function fmaxw(v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 real(kind=wp) :: dfmaxw Return Value real(kind=wp)","tags":"","loc":"proc\\fmaxw.html"},{"title":"psiq – FRTС project","text":"public  function psiq(v, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 Return Value real(kind=wp)","tags":"","loc":"proc\\psiq.html"},{"title":"erfcc – FRTС project","text":"public  function erfcc(x) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x Return Value real(kind=wp)","tags":"","loc":"proc\\erfcc.html"},{"title":"init_vi – FRTС project","text":"public  subroutine init_vi(vclt, vi) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt real(kind=wp), intent(out) :: vi (i0)","tags":"","loc":"proc\\init_vi.html"},{"title":"init_fmaxw_classic – FRTС project","text":"public  subroutine init_fmaxw_classic(vclt, enorm, fi, dfi) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt real(kind=wp), intent(in) :: enorm real(kind=wp), intent(out) :: fi (i0) real(kind=wp), intent(out) :: dfi (i0)","tags":"","loc":"proc\\init_fmaxw_classic.html"},{"title":"init_fmaxw_ext – FRTС project","text":"public  subroutine init_fmaxw_ext(vclt, enorm, fi, dfi) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt real(kind=wp), intent(in) :: enorm real(kind=wp), intent(out) :: fi (i0) real(kind=wp), intent(out) :: dfi (i0)","tags":"","loc":"proc\\init_fmaxw_ext.html"},{"title":"splne – FRTС project","text":"public  subroutine splne(x, y, n, y2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x (n) real(kind=wp) :: y (n) integer :: n real(kind=wp) :: y2 (n)","tags":"","loc":"proc\\splne.html"},{"title":"splnt – FRTС project","text":"public  subroutine splnt(xa, ya, y2a, n, x, y, dy) Arguments Type Intent Optional Attributes Name real(kind=wp) :: xa (n) real(kind=wp) :: ya (n) real(kind=wp) :: y2a (n) integer :: n real(kind=wp) :: x real(kind=wp) :: y real(kind=wp) :: dy","tags":"","loc":"proc\\splnt.html"},{"title":"dsplnt – FRTС project","text":"public  subroutine dsplnt(xa, ya, y2a, n, x, y, dy, ddy) Arguments Type Intent Optional Attributes Name real(kind=wp) :: xa (n) real(kind=wp) :: ya (n) real(kind=wp) :: y2a (n) integer :: n real(kind=wp) :: x real(kind=wp) :: y real(kind=wp) :: dy real(kind=wp) :: ddy","tags":"","loc":"proc\\dsplnt.html"},{"title":"utils – FRTС project","text":"Uses kind_module Derived Types type, public :: Timer Components Type Visibility Attributes Name Initial real(kind=wp), public :: start_time real(kind=wp), public :: end_time real(kind=wp), public :: elapsed_time real(kind=wp), public :: plasma_time character(len=120), public :: file_name Type-Bound Procedures procedure, public :: start => Time_start procedure, public :: stop => Time_stop procedure, public :: stop_and_save => Time_stop_and_save Functions public  function sys_time () Arguments None Return Value real(kind=wp) Subroutines public  subroutine Time_start (this, fn, pt) Arguments Type Intent Optional Attributes Name class( Timer ), intent(inout) :: this character(len=*), intent(in) :: fn real(kind=wp), intent(in) :: pt public  subroutine Time_stop (this) Arguments Type Intent Optional Attributes Name class( Timer ), intent(inout) :: this public  subroutine Time_stop_and_save (this) Arguments Type Intent Optional Attributes Name class( Timer ), intent(inout) :: this","tags":"","loc":"module\\utils.html"},{"title":"metrics – FRTС project","text":"Uses kind_module Variables Type Visibility Attributes Name Initial real(kind=wp), public :: g11 common/metrika/g11,g12,g22,g33,gg,g,si,co real(kind=wp), public :: g12 common/metrika/g11,g12,g22,g33,gg,g,si,co real(kind=wp), public :: g22 common/metrika/g11,g12,g22,g33,gg,g,si,co real(kind=wp), public :: g33 common/metrika/g11,g12,g22,g33,gg,g,si,co real(kind=wp), public :: gg common/metrika/g11,g12,g22,g33,gg,g,si,co real(kind=wp), public :: g common/metrika/g11,g12,g22,g33,gg,g,si,co real(kind=wp), public :: si common/metrika/g11,g12,g22,g33,gg,g,si,co real(kind=wp), public :: co common/metrika/g11,g12,g22,g33,gg,g,si,co real(kind=wp), public :: g2v1 real(kind=wp), public :: g2jq real(kind=wp), public :: g3v real(kind=wp), public :: b real(kind=wp), public :: bp real(kind=wp), public :: bt real(kind=wp), public :: x0 real(kind=wp), public :: x0t real(kind=wp), public :: xj real(kind=wp), public :: xjt real(kind=wp), public :: dxdr real(kind=wp), public :: dxdt real(kind=wp), public :: dzdr real(kind=wp), public :: dzdt real(kind=wp), public :: dxdrdt real(kind=wp), public :: dxdtdt real(kind=wp), public :: dzdrdt real(kind=wp), public :: dzdtdt real(kind=wp), public :: bat real(kind=wp), public :: bpt real(kind=wp), public :: btt real(kind=wp), public :: g2jqt real(kind=wp), public :: g11t real(kind=wp), public :: g22t real(kind=wp), public :: g33t real(kind=wp), public :: g12t real(kind=wp), public :: gprt Subroutines public  subroutine calculate_metrics (pa, ptet) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: pa real(kind=wp), intent(in) :: ptet","tags":"","loc":"module\\metrics.html"},{"title":"dielectric_tensor – FRTС project","text":"components of dielectric tensor Uses kind_module metrics Variables Type Visibility Attributes Name Initial real(kind=wp), public :: e1 real(kind=wp), public :: e2 real(kind=wp), public :: e3 real(kind=wp), public :: pn real(kind=wp), public :: fnr real(kind=wp), public :: wpq real(kind=wp), public :: whe real(kind=wp), public :: v real(kind=wp), public :: u1 real(kind=wp), public :: u Subroutines public  subroutine calculate_dielectric_tensor (pa) calculate components of dielectric tensor Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: pa","tags":"","loc":"module\\dielectric_tensor.html"},{"title":"dispersion_equation – FRTС project","text":"dispersion equation Uses kind_module metrics Variables Type Visibility Attributes Name Initial real(kind=wp), public :: ynz real(kind=wp), public :: ynzq real(kind=wp), public :: as real(kind=wp), public :: bs real(kind=wp), public :: cs real(kind=wp), public :: pnew real(kind=wp), public :: yny real(kind=wp), public :: gpr real(kind=wp), public :: dls Subroutines public  subroutine calculate_dispersion_equation (yn2, yn3) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: yn2 real(kind=wp), intent(in) :: yn3","tags":"","loc":"module\\dispersion_equation.html"},{"title":"partial_derivatives – FRTС project","text":"calculation of partial derivatives Uses kind_module Subroutines public  subroutine calculate_partial_derivatives (yn2, yn3, dl1, ynpopq, al, bl, dl2, prt, prm) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: yn2 real(kind=wp), intent(in) :: yn3 real(kind=wp), intent(in) :: dl1 real(kind=wp), intent(in) :: ynpopq real(kind=wp), intent(in) :: al real(kind=wp), intent(in) :: bl real(kind=wp), intent(in) :: dl2 real(kind=wp), intent(out) :: prt real(kind=wp), intent(out) :: prm","tags":"","loc":"module\\partial_derivatives.html"},{"title":"decrements – FRTС project","text":"Uses kind_module Variables Type Visibility Attributes Name Initial real(kind=wp), public :: dnx real(kind=wp), public :: dhdnr integer, public :: ifound real(kind=wp), public :: vfound common /eg1/ vfound,ifound integer, public :: icf1 integer, public :: icf2 real(kind=wp), public :: pdec1 common /eg2/ pdec1,pdec2,pdec3,pdecv,pdecal,dfdv,icf1,icf2 real(kind=wp), public :: pdec2 common /eg2/ pdec1,pdec2,pdec3,pdecv,pdecal,dfdv,icf1,icf2 real(kind=wp), public :: pdec3 common /eg2/ pdec1,pdec2,pdec3,pdecv,pdecal,dfdv,icf1,icf2 real(kind=wp), public :: pdecv common /eg2/ pdec1,pdec2,pdec3,pdecv,pdecal,dfdv,icf1,icf2 real(kind=wp), public :: pdecal common /eg2/ pdec1,pdec2,pdec3,pdecv,pdecal,dfdv,icf1,icf2 real(kind=wp), public :: dfdv common /eg2/ pdec1,pdec2,pdec3,pdecv,pdecal,dfdv,icf1,icf2 real(kind=wp), public :: cf1 common /eg3/ cf1,cf2,cf3,cf4,cf5,cf6 real(kind=wp), public :: cf2 common /eg3/ cf1,cf2,cf3,cf4,cf5,cf6 real(kind=wp), public :: cf3 common /eg3/ cf1,cf2,cf3,cf4,cf5,cf6 real(kind=wp), public :: cf4 common /eg3/ cf1,cf2,cf3,cf4,cf5,cf6 real(kind=wp), public :: cf5 common /eg3/ cf1,cf2,cf3,cf4,cf5,cf6 real(kind=wp), public :: cf6 common /eg3/ cf1,cf2,cf3,cf4,cf5,cf6 real(kind=wp), public :: dgdu (50,100) integer, public :: kzero (100) common /arr/ dgdu(50,100),kzero(100)\n используется в zatukh, ourlhcd2017 и alphas Functions public  function zatukh (psy, j, u, n) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: psy integer, intent(in) :: j real(kind=wp), intent(in) :: u (:,:) integer, intent(in) :: n Return Value real(kind=wp) Subroutines public  subroutine calculate_decrements (pa, yn2, ptet, yn3, ynpopq, xnr, jr, izn) pdec1=-pdecv*dfdv Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: pa real(kind=wp), intent(in) :: yn2 real(kind=wp), intent(in) :: ptet real(kind=wp), intent(in) :: yn3 real(kind=wp), intent(in) :: ynpopq real(kind=wp), intent(in) :: xnr integer, intent(in) :: jr integer, intent(in) :: izn","tags":"","loc":"module\\decrements.html"},{"title":"dispersion_module – FRTС project","text":"Uses kind_module Variables Type Visibility Attributes Name Initial real(kind=wp), public :: yn3 common /abefo/ yn3 integer, public :: ivar common /bdeo/ ivar integer, public :: icall1 integer, public :: icall2 integer, public :: izn common /abcde/ izn real(kind=wp), public :: ynpopq common /bcef/ ynz,ynpopq integer, public :: iconv common /cefn/ iconv,irefl integer, public :: irefl common /cefn/ iconv,irefl integer, public :: ipow common /ceg/ ipow,jfoundr integer, public :: jfoundr common /ceg/ ipow,jfoundr real(kind=wp), public :: dhdm common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u real(kind=wp), public :: dhdtet common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u real(kind=wp), public :: dhdr common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u real(kind=wp), public :: ddn common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u real(kind=wp), public :: dhdn3 common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u real(kind=wp), public :: dhdv2v common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u real(kind=wp), public :: dhdu2u common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u real(kind=wp), public :: znakstart common/direct/znakstart real(kind=wp), public :: ham common/fjham/ham integer, public :: idec real(kind=wp), public :: pdec14 common /df/ pdec14,pdec24,pdec34,idec real(kind=wp), public :: pdec24 common /df/ pdec14,pdec24,pdec34,idec real(kind=wp), public :: pdec34 common /df/ pdec14,pdec24,pdec34,idec Functions public  function dhdomega (rho, theta, yn1, yn2) result(znak) вычисляет znakstart\n!!!\nw*dH/dw=wdhdw: Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: rho real(kind=wp), intent(in) :: theta real(kind=wp), intent(inout) :: yn1 real(kind=wp), intent(in) :: yn2 Return Value real(kind=wp) Subroutines public  subroutine disp2_ider0 (pa, yn2, ptet, xnro) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: pa real(kind=wp), intent(in) :: yn2 real(kind=wp), intent(in) :: ptet real(kind=wp), intent(out) :: xnro public  subroutine disp2 (pa, yn2, ptet, xnro, prt, prm) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: pa real(kind=wp), intent(in) :: yn2 real(kind=wp), intent(in) :: ptet real(kind=wp), intent(out) :: xnro real(kind=wp), intent(out) :: prt real(kind=wp), intent(out) :: prm public  subroutine disp2_iroot3 (pa, yn2, ptet, xnro, pg1, pg2, pg3, pg4) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: pa real(kind=wp), intent(in) :: yn2 real(kind=wp), intent(in) :: ptet real(kind=wp), intent(in) :: xnro real(kind=wp), intent(out) :: pg1 real(kind=wp), intent(out) :: pg2 real(kind=wp), intent(out) :: pg3 real(kind=wp), intent(out) :: pg4 public  subroutine disp2_iroot2 (pa, yn2, ptet, prt, prm) !!!\nold variant: Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: pa real(kind=wp), intent(in) :: yn2 real(kind=wp), intent(in) :: ptet real(kind=wp), intent(out) :: prt real(kind=wp), intent(out) :: prm public  subroutine disp4 (in_pa, ptet, xnr, yn2) !!!\n      pn=fn1(pa,fnr)\n      pn=fn2(pa,fnr,fnrr)\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n      dl=bs 2-4d0 as bs Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: in_pa real(kind=wp), intent(in) :: ptet real(kind=wp), intent(inout) :: xnr real(kind=wp), intent(in) :: yn2 public  subroutine extd4 (x, y, dydx) !!! Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y (:) real(kind=wp), intent(inout) :: dydx (:)","tags":"","loc":"module\\dispersion_module.html"},{"title":"FokkerPlanck_module – FRTС project","text":"calculation of distribution functions at time t1=t+dtau !! Uses kind_module Subroutines public  subroutine fokkerplanck_compute (time, TAU) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: time real(kind=wp), intent(in) :: TAU public  subroutine init_diffusion (h, n, vj, dj, d1, d2, d3) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: h integer, intent(in) :: n real(kind=wp), intent(in), dimension(:) :: vj real(kind=wp), intent(in), dimension(:) :: dj real(kind=wp), intent(out), dimension(:) :: d1 real(kind=wp), intent(out), dimension(:) :: d2 real(kind=wp), intent(out), dimension(:) :: d3","tags":"","loc":"module\\fokkerplanck_module.html"},{"title":"plasma – FRTС project","text":"модуль параметров плазмы Uses kind_module Variables Type Visibility Attributes Name Initial integer, public :: ngrid ASTRA radial grid number integer, public :: nspl ASTRA radial grid number real(kind=wp), public :: tcur время (придумать название для переменной получше) real(kind=wp), public :: rm minor radius in mid-plane, cm real(kind=wp), public :: b_tor0 тороидальное магнитное поле\nвременно нужно две переменных, тоже нужно исправить real(kind=wp), public :: b_tor тороидальное магнитное поле real(kind=wp), public :: r0 real(kind=wp), public :: z0 real(kind=wp), public :: rh1 real(kind=wp), public, dimension(:), allocatable :: con real(kind=wp), public, dimension(:), allocatable :: tem real(kind=wp), public, dimension(:), allocatable :: temi real(kind=wp), public, dimension(:), allocatable :: zeff real(kind=wp), public, dimension(:), allocatable :: afld real(kind=wp), public, dimension(:), allocatable :: rh real(kind=wp), public, dimension(:), allocatable :: rha real(kind=wp), public, dimension(:), allocatable :: drhodr real(kind=wp), public, dimension(:), allocatable :: delta real(kind=wp), public, dimension(:), allocatable :: ell real(kind=wp), public, dimension(:), allocatable :: gamm real(kind=wp), public, dimension(:), allocatable :: amy real(kind=wp), public :: tet1 common /a0a2/ real(kind=wp), public :: tet2 common /a0a2/ real(kind=wp), public :: xmi /a0ef3/ xmi,cnye,cnyi,xsz,vt0 real(kind=wp), public :: cnye /a0ef3/ xmi,cnye,cnyi,xsz,vt0 real(kind=wp), public :: cnyi /a0ef3/ xmi,cnye,cnyi,xsz,vt0 real(kind=wp), public :: xsz /a0ef3/ xmi,cnye,cnyi,xsz,vt0 real(kind=wp), public :: vt0 /a0ef3/ xmi,cnye,cnyi,xsz,vt0 real(kind=wp), public :: cnstvc real(kind=wp), public :: ww common /a0ef2/ ww real(kind=wp), public :: cltn common /a0ef1/ cltn real(kind=wp), public :: vperp (50,100) real(kind=wp), public :: cnstal real(kind=wp), public :: zza real(kind=wp), public :: zze real(kind=wp), public :: valfa real(kind=wp), public :: vpmax real(kind=wp), public :: vk (100) real(kind=wp), public :: sk (100) integer, public, parameter :: ipsy = 5 ipsy = number of polinomial decomposition coefficients\nused for interpolation of Zakharov's moments. integer, public, parameter :: ncoef = 5 ipsy = number of polinomial decomposition coefficients\nused for interpolation of Zakharov's moments. real(kind=wp), public, dimension(ipsy) :: cdl real(kind=wp), public, dimension(ipsy) :: cly real(kind=wp), public, dimension(ipsy) :: cgm real(kind=wp), public, dimension(ipsy) :: cmy real(kind=wp), public, dimension(ipsy) :: coeffs real(kind=wp), public :: y2dn (501) common /a0l3/ real(kind=wp), public :: y2tm (501) common /a0l3/ real(kind=wp), public :: y2tmi (501) common /a0l3/ real(kind=wp), public :: y2zeff (501) common /a0l5/ integer, public :: ncheb real(kind=wp), public :: chebne (50) common/ne_cheb real(kind=wp), public :: chebdne (50) common/ne_cheb real(kind=wp), public :: chebddne (50) common/ne_cheb real(kind=wp), public :: enorm (100) em поле и еще что-то real(kind=wp), public :: fst (100) em поле и еще что-то Functions public  function fn (x) plasma  density,  cm&#94;-3 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) public  function fvt (r) нет описания Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r Return Value real(kind=wp) public  function fn1 (x, fnp) plasma density and its derivative Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(out) :: fnp Return Value real(kind=wp) public  function fn2 (r, fnp, fnpp) plasma density and its first and second derivatives Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r real(kind=wp), intent(out) :: fnp real(kind=wp), intent(out) :: fnpp Return Value real(kind=wp) public  function ft (x) electron temperature, erg\n     ft=y            ! kev Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) public  function fti (x) ion temperature, kev Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) public  function zefff (x) z_effective profile Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) public  function obeom (ptet, pa) Arguments Type Intent Optional Attributes Name real :: ptet real :: pa Return Value real(kind=wp) public  function ploshad (ptet, pa) Arguments Type Intent Optional Attributes Name real :: ptet real :: pa Return Value real(kind=wp) public  function gaussint (f, a, b, r, eps) что-то про гаусс Arguments Type Intent Optional Attributes Name real(kind=wp) :: f real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: r real(kind=wp) :: eps Return Value real(kind=wp) Subroutines public  subroutine init_plasma (NA1, ABC, BTOR, RTOR, UPDWN, GP2, AMETR, RHO, SHIF, ELON, TRIA, MU, NE, TE, TI, ZEF, UPL) variant\n amy=(btor/q) rho (drho/dr) is a function of \"minor radius\" r=rh(i).\n Poloidal magnetic field: B_pol=amy(r)*sqrt(g22/g), where g is\n determinant of 3D metric tensor and g22 is the (22) element of\n the tensor, normalized on ABC&#94;4 and ABC&#94;2, correspondingly. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: NA1 real(kind=wp), intent(in) :: ABC real(kind=wp), intent(in) :: BTOR real(kind=wp), intent(in) :: RTOR real(kind=wp), intent(in) :: UPDWN real(kind=wp), intent(in) :: GP2 real(kind=wp), dimension(*) :: AMETR real(kind=wp), dimension(*) :: RHO real(kind=wp), dimension(*) :: SHIF real(kind=wp), dimension(*) :: ELON real(kind=wp), dimension(*) :: TRIA real(kind=wp), dimension(*) :: MU real(kind=wp), dimension(*) :: NE real(kind=wp), dimension(*) :: TE real(kind=wp), dimension(*) :: TI real(kind=wp), dimension(*) :: ZEF real(kind=wp), dimension(*) :: UPL public  subroutine init_parameters () !!!!!!      ptkev=ft(zero)/0.16d-8  !Te in keV\n      ccurnr=pqe pqe 0.333d-9/pme Arguments None public  subroutine write_plasma (time_stamp) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: time_stamp public  subroutine write_lcms () write lcms Arguments None public  subroutine find_volums_and_surfaces () Arguments None public  subroutine calc_enorm () fst(j)=pn xlogj c0 4/pi4/vt 3 Arguments None public  subroutine init_maxwell () Arguments None","tags":"","loc":"module\\plasma.html"},{"title":"savelyev_solver_module – FRTС project","text":"Uses kind_module Functions public  function rplusk (x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp) public  function rplusk2 (x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp) public  function rmink (x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp) public  function rmink2 (x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp) public  function rs (x, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp) public  function qf (x) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) public  function k2 (x, dif) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif Return Value real(kind=wp) public  function kinv (x, dif) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif Return Value real(kind=wp) public  function kinv2 (x, dif) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif Return Value real(kind=wp) Subroutines public  subroutine savelyev_solver (alfa2, nt, h, dt, n, ybeg, yend, d1, d2, d3, y) разностная схема Савельева для уравнения Фоккера-Планка Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 integer, intent(in) :: nt real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: d1 (n+1) real(kind=wp), intent(in) :: d2 (n+1) real(kind=wp), intent(in) :: d3 (n+1) real(kind=wp), intent(inout) :: y (n) public  subroutine savelyev_abccoef (alfa2, a, b, c, f, y, dt, n, ybeg, yend, xx, h, d1, d2, d3) -- fill abc matrix Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 real(kind=wp), intent(inout) :: a (n) real(kind=wp), intent(inout) :: b (n) real(kind=wp), intent(inout) :: c (n) real(kind=wp), intent(inout) :: f (n) real(kind=wp), intent(inout) :: y (n) real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: xx (n+1) real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: d1 (n+1) real(kind=wp), intent(in) :: d2 (n+1) real(kind=wp), intent(in) :: d3 (n+1) public  subroutine tridag (a, b, c, r, u, n) создает трехдиагональнйю матрицу Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (n) real(kind=wp), intent(in) :: b (n) real(kind=wp), intent(in) :: c (n) real(kind=wp), intent(in) :: r (n) real(kind=wp), intent(inout) :: u (n) integer, intent(in) :: n","tags":"","loc":"module\\savelyev_solver_module.html"},{"title":"trajectory_module – FRTС project","text":"common/refl/nrefj(mpnt) Uses trajectory_data kind_module Variables Type Visibility Attributes Name Initial integer, public, parameter :: max_num_trajectories = 10000 type( Trajectory ), public, target :: trajectories (max_num_trajectories) Subroutines public  subroutine init_trajectory () Arguments None public  subroutine view (tview, ispectr, nnz, ntet) !writing trajectories into a file\n          pintld=-dland(i) (dflf+dfrt)/2d0\n          pdec1=-pdecv df Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: tview integer, intent(in) :: ispectr integer, intent(in) :: nnz integer, intent(in) :: ntet public  subroutine tracing (traj, nmax, nb1, nb2, pabs) Arguments Type Intent Optional Attributes Name class( Trajectory ), intent(inout) :: traj integer, intent(inout) :: nmax integer, intent(inout) :: nb1 integer, intent(inout) :: nb2 real(kind=wp), intent(in) :: pabs","tags":"","loc":"module\\trajectory_module.html"},{"title":"FokkerPlanck1D_mod – FRTС project","text":"модуль содержит функции для решения одномерного уравнения Фоккер-Планка Uses savelyev_solver_module iso_fortran_env Interfaces public        interface FokkerPlanck1D public  function FokkerPlanck1D_constructor (e, v_lim, v, f) result(this) конструктор для FokkerPlanck1D Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D ) Derived Types type, public :: FokkerPlanck1D solver of FP eq Components Type Visibility Attributes Name Initial real(kind=dp), public :: enorm = 0 электрическое поле real(kind=dp), public :: v_lim = 0 верхняя граница скорости электронов real(kind=dp), public, allocatable :: v (:) сетка скоростей real(kind=dp), public, allocatable :: f (:) распределение integer, public :: i0 = 0 size of distribution grid real(kind=dp), public :: alfa2 = 0 поле со знаком integer, public :: n = 0 size of local grid real(kind=dp), public :: h = 0 step of local grid real(kind=dp), public, allocatable :: d1 (:) диффузия real(kind=dp), public, allocatable :: d2 (:) диффузия real(kind=dp), public, allocatable :: d3 (:) диффузия Constructor public\n\n                    \n                    function FokkerPlanck1D_constructor (e, v_lim, v, f) конструктор для FokkerPlanck1D Type-Bound Procedures procedure, public :: print => FokkerPlanck1D_print procedure, public :: solve_time_step => FokkerPlanck1D_solve_time_step procedure, public :: init_zero_diffusion => FokkerPlanck1D_init_zero_diffusion procedure, public :: init_diffusion => FokkerPlanck1D_init_diffusion Functions public  function FokkerPlanck1D_constructor (e, v_lim, v, f) result(this) конструктор для FokkerPlanck1D Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D ) Subroutines public  subroutine FokkerPlanck1D_print (this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(in) :: this public  subroutine FokkerPlanck1D_init_zero_diffusion (this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this public  subroutine FokkerPlanck1D_init_diffusion (this, dif) инициализация диффузии для схемы савельева Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in), dimension(:) :: dif public  subroutine FokkerPlanck1D_solve_time_step (this, dt, nt) !!!!!!!!!!   solve problem   !!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in) :: dt integer, intent(in) :: nt public  subroutine burying_procedure (v, f0, df0) процедура закапывания Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (:) real(kind=8), intent(inout) :: f0 (:) real(kind=8), intent(inout), optional :: df0 (:)","tags":"","loc":"module\\fokkerplanck1d_mod.html"},{"title":"FluxSurface_mod – FRTС project","text":"все что связанно с магнитными поверхностями Uses kind_module Derived Types type, public :: FluxSurface класс магнитной поверхности Components Type Visibility Attributes Name Initial integer, public :: index номер магнитной поверхности real(kind=wp), public :: r радиус real(kind=wp), public :: vmax vmax=cltn/vto real(kind=wp), public :: vt наверно тепловая скорость электронов????? vt=fvt(r) integer, public :: ipt размер vgrid real(kind=wp), public, allocatable :: vgrid (:) real(kind=wp), public, allocatable :: vr_grid (:) бываший vrj real(kind=wp), public, allocatable :: diffusion (:) бывший dijk(i,j,k) или dj(i)","tags":"","loc":"module\\fluxsurface_mod.html"},{"title":"math_module – FRTС project","text":"Uses kind_module Subroutines public  subroutine diff (x, y, n, dy) Arguments Type Intent Optional Attributes Name real :: x real :: y integer :: n real :: dy public  subroutine integral (ibeg, iend, x, y, fout) Arguments Type Intent Optional Attributes Name integer :: ibeg integer :: iend real :: x real :: y real :: fout public  subroutine fsmoth4 (x, y, n, ys) Arguments Type Intent Optional Attributes Name real :: x real :: y integer, intent(in) :: n real :: ys","tags":"","loc":"module\\math_module.html"},{"title":"approximation – FRTС project","text":"polinomial approximation Uses kind_module Functions public  function polin (k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=wp) :: x Return Value real(kind=wp) public  function polin1 (k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=wp) :: x Return Value real(kind=wp) public  function polin2 (k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=wp) :: x Return Value real(kind=wp) public  function fdf (x, c, n, df) result(p) вычисление значения полинома и его производной Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: c (n) integer, intent(in) :: n real(kind=wp), intent(out) :: df Return Value real(kind=wp) public  function fdfddf (x, c, n, df, ddf) вычисление значения полинома и первой и второй производной Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: c (n) integer, intent(in) :: n real(kind=wp), intent(out) :: df real(kind=wp), intent(out) :: ddf Return Value real(kind=wp) Subroutines public  subroutine approx (x, y, n, f, m, b) the data to be approximated. number of points in the input data. number of coefficients of decomposition\n       over base functions : found decomposition coefficients Arguments Type Intent Optional Attributes Name real(kind=wp) :: x (n) real(kind=wp) :: y (n) integer :: n real :: f integer :: m real(kind=wp) :: b (*) public  subroutine ludcmp (a, n, np, indx, d) Arguments Type Intent Optional Attributes Name real(kind=wp) :: a (np,np) integer :: n integer :: np real(kind=wp) :: indx (n) real :: d public  subroutine lubksb (a, n, np, indx, b) Arguments Type Intent Optional Attributes Name real(kind=wp) :: a (np,np) integer :: n integer :: np real(kind=wp) :: indx (n) real(kind=wp) :: b (n)","tags":"","loc":"module\\approximation.html"},{"title":"writer_module – FRTС project","text":"Uses kind_module Subroutines public  subroutine binary_write_array (v, a, time, array_name) сохраняет массивы расределения и скорости Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: v (:,:) real(kind=wp), intent(in) :: a (:,:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name public  subroutine write_v_array (v, a, time, array_name) сохраняет массивы расределения и скорости Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: v (:,:) real(kind=wp), intent(in) :: a (:,:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name public  subroutine write_x_array (x, arr, time, array_name) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:,:) real(kind=wp), intent(in) :: arr (:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name public  subroutine write_matrix (arr, time, array_name) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: arr (:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name public  subroutine write_array (arr, N, array_name) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: arr (*) integer, intent(in) :: N character(len=*), intent(in) :: array_name public  subroutine write_distribution (arr, N, time) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: arr (*) integer, intent(in) :: N real(kind=wp), intent(in) :: time","tags":"","loc":"module\\writer_module.html"},{"title":"source_new_mod – FRTС project","text":"Uses kind_module Variables Type Visibility Attributes Name Initial real(kind=wp), public :: rsou (102) real(kind=wp), public :: sou (102) integer, public :: npta common /asou/ rsou(102),sou(102),npta\n используется в source_new и ourlhcd2017 Subroutines public  subroutine source_new (r, out) Arguments Type Intent Optional Attributes Name real :: r real :: out","tags":"","loc":"module\\source_new_mod.html"},{"title":"iterator_mod – FRTС project","text":"Uses kind_module Variables Type Visibility Attributes Name Initial real(kind=wp), public :: vmid (100) real(kind=wp), public :: vz1 (100) real(kind=wp), public :: vz2 (100) integer, public :: ibeg (100) integer, public :: iend (100) real(kind=wp), public :: vrj (101) real(kind=wp), public :: dj (101) real(kind=wp), public :: djnew (1001) real(kind=wp), public :: dj2 (101) real(kind=wp), public :: d2j (101) real(kind=wp), public :: vgrid (101,100) common/gridv/vgrid(101,100),dfundv(101,100) real(kind=wp), public :: dfundv (101,100) common/gridv/vgrid(101,100),dfundv(101,100) integer, public :: nvpt common/gridv/nvpt integer, public :: ipt1 integer, public :: ipt2 integer, public :: ipt integer, public :: iterat real(kind=wp), public :: psum4 common /vvv2/ psum4 real(kind=wp), public :: plost common /a0a4/ plost,pnab real(kind=wp), public :: pnab common /a0a4/ plost,pnab real(kind=wp), public :: vlf real(kind=wp), public :: vrt real(kind=wp), public :: dflf real(kind=wp), public :: dfrt Subroutines public  subroutine distr (vz, j, ifound, fder) Arguments Type Intent Optional Attributes Name real(kind=8) :: vz integer, intent(in) :: j integer, intent(inout) :: ifound real(kind=8) :: fder","tags":"","loc":"module\\iterator_mod.html"},{"title":"lhcd_module – FRTС project","text":"LHCD модуль Uses spectrum_mod kind_module Variables Type Visibility Attributes Name Initial type( Spectrum ), public :: full_spectrum type( Spectrum ), public :: pos_spectr type( Spectrum ), public :: neg_spectr real(kind=wp), public, dimension(:), allocatable :: vvj real(kind=wp), public, dimension(:), allocatable :: vdfj integer, public, parameter :: kpt1 = 20 integer, public, parameter :: kpt3 = 20 Subroutines public  subroutine ourlhcd2017 (spectr, outpe, pe_out) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!sav2008       pn=fn(r)\n       pn=fn1(r,fnr)\n       pn=fn2(r,fnr,fnrr) !sav2008\n!!!!!!!read data !!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!sign of driven current in right coordinate system {dro,dteta,dfi}:\n!!!curdir=+1.0 for current drive in positive direction \"dfi\"\n!!!curdir=-1.0 for current drive in negative direction \"dfi\"\n!!!spectrum Nz>0 is along dfi>0 and Nz<0 is along dfi<0\n!!!it is also OK if Npar is used instead of Nz, but for Btor>0, that is along dfi>0\n      curdir=-dble(ispectr)\n!!!!!!!!!!!!! begin iterations !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n   find nevyazka Read more… Arguments Type Intent Optional Attributes Name type( Spectrum ) :: spectr real(kind=8), dimension(*) :: outpe real(kind=8) :: pe_out public  subroutine init_iteration () Arguments None public  subroutine gridvel (v1, v2, vmax, cdel, ni1, ni2, ipt1, kpt3, vrj) v12<v<=v2 Arguments Type Intent Optional Attributes Name double precision :: v1 double precision :: v2 double precision :: vmax double precision :: cdel integer :: ni1 integer :: ni2 integer :: ipt1 integer :: kpt3 double precision :: vrj (*) public  subroutine recalculate_f_for_a_new_mesh (ispectr) recalculate f' for a new mesh\n!         if(vrj(i).gt.vvj(i0)) exit Arguments Type Intent Optional Attributes Name integer, intent(in) :: ispectr public  subroutine alphas (d, u, j, kmax, g) Arguments Type Intent Optional Attributes Name real :: d real :: u integer, intent(in) :: j integer, intent(in) :: kmax real :: g","tags":"","loc":"module\\lhcd_module.html"},{"title":"runge_kutta_module – FRTС project","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses kind_module Abstract Interfaces abstract interface public  subroutine Iderivs_func(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y (:) real(kind=wp), intent(inout) :: dydx (:) Subroutines public  subroutine rkqc (y, dydx, n, x, htry, eps, yscal, hdid, hnext, derivs) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: y (n) real(kind=wp), intent(inout) :: dydx (n) integer, intent(in) :: n real(kind=wp), intent(inout) :: x real(kind=wp), intent(in) :: htry real(kind=wp), intent(in) :: eps real(kind=wp), intent(in) :: yscal (n) real(kind=wp), intent(inout) :: hdid real(kind=wp), intent(inout) :: hnext procedure( Iderivs_func ) :: derivs public  subroutine rk4 (y, dydx, n, x, h, yout, derivs) Arguments Type Intent Optional Attributes Name real :: y real :: dydx integer, intent(in) :: n real :: x real :: h real :: yout procedure( Iderivs_func ) :: derivs public  subroutine runge_kutta_qs (y, dydx, n, x, htry, eps, yscal, hdid, hnext, derivs) метод рунге-кутта Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: y (n) real(kind=wp), intent(inout) :: dydx (n) integer, intent(in) :: n real(kind=wp), intent(inout) :: x real(kind=wp), intent(in) :: htry real(kind=wp), intent(in) :: eps real(kind=wp), intent(in) :: yscal (n) real(kind=wp), intent(inout) :: hdid real(kind=wp), intent(inout) :: hnext procedure( Iderivs_func ) :: derivs public  subroutine rkck (y, dydx, n, x, h, yout, yerr, derivs) метод рунге-кутта, нужны подробности Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: y (n) real(kind=wp), intent(in) :: dydx (n) integer, intent(in) :: n real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: h real(kind=wp), intent(out) :: yout (n) real(kind=wp), intent(out) :: yerr (n) procedure( Iderivs_func ) :: derivs","tags":"","loc":"module\\runge_kutta_module.html"},{"title":"current – FRTС project","text":"Uses kind_module Variables Type Visibility Attributes Name Initial real(kind=wp), public :: dql (101,100) real(kind=wp), public :: pdl (100) real(kind=wp), public :: vzmin (100) real(kind=wp), public :: vzmax (100) real(kind=wp), public :: fcoll (100) real(kind=wp), public :: dens (100) real(kind=wp), public :: eta (100) real(kind=wp), public :: dq1 (101,100) real(kind=wp), public :: dq2 (101,100) real(kind=wp), public :: pdc (100) real(kind=wp), public :: pda (100) real(kind=wp), public :: ppv1 real(kind=wp), public :: ppv2 real(kind=wp), public :: pdfast (100) real(kind=wp), public :: dqi0 (50,100) real(kind=wp), public :: dncount (101,100) Subroutines public  subroutine find_achieved_radial_points (nvpt) find achieved radial points jbeg-jend Arguments Type Intent Optional Attributes Name integer, intent(in) :: nvpt public  subroutine dfind (j, i, v, powpr, pil, pic, pia, df, decv, refr, vlf, vrt, ifast) !        adde=zze (dd/dens(j)) weight\n!        e2perp(i,j)=e2perp(i,j)+adde Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: i real(kind=wp), intent(in) :: v real(kind=wp), intent(in) :: powpr real(kind=wp), intent(in) :: pil real(kind=wp), intent(in) :: pic real(kind=wp), intent(in) :: pia real(kind=wp), intent(in) :: df real(kind=wp), intent(in) :: decv real(kind=wp), intent(in) :: refr real(kind=wp), intent(in) :: vlf real(kind=wp), intent(in) :: vrt integer, intent(in) :: ifast","tags":"","loc":"module\\current.html"},{"title":"power – FRTС project","text":"","tags":"","loc":"module\\power.html"},{"title":"lock_module – FRTС project","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses kind_module Subroutines public  subroutine linf (x, y, t, fout, klo, khi) линейная аппроксимация\nTODO будет удобнее если переделать в функцию Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (*) real(kind=wp), intent(in) :: y (*) real(kind=wp), intent(in) :: t real(kind=wp), intent(out) :: fout integer, intent(in) :: klo integer, intent(in) :: khi public  subroutine lock (xa, n, x, klo, khi, ierr) что делает? Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xa (*) integer, intent(in) :: n real(kind=wp), intent(in) :: x integer, intent(inout) :: klo integer, intent(inout) :: khi integer, intent(inout) :: ierr public  subroutine lock2 (xa, n, x, klo, khi, ierr) что делает Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xa (*) integer, intent(in) :: n real(kind=wp), intent(in) :: x integer, intent(inout) :: klo integer, intent(inout) :: khi integer, intent(inout) :: ierr","tags":"","loc":"module\\lock_module.html"},{"title":"constants – FRTС project","text":"модуль с математическими и физическими константами\nnt_001 тестовый комментарий Uses kind_module Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: zero = 0.0_wp real(kind=wp), public, parameter :: one = 1.0_wp real(kind=wp), public, parameter :: two = 2.0_wp real(kind=wp), public, parameter :: one_third = 1.0_wp/3.0_wp real(kind=wp), public, parameter :: tiny = 1.e-100_wp real(kind=wp), public, parameter :: tiny1 = 1e-7_wp real(kind=wp), public, parameter :: pi = acos(-one) число Пи = 3.1415.... real(kind=wp), public, parameter :: pi2 = 2.0_wp*pi real(kind=wp), public, parameter :: pi4 = 4.0_wp*pi real(kind=wp), public, parameter :: piq = sqrt(pi) real(kind=wp), public, parameter :: pisqrt = sqrt(pi) real(kind=wp), public, parameter :: pi2sqrt = sqrt(pi2) real(kind=wp), public, parameter :: talfa = 3.5_wp alpha particles' birth energy, MeV real(kind=wp), public, parameter :: zalfa = 2.0_wp alpha particles' electrical charge real(kind=wp), public, parameter :: xmalfa = 4.0_wp alpha particles' atomic mass real(kind=wp), public, parameter :: clt = 3.0e+10_wp скорость света real(kind=wp), public, parameter :: pme = 9.11e-28_wp real(kind=wp), public, parameter :: pme_e = 9.11e-28 real(kind=wp), public, parameter :: pqe = 4.803e-10_wp real(kind=wp), public, parameter :: xlog = 16.0_wp+dlog(16.0_wp) real(kind=wp), public, parameter :: c0 = sqrt(pi4*pqe**2/pme) real(kind=wp), public, parameter :: c1 = pqe/pme/clt real(kind=wp), public, parameter :: xsgs = 1e+13_wp 1MW = 1e13 erg/s real(kind=wp), public, parameter :: xwtt = 1e-7_wp real(kind=wp), public, parameter :: cnst1 = 0.2965924106e-6_wp cnst1=(m_e/m_p)**2, CGS real(kind=wp), public, parameter :: cnst2 = 0.359680922e-35_wp cnst2=(m_e/e)**2,  CGS Subroutines public  subroutine show_constants () Arguments None","tags":"","loc":"module\\constants.html"},{"title":"rt_parameters – FRTС project","text":"Uses kind_module Variables Type Visibility Attributes Name Initial real(kind=wp), public :: freq Freq,     RF frequency, GHz real(kind=wp), public :: xmi1 Mi1/Mp,  relative mass of ions 1 real(kind=wp), public :: zi1 charge of ions 1 real(kind=wp), public :: xmi2 Mi2/Mp,  relative mass of ions 2 real(kind=wp), public :: zi2 charge of ions 2 real(kind=wp), public :: dni2 0.03   Ni2/Ni1, relative density of ions 2 real(kind=wp), public :: xmi3 Mi3/Mp,  relative mass of ions 3 real(kind=wp), public :: zi3 charge of ions 3 real(kind=wp), public :: dni3 Ni3/Ni1, relative density of ions 3 !!!!!!!!!!!  parameters for alphas calculations !!! integer, public :: itend0 itend0,   if = 0, no alphas real(kind=wp), public :: energy energy,   max. perp. energy of alphas (MeV) real(kind=wp), public :: factor factor,   factor in alpha source real(kind=wp), public :: dra dra,      relative alpha source broadening (dr/a) integer, public :: kv kv,       V_perp  greed number !!!!!!!!!!! numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! integer, public :: nr nr,  radial grid number  <= 505 real(kind=wp), public :: hmin1 hmin1, rel.(hr) min. step in the Fast comp. mode, <1.d0 real(kind=wp), public :: rrange rrange,   rel.(hr) size of a 'turning' point region, <1.d0 real(kind=wp), public :: eps eps,      accuracy real(kind=wp), public :: eps_const eps,      accuracy real(kind=wp), public :: hdrob hdrob,    h4 correction, real(kind=wp), public :: cleft cleft,    left Vz plato border shift (<1) real(kind=wp), public :: cright cright,   right Vz plato border shift (>1) real(kind=wp), public :: cdel cdel,     (left part)/(Vz plato size) real(kind=wp), public :: rbord rbord,    relative radius of reflection, <1. real(kind=wp), public :: pchm pchm,     threshold between 'strong' and weak' absorption, <1. real(kind=wp), public :: pabs0 pabs,     part of remaining power interp. as absorption real(kind=wp), public :: pgiter pgiter,   relative accuracy to stop iterations integer, public :: ni1 ni1,      grid number in the left part of Vz plato integer, public :: ni2 ni2,      grid number in the right part of Vz plato integer, public :: niterat niterat,  maximal number of iterations integer, public :: nmaxm (4) nmaxm(1), permitted reflections at 0 iteration\nnmaxm(2), permitted reflections at 1 iteration\nnmaxm(3), permitted reflections at 2 iteration\nnmaxm(4), permitted reflections at 3 iteration integer, public :: maxstep2 maxstep2, maximal steps' number in Fast comp. mode integer, public :: maxstep4 maxstep4, maximal steps' number in Slow comp. mode !!!!!!!!!!!  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! integer, public :: ipri ipri, printing output monitoring: 0,1,2,3,4 integer, public :: iw iw, initial mode (slow=1, fast=-1) integer, public :: ismth ismth, if=0, no smoothing in Ne(rho),Te(rho),Ti(rho) integer, public :: ismthalf ismthalf,  if=0, no smoothing in D_alpha(vperp) integer, public :: ismthout ismthout,  if=0, no smoothing in output profiles integer, public :: inew inew=0 for usual tokamak&Ntor_grill; 1 or 2 for g' in ST&Npol_grill integer, public :: itor itor,      +-1, Btor direction in right coord{drho,dteta,dfi} integer, public :: i_pol ipol,      +-1, Bpol direction in right coord{drho,dteta,dfi} !!!!!!!!!!!  grill parameters and input LH spectrum !!!!!!!!!!!! real(kind=wp), public :: zplus Zplus,    upper grill corner in centimeters real(kind=wp), public :: zminus Zminus,   lower grill corner in centimeters integer, public :: ntet ntet,     theta grid number integer, public :: nnz nnz,      N_phi grid number integer, public :: spectrum_type spectrum type 1 - 1D, 2 = 2D, 3, scatter Subroutines public  subroutine show_parameters () Arguments None public  subroutine read_parameters (file_name) !!!!!!!!!!!  read  physical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read parameters for alphas calculation !!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read  numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read grill parameters and input LH spectrum !!!!!!!!!!!!\n!!!!!!!!!!! checking initial parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name character(len=*) :: file_name","tags":"","loc":"module\\rt_parameters.html"},{"title":"driver_module – FRTС project","text":"Uses kind_module Variables Type Visibility Attributes Name Initial integer, public, parameter :: length = 5000000 common/agh/xnpar,vel,dland,dcoll,dalf,perpn,tetai,jrad,iww,izz integer, public :: irs integer, public :: iabsorp real(kind=wp), public :: rzz common /abc/ rzz,tetzz,xmzz real(kind=wp), public :: tetzz common /abc/ rzz,tetzz,xmzz real(kind=wp), public :: xmzz common /abc/ rzz,tetzz,xmzz integer, public :: iznzz common /abc/ iznzz,iwzz,irszz integer, public :: iwzz common /abc/ iznzz,iwzz,irszz integer, public :: irszz common /abc/ iznzz,iwzz,irszz real(kind=wp), public :: hrad integer, public :: ind integer, public :: im4 real(kind=wp), public :: pow common /acg/ pow real(kind=wp), public :: pintld4 real(kind=wp), public :: pintcl4 real(kind=wp), public :: pintal4 Functions public  function dql1 (ifound, jfoundr, pabs) result(powccc) pintld=-pintld4*dfdv Arguments Type Intent Optional Attributes Name integer, intent(in) :: ifound integer, intent(in) :: jfoundr real(kind=wp), intent(in) :: pabs Return Value real(kind=wp) Subroutines public  subroutine memorize_trajectory_point4 (ro, theta) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ro real(kind=wp), intent(in) :: theta public  subroutine memorize_trajectory_point (vz, j, ro, powccc, driver) memorize trajectory point Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vz integer, intent(in) :: j real(kind=wp), intent(in) :: ro real(kind=wp), intent(in) :: powccc integer, intent(in) :: driver public  subroutine driver2 (ystart, x1, x2, xsav, hmin, h1, pabs) solve eqs. starting from xbeg\nystart(1) = tet\nystart(2) = xm\nx1 = xbeg rini\nx2 = xend Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ystart (2) real(kind=wp), intent(in) :: x1 real(kind=wp), intent(inout) :: x2 real(kind=wp), intent(inout) :: xsav real(kind=wp), intent(in) :: hmin real(kind=wp), intent(in) :: h1 real(kind=wp), intent(in) :: pabs public  subroutine extd2 (x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y (:) real(kind=wp), intent(inout) :: dydx (:) public  subroutine difeq (y, dydx, nv, x, htry, eps, yscal, hdid, hnext, derivs) ! зачем save ????? Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: y (nv) real(kind=wp), intent(in) :: dydx (nv) integer, intent(in) :: nv real(kind=wp), intent(inout) :: x real(kind=wp), intent(in) :: htry real(kind=wp), intent(in) :: eps real(kind=wp), intent(inout) :: yscal (nv) real(kind=wp), intent(inout) :: hdid real(kind=wp), intent(inout) :: hnext procedure( Iderivs_func ) :: derivs public  subroutine mmid (y, dydx, nvar, xs, htot, nstep, yout, derivs) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: y (nvar) real(kind=wp), intent(in) :: dydx (nvar) integer, intent(in) :: nvar real(kind=wp), intent(in) :: xs real(kind=wp), intent(in) :: htot integer, intent(in) :: nstep real(kind=wp), intent(inout) :: yout (nvar) procedure( Iderivs_func ) :: derivs public  subroutine rzextr (iest, xest, yest, yz, dy, nv) rational extrapolation\nзачем save ???? Arguments Type Intent Optional Attributes Name integer, intent(in) :: iest real(kind=wp), intent(in) :: xest real(kind=wp), intent(in) :: yest (nv) real(kind=wp), intent(inout) :: yz (nv) real(kind=wp), intent(inout) :: dy (nv) integer, intent(in) :: nv public  subroutine pzextr (iest, xest, yest, yz, dy, nv) polynomial extrapolation Arguments Type Intent Optional Attributes Name integer :: iest double precision :: xest double precision :: yest (nv) double precision :: yz (nv) double precision :: dy (nv) integer :: nv public  subroutine driver4 (ystart, x1, x2, rexi, hmin, derivs) var        if(dabs(dydx(3)).ne.zero) h=dabs(hmin1/dydx(3))/hdrob1\n    if(dabs(y(3)-rexi).gt.rrange.or.nstp.eq.maxstep4) then  ! exit !sav2008 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ystart (:) real(kind=wp), intent(inout) :: x1 real(kind=wp), intent(inout) :: x2 real(kind=wp), intent(in) :: rexi real(kind=wp), intent(in) :: hmin procedure( Iderivs_func ) :: derivs","tags":"","loc":"module\\driver_module.html"},{"title":"trajectory_data – FRTС project","text":"Uses kind_module Variables Type Visibility Attributes Name Initial integer, public, parameter :: max_size = 10000 type( Trajectory ), public, pointer :: current_trajectory Derived Types type, public :: TrajectoryPoint тип для хранения точки тректории Components Type Visibility Attributes Name Initial real(kind=wp), public :: dland real(kind=wp), public :: dcoll real(kind=wp), public :: perpn real(kind=wp), public :: dalf real(kind=wp), public :: vel real(kind=wp), public :: tetai real(kind=wp), public :: xnpar real(kind=wp), public :: rho real(kind=wp), public :: vthc real(kind=wp), public :: poloidn integer, public :: izz integer, public :: iww integer, public :: jrad integer, public :: driver value = 2 or 4, где была создана точка в driver2 или driver4 type, public :: Trajectory Components Type Visibility Attributes Name Initial integer, public :: size size of Trajectory real(kind=wp), public :: tetin real(kind=wp), public :: xmin real(kind=wp), public :: rin real(kind=wp), public :: yn3 real(kind=wp), public :: pow integer, public :: irs integer, public :: iw integer, public :: izn integer, public :: spectrum_point_index integer, public :: mbad integer, public :: nrefj real(kind=wp), public :: tetzap real(kind=wp), public :: xmzap real(kind=wp), public :: rzap real(kind=wp), public :: yn3zap real(kind=wp), public :: powexit integer, public :: irszap integer, public :: iwzap integer, public :: iznzap type( TrajectoryPoint ), public, allocatable :: points (:) Type-Bound Procedures procedure, public :: init => init_method procedure, public :: reset => reset_method procedure, public :: add_point => add_point_method procedure, public :: write_info => write_info_method Subroutines public  subroutine init_method (this, theta, index) инициализация траетории Arguments Type Intent Optional Attributes Name class( Trajectory ), intent(inout) :: this real(kind=wp), intent(in) :: theta integer, intent(in) :: index public  subroutine reset_method (this, index) сброс счетчика Arguments Type Intent Optional Attributes Name class( Trajectory ), intent(inout) :: this integer, intent(in) :: index public  subroutine add_point_method (this, tpoint) добавляение новой точнки траектории Arguments Type Intent Optional Attributes Name class( Trajectory ), intent(inout) :: this class( TrajectoryPoint ), intent(in) :: tpoint public  subroutine write_info_method (this, iu) сохранение в файл информации о траектории Arguments Type Intent Optional Attributes Name class( Trajectory ), intent(inout) :: this integer, intent(in) :: iu","tags":"","loc":"module\\trajectory_data.html"},{"title":"chang_cooper_module – FRTС project","text":"Uses kind_module Subroutines public  subroutine chang_cooper_solver (alfa2, nt, h, dt, n, ybeg, yend, d1, d2, d3, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 integer, intent(in) :: nt real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: d1 (n+1) real(kind=wp), intent(in) :: d2 (n+1) real(kind=wp), intent(in) :: d3 (n+1) real(kind=wp), intent(inout) :: y (n+2) public  subroutine chang_cooper_abcoef (alfa2, a, b, c, f, y, dt, n, ybeg, yend, xx, h, df) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 real(kind=wp), intent(inout) :: a (n) real(kind=wp), intent(inout) :: b (n) real(kind=wp), intent(inout) :: c (n) real(kind=wp), intent(inout) :: f (n) real(kind=wp), intent(inout) :: y (n+2) real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: xx (n+1) real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: df (n+1)","tags":"","loc":"module\\chang_cooper_module.html"},{"title":"manager_mod – FRTС project","text":"модуль определяет начальные значения лучей и запускает трассировку Uses kind_module Subroutines public  subroutine manager (iterat, iw0, ntet, spectr) Arguments Type Intent Optional Attributes Name integer :: iterat integer :: iw0 integer :: ntet type( Spectrum ) :: spectr public  subroutine rini (traj, point, iw0) Arguments Type Intent Optional Attributes Name class( Trajectory ), intent(inout) :: traj type( SpectrumPoint ), intent(in) :: point integer, intent(in) :: iw0 public  subroutine dqliter (dltpow, traj, h, powexit, iout) !old variant\n!       call raspr(v,abs(jr),iv,df)\n!       if(iv.eq.0) iv=1\n!!!!!!!!!!!!!!!!!!!!!!!!\n       dfsr=v df (vrt-vlf)\n       vsr=v (vrt-vlf)\n        pintld=-dland(i) (dflf+dfrt)/2d0\n        pdec1=-pdecv*df Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: dltpow type( Trajectory ), intent(in), pointer :: traj real(kind=wp), intent(in) :: h real(kind=wp), intent(out) :: powexit integer, intent(inout) :: iout","tags":"","loc":"module\\manager_mod.html"},{"title":"kind_module – FRTС project","text":"Uses iso_fortran_env Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = real64 double precision reals","tags":"","loc":"module\\kind_module.html"},{"title":"driven_current_module – FRTС project","text":"Driven Current Module Uses kind_module Variables Type Visibility Attributes Name Initial real(kind=wp), public :: zv1 (100,2) real(kind=wp), public :: zv2 (100,2) Interfaces public        interface DrivenCurrent public  function DrivenCurrent_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( DrivenCurrent ) public        interface DrivenCurrentResult public  function DrivenCurrentResult_constructor (positive_dc, negative_dc) result(this) Arguments Type Intent Optional Attributes Name type( DrivenCurrent ), intent(in) :: positive_dc type( DrivenCurrent ), intent(in) :: negative_dc Return Value type( DrivenCurrentResult ) Derived Types type, public :: DrivenCurrent Components Type Visibility Attributes Name Initial real(kind=wp), public :: cu ??  может лучше cuj real(kind=wp), public :: cu0 ??              cujoh real(kind=wp), public :: c ?? real(kind=wp), public :: c0 ?? real(kind=wp), public, dimension(:), allocatable :: outj outj(i)  = LH driven current density, MA/m&#94;2 real(kind=wp), public, dimension(:), allocatable :: ohj integer, public :: grid_size Constructor public\n\n                    \n                    function DrivenCurrent_constructor (size) Type-Bound Procedures procedure, public :: evaluate => DrivenCurrent_evaluate type, public :: DrivenCurrentResult Components Type Visibility Attributes Name Initial real(kind=wp), public :: cup real(kind=wp), public :: cp real(kind=wp), public :: cum real(kind=wp), public :: cm real(kind=wp), public :: cup0 real(kind=wp), public :: cp0 real(kind=wp), public :: cum0 real(kind=wp), public :: cm0 Constructor public\n\n                    \n                    function DrivenCurrentResult_constructor (positive_dc, negative_dc) Type-Bound Procedures procedure, public :: print => driven_current_result_print procedure, public :: save => driven_current_result_save Functions public  function DrivenCurrent_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( DrivenCurrent ) public  function DrivenCurrentResult_constructor (positive_dc, negative_dc) result(this) Arguments Type Intent Optional Attributes Name type( DrivenCurrent ), intent(in) :: positive_dc type( DrivenCurrent ), intent(in) :: negative_dc Return Value type( DrivenCurrentResult ) Subroutines public  subroutine DrivenCurrent_evaluate (this, ROC) Arguments Type Intent Optional Attributes Name class( DrivenCurrent ), intent(inout) :: this real(kind=wp), intent(in) :: ROC public  subroutine driven_current_result_print (this, time) Arguments Type Intent Optional Attributes Name class( DrivenCurrentResult ), intent(in) :: this real(kind=wp), intent(in) :: time public  subroutine driven_current_result_save (this, time) Arguments Type Intent Optional Attributes Name class( DrivenCurrentResult ), intent(in) :: this real(kind=wp), intent(in) :: time","tags":"","loc":"module\\driven_current_module.html"},{"title":"iteration_result_mod – FRTС project","text":"Uses kind_module Derived Types type, public :: IterationResult Components Type Visibility Attributes Name Initial integer, public :: number iteration number 'iteration=',iterat integer, public :: spectr_direction 'ispectr=',ispectr real(kind=wp), public :: P_launched P_launched, MW=',plaun real(kind=wp), public :: P_landau 'P_landau, MW=',ol real(kind=wp), public :: P_coll 'P_coll, MW=',oc real(kind=wp), public :: P_alph 'P_alph, MW=',oa real(kind=wp), public :: alphas_power 'Alphas power, MW=',fuspow real(kind=wp), public :: P_fast real(kind=wp), public :: P_lost real(kind=wp), public :: P_not_accounted real(kind=wp), public :: P_landau_strong_absorption real(kind=wp), public :: P_landau_weak_absorption real(kind=wp), public :: P_turns real(kind=wp), public :: efficiency real(kind=wp), public :: avedens real(kind=wp), public :: r0 real(kind=wp), public :: eta_eff real(kind=wp), public :: residual невязка 'nevyazka=', pchg Type-Bound Procedures procedure, public :: print => iteration_result_print procedure, public :: save => iteration_result_save Subroutines public  subroutine iteration_result_print (this) Arguments Type Intent Optional Attributes Name class( IterationResult ), intent(in) :: this public  subroutine iteration_result_save (this, time_stamp) save Iteration Result to file Arguments Type Intent Optional Attributes Name class( IterationResult ), intent(in) :: this real(kind=wp), intent(in) :: time_stamp","tags":"","loc":"module\\iteration_result_mod.html"},{"title":"spectrum_mod – FRTС project","text":"Uses kind_module Interfaces public        interface Spectrum public  function spectrum_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( Spectrum ) Derived Types type, public :: SpectrumPoint Components Type Visibility Attributes Name Initial real(kind=wp), public :: Ntor Ntau=-Ntor real(kind=wp), public :: Npol Ntet=Npol real(kind=wp), public :: power power type, public :: Spectrum Components Type Visibility Attributes Name Initial integer, public :: size size of spectrum real(kind=wp), public :: input_power power of spectrum real(kind=wp), public :: power_ratio доля входной мощности real(kind=wp), public :: max_power real(kind=wp), public :: sum_power суммарная power integer, public :: direction направление спектра   +1 или -1 или 0 - полный type( SpectrumPoint ), public, allocatable :: data (:) Constructor public\n\n                    \n                    function spectrum_constructor (size) Type-Bound Procedures procedure, public :: get_positive_part => get_positive_part_method procedure, public :: get_negative_part => get_negative_part_method procedure, public :: calc_max_power => calc_max_power_method procedure, public :: normalization => normalization_method procedure, public :: integral_trapez => integral_trapez_method procedure, public :: write => write_spectrum Functions public  function spectrum_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( Spectrum ) public  function integral_trapez_method (this) result(sum) вычисление полной мощности спектра\nинтегрирование методом трапеций Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(in) :: this Return Value real(kind=wp) public  function get_positive_part_method (this) result(spectr) Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(in) :: this Return Value type( Spectrum ) public  function get_negative_part_method (this) result(spectr) Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(in) :: this Return Value type( Spectrum ) public  function read_spectrum (file_name) result(spectr) Arguments Type Intent Optional Attributes Name character(len=*), value :: file_name Return Value type( Spectrum ) public  function make_spline_approximation (spectr) result(appx_spectr) approximation of input LH spectrum Arguments Type Intent Optional Attributes Name type( Spectrum ), intent(in) :: spectr Return Value type( Spectrum ) Subroutines public  subroutine calc_max_power_method (this) Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(inout) :: this public  subroutine normalization_method (this) Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(inout) :: this public  subroutine write_spectrum (this, spectrum_name) write spectrum to file Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(inout) :: this character(len=*), intent(in) :: spectrum_name public  subroutine divide_spectrum (spectr, pos_spectr, neg_spectr) деление спектра на две части Arguments Type Intent Optional Attributes Name type( Spectrum ), intent(in) :: spectr type( Spectrum ), intent(out) :: pos_spectr type( Spectrum ), intent(out) :: neg_spectr","tags":"","loc":"module\\spectrum_mod.html"},{"title":"chebyshev – FRTС project","text":"Chebyshev fit Uses kind_module Functions public  function chebev (a, b, c, m, x) Chebyshev evaluation: All arguments are input. \nc(1:m) is an array of Chebyshev coefficients, the first m elements \nof c output from chebft (which must have been called with\nthe same a and b). The Chebyshev polynomial evaluated\nand the result is returned as the function value. Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: c (m) integer :: m real(kind=wp) :: x Return Value real(kind=wp) Subroutines public  subroutine chebft1 (a, b, c, n, func) Chebyshev fit: Given a function func, lower and upper limits\nof the interval [a,b], and a maximum degree n, this routine \ncomputes the n coefficients c(k) such that func(x) approximately =\nSUMM_(k=1)&#94;(k=n)[c(k)*T(k-1)(y)]-c(1)/2, where y and x are related by\n(5.8.10). This routine is to be used with moderately large n \n(e.g., 30 or 50), the array of cs subsequently to be truncated\nat the smaller value m such that c(m+1) and subsequent elements \nare negligible. Parameters: Maximum expected value of n, and ð. Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: c (n) integer :: n real :: func public  subroutine chder (a, b, c, cder, n) Given a,b,c(1:n), as output from routine chebft(), and given n, \nthe desired degree of approximation (length of c to be used), \nthis routine returns the array cder(1:n), the Chebyshev \ncoefficients of the derivative of the function whose coefficients \nare c(1:n). Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: c (n) real(kind=wp) :: cder (n) integer :: n","tags":"","loc":"module\\chebyshev.html"},{"title":"maxwell – FRTС project","text":"Все что относится к распределению Максвелла Uses constants kind_module Variables Type Visibility Attributes Name Initial integer, public, parameter :: i0 = 1002 real(kind=wp), public :: v_grid (i0,100) сетка обычных скоростей real(kind=wp), public :: vij (i0,100) real(kind=wp), public :: fij0 (i0,100,2) real(kind=wp), public :: fij (i0,100,2) real(kind=wp), public :: dfij (i0,100,2) real(kind=wp), public :: dij (i0,100,2) logical, public :: flag_d0 бывший d0 integer, public :: jindex common/dddql/ d0,jindex,kindex integer, public :: kindex common/dddql/ d0,jindex,kindex Functions public  function currlhcd (v, f) result(curs) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: v (:) real(kind=wp), intent(in) :: f (:) Return Value real(kind=wp) public  function create_vt_grid (vclt) result(vt_grid) создание сетки тепловых скоростей Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt Return Value real(kind=wp), (i0) public  function funmaxwell (v, dfunmaxwell) распределение Максвелла и его производная Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: dfunmaxwell Return Value real(kind=wp) public  function fmaxw_classic (v, alfa2, dfmaxw) распределение Максвелла с альфа-частицами и его производная Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 real(kind=wp) :: dfmaxw Return Value real(kind=wp) public  function fmaxw_ext (v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 real(kind=wp) :: dfmaxw Return Value real(kind=wp) public  function fmaxw (v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 real(kind=wp) :: dfmaxw Return Value real(kind=wp) public  function psiq (v, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 Return Value real(kind=wp) public  function erfcc (x) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x Return Value real(kind=wp) Subroutines public  subroutine init_vi (vclt, vi) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt real(kind=wp), intent(out) :: vi (i0) public  subroutine init_fmaxw_classic (vclt, enorm, fi, dfi) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt real(kind=wp), intent(in) :: enorm real(kind=wp), intent(out) :: fi (i0) real(kind=wp), intent(out) :: dfi (i0) public  subroutine init_fmaxw_ext (vclt, enorm, fi, dfi) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt real(kind=wp), intent(in) :: enorm real(kind=wp), intent(out) :: fi (i0) real(kind=wp), intent(out) :: dfi (i0)","tags":"","loc":"module\\maxwell.html"},{"title":"spline_module – FRTС project","text":"сплайны\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses kind_module Subroutines public  subroutine splne (x, y, n, y2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x (n) real(kind=wp) :: y (n) integer :: n real(kind=wp) :: y2 (n) public  subroutine splnt (xa, ya, y2a, n, x, y, dy) Arguments Type Intent Optional Attributes Name real(kind=wp) :: xa (n) real(kind=wp) :: ya (n) real(kind=wp) :: y2a (n) integer :: n real(kind=wp) :: x real(kind=wp) :: y real(kind=wp) :: dy public  subroutine dsplnt (xa, ya, y2a, n, x, y, dy, ddy) Arguments Type Intent Optional Attributes Name real(kind=wp) :: xa (n) real(kind=wp) :: ya (n) real(kind=wp) :: y2a (n) integer :: n real(kind=wp) :: x real(kind=wp) :: y real(kind=wp) :: dy real(kind=wp) :: ddy","tags":"","loc":"module\\spline_module.html"},{"title":"1_utils.f90 – FRTС project","text":"Source Code module utils use kind_module implicit none type Timer real ( wp ) :: start_time real ( wp ) :: end_time real ( wp ) :: elapsed_time real ( wp ) :: plasma_time character ( 120 ) :: file_name contains procedure :: start => Time_start procedure :: stop => Time_stop procedure :: stop_and_save => Time_stop_and_save end type Timer contains subroutine Time_start ( this , fn , pt ) implicit none class ( Timer ), intent ( inout ) :: this character ( * ), intent ( in ) :: fn real ( wp ), intent ( in ) :: pt this % plasma_time = pt this % start_time = sys_time () this % file_name = fn end subroutine subroutine Time_stop ( this ) implicit none class ( Timer ), intent ( inout ) :: this this % end_time = sys_time () this % elapsed_time = this % end_time - this % start_time end subroutine subroutine Time_stop_and_save ( this ) implicit none class ( Timer ), intent ( inout ) :: this integer io call this % stop open ( newunit = io , file = this % file_name , position = \"append\" ) write ( io , '(2f22.14)' ) this % plasma_time , this % elapsed_time close ( io ) end subroutine function sys_time () ! ** return system time implicit none real ( wp ) sys_time integer count , count_rate , count_max call system_clock ( count , count_rate , count_max ) sys_time = count * 1.0 / count_rate return end end  module utils","tags":"","loc":"sourcefile\\1_utils.f90.html"},{"title":"3_dispersion.f90 – FRTС project","text":"Source Code module metrics use kind_module implicit none real ( wp ) :: g11 , g12 , g22 , g33 , gg , g , si , co !!common/metrika/g11,g12,g22,g33,gg,g,si,co real ( wp ) :: g2v1 , g2jq , g3v real ( wp ) :: b , bp , bt real ( wp ) :: x0 , x0t , xj , xjt real ( wp ) :: dxdr , dxdt , dzdr , dzdt real ( wp ) :: dxdrdt , dxdtdt , dzdrdt , dzdtdt real ( wp ) :: bat , bpt , btt real ( wp ) :: g2jqt real ( wp ) :: g11t , g22t , g33t , g12t , gprt contains subroutine calculate_metrics ( pa , ptet ) use constants use approximation use plasma use rt_parameters implicit none real ( wp ), intent ( in ) :: pa real ( wp ), intent ( in ) :: ptet real ( wp ) :: xdl , xdlp , xly , xlyp real ( wp ) :: xgm , xgmp , xmy , xmyp , xlyv , cotet , sitet xdl = fdf ( pa , cdl , ncoef , xdlp ) xly = fdf ( pa , cly , ncoef , xlyp ) xgm = fdf ( pa , cgm , ncoef , xgmp ) xmy = fdf ( pa , cmy , ncoef , xmyp ) xlyv = xlyp * pa + xly cotet = dcos ( ptet ) sitet = dsin ( ptet ) !---------------- dxdr =- xdlp + cotet - xgmp * sitet ** 2 dxdt =- ( pa + two * xgm * cotet ) * sitet dzdr = xlyv * sitet dzdt = xly * pa * cotet x0 = r0 / rm - xdl + pa * cotet - xgm * sitet ** 2 dxdrdt =- sitet - two * xgmp * sitet * cotet dzdrdt = xlyv * cotet dxdtdt =- pa * cotet - two * xgm * ( cotet ** 2 - sitet ** 2 ) dzdtdt =- xly * pa * sitet x0t = dxdt !-------------------------------------- ! components of metric tensor !-------------------------------------- g11 = dxdr ** 2 + dzdr ** 2 g22 = dxdt ** 2 + dzdt ** 2 g12 = dxdr * dxdt + dzdr * dzdt g33 = x0 ** 2 xj = ( dzdr * dxdt - dxdr * dzdt ) ** 2 !gg=g11*g22-g12*g12 gg = xj g = xj * g33 g2v1 = one / dsqrt ( g22 ) g2jq = dsqrt ( g22 / xj ) g3v = one / dsqrt ( g33 ) !-------------------------------------- !  magnetic field !-------------------------------------- bt = b_tor * ( r0 / rm ) / x0 bp = g2jq * g3v * xmy ! dsqrt(g22/xj)/dsqrt(g33) b = dsqrt ( bp * bp + bt * bt ) si = bp / b co = bt / b !------ calculation of derivatives ------ g11t = two * ( dxdr * dxdrdt + dzdr * dzdrdt ) g22t = two * ( dxdt * dxdtdt + dzdt * dzdtdt ) g33t = two * x0 * ( - pa * sitet - two * xgm * sitet * cotet ) g12t = dxdrdt * dxdt + dxdr * dxdtdt + dzdrdt * dzdt + dzdr * dzdtdt xjt = g11t * g22 + g22t * g11 - two * g12 * g12t btt =- b_tor * ( r0 / rm ) / x0 ** 2 * x0t g2jqt = ( g22t / xj - g22 / xj ** 2 * xjt ) / ( g2jq * two ) bpt = xmy * ( g2jqt * g3v - . 5 d0 * g2jq * g3v / g33 * g33t ) bat = one / b * ( bp * bpt + bt * btt ) end subroutine calculate_metrics end module metrics module dielectric_tensor !! components of dielectric tensor use kind_module use metrics implicit none real ( wp ) :: e1 , e2 , e3 real ( wp ) :: pn , fnr , wpq , whe , v , u1 , u contains subroutine calculate_dielectric_tensor ( pa ) !! calculate components of dielectric tensor use constants , only : zero , one , two use constants , only : c0 , c1 , pi use rt_parameters , only : inew use plasma , only : fn1 , fn2 use plasma , only : ww , xmi implicit none real ( wp ), intent ( in ) :: pa real ( wp ) :: fnrr pn = 0 fnr = 0 fnrr = 0 if ( inew . eq . 0 ) then !vardens pn = fn1 ( pa , fnr ) else pn = fn2 ( pa , fnr , fnrr ) end if wpq = c0 ** 2 * pn whe = b * c1 v = wpq / ww ** 2 u1 = whe / ww u = u1 ** 2 e1 = one - v * ( one / xmi - one / u ) e2 = v / u1 e3 = one - v end subroutine end module dielectric_tensor module dispersion_equation !! dispersion equation use kind_module use metrics implicit none real ( wp ) :: ynz , ynzq real ( wp ) :: as , bs , cs real ( wp ) :: pnew , yny , gpr , dls contains subroutine calculate_dispersion_equation ( yn2 , yn3 ) use constants , only : zero , one , two use constants , only : c0 , c1 use dielectric_tensor use rt_parameters , only : inew use plasma , only : ww , xsz implicit none real ( wp ), intent ( in ) :: yn2 , yn3 !real(wp) :: ! dispersion equation !-------------------------------------- !sav2008      if(ivar.eq.2) yn2=(ynz-yn3*co*g3v)/(si*g2v1) ynz = yn2 * si * g2v1 + yn3 * co * g3v ynzq = ynz ** 2 as = e1 bs =- ( e1 ** 2 - e2 ** 2 + e1 * e3 - ( e1 + e3 ) * ynzq ) cs = e3 * ( e1 ** 2 - e2 ** 2 - two * e1 * ynzq + ynzq ** 2 ) !----------------------------- !est !sav2009 pnew = zero yny = - ( yn2 * g2v1 * co - yn3 * g3v * si ) if ( inew . gt . 0 ) then if ( inew . eq . 1 ) then yny = - ( yn2 * g2v1 * co - yn3 * g3v * si ) elseif ( inew . eq . 2 ) then yny = - g2jq * ( yn2 * g2v1 * co - yn3 * g3v * si ) end if gpr = c0 ** 2 / ww ** 2 / u1 * fnr * xsz pnew = yny * gpr bs = bs + pnew cs = cs + pnew * ( ynzq - e3 ) end if !------------------------------------ dls = bs * bs - 4 d0 * as * cs !c      write(*,*)'rho=',pa,' teta=',ptet !c      write(*,*)'N2=',yn2,' N3=',yn3 !c      write(*,*)'Npar=',ynz,' e1=',e1 !c      write(*,*)'v=',v,' u=',u !c      write(*,*)'whe=',whe,' ww=',ww !c      write(*,*)'e2=',e2,' e3=',e3 !c      write(*,*)'bs=',bs,' as=',as !c      write(*,*)'cs=',cs,' dls=',dls !c      pause end subroutine end module dispersion_equation module partial_derivatives !! calculation of partial derivatives use kind_module implicit none contains subroutine calculate_partial_derivatives ( yn2 , yn3 , dl1 , ynpopq , al , bl , dl2 , prt , prm ) use constants , only : zero , one , two use constants , only : c0 , c1 use metrics use dielectric_tensor use dispersion_equation use rt_parameters , only : inew use plasma , only : ww , xsz implicit none real ( wp ), intent ( in ) :: yn2 , yn3 , dl1 , ynpopq , al , bl , dl2 real ( wp ), intent ( out ) :: prt , prm real ( wp ) :: s1 , p1 , p2 , p3 , ynzt , e1t , e2t , u1t , cot , sit real ( wp ) :: s2 , dnm , v1 , v2 , vvt , vvm real ( wp ) :: ynyt , dnym real ( wp ) :: pnewt real ( wp ) :: s21 , sjg , s23 , s24 , s22 !-------------------------------------- !   calculation of derivatives !-------------------------------------- !g11t=two*(dxdr*dxdrdt+dzdr*dzdrdt) !g22t=two*(dxdt*dxdtdt+dzdt*dzdtdt) !g33t=two*x0*(-pa*sitet-two*xgm*sitet*cotet) !g12t=dxdrdt*dxdt+dxdr*dxdtdt+dzdrdt*dzdt+dzdr*dzdtdt !xjt=g11t*g22+g22t*g11-two*g12*g12t !btt=-b_tor*(r0/rm)/x0**2*x0t !g2jqt=(g22t/xj-g22/xj**2*xjt)/(g2jq*two) !bpt=xmy*(g2jqt*g3v-.5d0*g2jq*g3v/g33*g33t) !bat=one/b*(bp*bpt+bt*btt) !----- sit = bpt / b - bp / b ** 2 * bat cot = btt / b - bt / b ** 2 * bat u1t = c1 / ww * bat e1t =- v / u ** 2 * two * u1 * u1t e2t =- v / u * u1t ynzt = yn2 * sit * g2v1 - yn2 * si * g2v1 ** 3 / two * g22t + yn3 * cot * g3v - yn3 * co * g3v ** 3 / two * g33t p1 = two * ynz * ynzt p2 = e1t p3 = ( e2 * e2t ) / e1 - e2 ** 2 / ( two * e1 ** 2 ) * e1t s1 =- p2 / ( two * e1 ** 2 ) * e3 * ( ynzq - e1 ) + ( e3 + e1 ) / ( two * e1 ) * ( p1 - p2 ) + p3 s2 = two * e3 / e1 * ( ynzq - e1 ) * ( p1 - p2 ) - p2 * e3 / ( e1 ** 2 ) * ( ynzq - e1 ) ** 2 - two * e3 * p3 dnm = two * ynz * si * g2v1 v1 = ( e3 + e1 ) / ( two * e1 ) * dnm v2 = two * e3 / e1 * ( ynzq - e1 ) * dnm !----------------------------------- !est !sav2009 if ( inew . gt . 0 ) then gprt =- c0 ** 2 / ww ** 2 * fnr / u * u1t * xsz if ( inew . eq . 1 ) then ynyt = - ( yn2 * cot * g2v1 - yn2 * co * g2v1 ** 3 / two * g22t - ( yn3 * sit * g3v - yn3 * si * g3v ** 3 / two * g33t )) dnym = - co * g2v1 else if ( inew . eq . 2 ) then ynyt = - g2jq * ( yn2 * cot * g2v1 - yn2 * co * g2v1 ** 3 / two * g22t - ( yn3 * sit * g3v - yn3 * si * g3v ** 3 / two * g33t )) ynyt = ynyt - g2jqt * ( yn2 * g2v1 * co - yn3 * g3v * si ) dnym = - g2jq * co * g2v1 end if pnewt = ( ynyt * gpr + yny * gprt ) s1 = s1 + pnewt / ( two * e1 ) - pnew / ( two * e1 ** 2 ) * e1t s2 = s2 + ( pnewt * ( ynzq - e3 ) + pnew * p1 ) / e1 - pnew * ( ynzq - e3 ) / e1 ** 2 * e1t v1 = v1 + dnym * gpr / ( two * e1 ) v2 = v2 + gpr * ( dnym * ( ynzq - e3 ) + yny * dnm ) / e1 end if !--------------------------------------------- vvt =- s1 + ( bs / as * s1 - s2 ) / ( two * dl1 ) vvm =- v1 + ( bs / as * v1 - v2 ) / ( two * dl1 ) s1 =- yn2 * ( g12t / g22 - g12 / g22 ** 2 * g22t ) s21 = yn2 ** 2 * ( g11t / g22 - g11 / g22 ** 2 * g22t ) s22 = yn3 ** 2 * ( xjt / ( g33 * g22 ) - xj / ( g33 * g22 ) ** 2 * ( g33t * g22 + g22t * g33 ) ) sjg = ( xjt * g22 - xj * g22t ) / g22 ** 2 s23 = two * ynz * ynzt * xj / g22 + sjg * ynzq s24 = vvt * xj / g22 + ynpopq * sjg s2 = s21 + s22 - s23 - s24 prt =- s1 + ( two * ( bl / al ) * s1 - s2 ) / ( two * dl2 ) s1 =- g12 / g22 s21 = two * yn2 * g11 / g22 s22 = dnm * xj / g22 s23 = vvm * xj / g22 s2 = s21 - s22 - s23 prm =- s1 + ( two * ( bl / al ) * s1 - s2 ) / ( two * dl2 ) end subroutine end module partial_derivatives module decrements use kind_module implicit none real ( wp ) :: dnx real ( wp ) :: dhdnr integer :: ifound real ( wp ) :: vfound !!common /eg1/ vfound,ifound integer :: icf1 , icf2 real ( wp ) :: pdec1 , pdec2 , pdec3 , pdecv , pdecal , dfdv !!common /eg2/ pdec1,pdec2,pdec3,pdecv,pdecal,dfdv,icf1,icf2 real ( wp ) :: cf1 , cf2 , cf3 , cf4 , cf5 , cf6 !!common /eg3/ cf1,cf2,cf3,cf4,cf5,cf6 real ( wp ) :: dgdu ( 50 , 100 ) integer :: kzero ( 100 ) !!common /arr/ dgdu(50,100),kzero(100) !! используется в zatukh, ourlhcd2017 и alphas contains subroutine calculate_decrements ( pa , yn2 , ptet , yn3 , ynpopq , xnr , jr , izn ) use constants , only : zero , one , two use constants , only : c0 , c1 , pi use constants , only : zalfa , xmalfa , xlog , clt use plasma , only : fn1 , fn2 , fvt , ft , zefff use plasma , only : ww , xmi , xsz , cltn , cnye , cnyi use plasma , only : cnstal , valfa , vperp use rt_parameters , only : inew , iw , itend0 , kv use metrics use dielectric_tensor use dispersion_equation , only : as , bs , yny , ynz , ynzq use iterator_mod use source_new_mod , only : source_new implicit none real ( wp ), intent ( in ) :: pa , yn2 , ptet , yn3 , ynpopq , xnr integer , intent ( in ) :: jr , izn real ( wp ) :: sl1 , vz , vt , fder , aimh , pnye , pnyi real ( wp ) :: tmp , fcoll , source , argum real ( wp ) :: dek1 , dek2 , dek3 !-------------------------------------- !  calculation of decrements !-------------------------------------- dnx = two * as * ynpopq + bs dhdnr = dnx * ( two * g22 * xnr - two * g12 * yn2 ) / xj sl1 = ( ynzq - e1 ) * ( ynzq + ynpopq - e1 ) - e2 ** 2 cf3 = ynz cf4 = xnr cf5 = yn2 vz = cltn / dabs ( ynz ) if ( vz . gt . cltn ) vz = cltn !sav2010 vt = fvt ( pa ) !jr=jfoundr icf1 = iw icf2 = izn call distr ( vz , jr , ifound , fder ) dfdv = fder vfound = vz cf2 = ptet cf6 = yny aimh = wpq / ww ** 2 * pi * sl1 * cltn ** 2 / ynzq pdecv = dabs ( aimh / dhdnr / xsz ) !!        pdec1=-pdecv*dfdv pdec1 = dabs ( pdecv * dfdv ) pnye = cnye * wpq ** 2 / ( pn * vt ** 3 ) pnyi = cnyi * pnye * zefff ( pa ) pdec2 = dabs ( pnyi / ww * ( wpq / whe ** 2 * ynpopq + wpq / ww ** 2 * ynzq ) * ynpopq / dhdnr / xsz ) cf1 = dsqrt ( ynpopq ) if ( itend0 . gt . 0 ) then tmp = ft ( pa ) / 0.16d-8 fcoll = . 5 d - 13 * pn * zalfa ** 2 * xlog / xmalfa / tmp ** 1.5d0 !cc          ddens=dn1*pn !cc          tdens=dn2*pn !cc          tt=fti(pa)**0.33333d0    ! (ti, kev)&#94;1/3 !cc          source=4d-12*factor*ddens*tdens*dexp(-20d0/tt)/tt**2 call source_new ( pa , source ) dek1 = cnstal * pdecv * ( 1.d0 - e3 / ynpopq ) ** 2 / cf1 dek2 = source / ( fcoll * pn ) pdecal = dek1 * dek2 pdec3 = zero if ( itend0 . gt . 0 ) then argum = clt / ( cf1 * valfa ) dek3 = zatukh ( argum , jr , vperp , kv ) pdec3 = pdecal * dek3 end if end if end subroutine real ( wp ) function zatukh ( psy , j , u , n ) use constants !implicit real*8 (a-h,o-z) implicit none real ( wp ), intent ( in ) :: psy real ( wp ), intent ( in ) :: u (:,:) integer , intent ( in ) :: j , n real ( wp ) :: x ( 50 ), y ( 50 ), a ( 50 ), b ( 50 ) real ( wp ) :: um , s1 , s2 , ss1 , ss2 , sum !common /a0befr/ pi,pi2 !common /arr/ dgdu(50,100),kzero(100) integer :: km , k , i , l km = kzero ( j ) um = u ( km , j ) if ( um . ge . one ) then zatukh = zero if ( psy . lt . one ) zatukh = . 5 d0 * pi / psy ** 3 return end if if ( psy - um . le . zero . or . u ( n , j ) - psy . le . zero ) then zatukh = zero return end if do k = 1 , n x ( k ) = u ( k , j ) y ( k ) = dgdu ( k , j ) end do i = n - 1 do l = 1 , n - 1 if ( x ( l + 1 ) - psy . gt . zero . and . psy - x ( l ). ge . zero ) i = l end do do k = i , n - 1 b ( k ) = ( y ( k + 1 ) - y ( k )) / ( x ( k + 1 ) - x ( k )) a ( k ) = y ( k ) - b ( k ) * x ( k ) end do s2 = sqrt (( x ( i + 1 ) - psy ) * ( x ( i + 1 ) + psy )) ss2 = x ( i + 1 ) + s2 sum = a ( i ) * log ( psy / ss2 ) - b ( i ) * s2 do k = 2 , n - i s1 = sqrt (( x ( i + k - 1 ) - psy ) * ( x ( i + k - 1 ) + psy )) ss1 = x ( i + k - 1 ) + s1 s2 = sqrt (( x ( i + k ) - psy ) * ( x ( i + k ) + psy )) ss2 = x ( i + k ) + s2 sum = sum + a ( i + k - 1 ) * log ( ss1 / ss2 ) + b ( i + k - 1 ) * ( s1 - s2 ) end do zatukh = sum return end end module decrements module dispersion_module use kind_module implicit none real ( wp ) :: yn3 !!common /abefo/ yn3 integer :: ivar !!common /bdeo/ ivar integer :: icall1 , icall2 !common /aef2/ icall1,icall2 integer :: izn !!common /abcde/ izn real ( wp ) :: ynpopq !real(wp) ::ynz, ynpopq !!common /bcef/ ynz,ynpopq integer iconv , irefl !!common /cefn/ iconv,irefl integer ipow , jfoundr !!common /ceg/ ipow,jfoundr real ( wp ) :: dhdm , dhdtet , dhdr , ddn , dhdn3 , dhdv2v , dhdu2u !!common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u real ( wp ) :: znakstart !!common/direct/znakstart real ( wp ) :: ham !!common/fjham/ham integer :: idec real ( wp ) :: pdec14 , pdec24 , pdec34 !!common /df/ pdec14,pdec24,pdec34,idec contains subroutine disp2_ider0 ( pa , yn2 , ptet , xnro ) ! case iroot == 1 ider == 0 ivar =0 use constants , only : zero , one , two use rt_parameters , only : iw use metrics use dielectric_tensor use dispersion_equation implicit none real ( wp ), intent ( in ) :: pa ! ro real ( wp ), intent ( in ) :: yn2 ! ??? real ( wp ), intent ( in ) :: ptet ! theta real ( wp ), intent ( out ) :: xnro ! ??? integer :: jr real ( wp ) :: dl1 , ynpopq1 , al , bl , cl , cl1 , dll real ( wp ) :: dl2 , xnr , ynyt , dnym real ( wp ) :: dnx , dll1 , e1t iconv = 0 irefl = 0 if ( pa . ge . one . or . pa . le . zero ) then pause endif icall1 = icall1 + 1 call calculate_metrics ( pa , ptet ) call calculate_dielectric_tensor ( pa ) call calculate_dispersion_equation ( yn2 , yn3 ) if ( dls . lt . zero ) then ! conversion pause iconv = 1 return end if dl1 = dfloat ( iw ) * dsqrt ( dls ) / two / as if ( iw . eq . - 1 ) ynpopq =- bs / ( two * as ) + dl1 if ( iw . eq . 1 ) ynpopq = two * cs / ( - bs - two * as * dl1 ) !cc      write(*,*)'iw=',iw,' izn=',izn,' Nperp=',dsqrt(ynpopq) !cc      write(*,*)'Nperp2=',ynpopq,' ynpopq1=',-bs/(two*as)-dl1 !cc      pause al = g22 / xj bl =- yn2 * g12 / xj cl = g11 * yn2 ** 2 / xj + yn3 ** 2 / g33 - ynzq - ynpopq dll = bl * bl - al * cl if ( dll . lt . zero ) then pause endif dl2 =- dfloat ( izn ) * dsqrt ( dll ) / al if ( izn . eq . 1 ) xnr =- bl / al + dl2 if ( izn . eq . - 1 ) xnr = cl / ( - bl - al * dl2 ) xnro = xnr end subroutine subroutine disp2 ( pa , yn2 , ptet , xnro , prt , prm ) ! case iroot == 1 ivar= 0 or 3 use constants , only : zero , one , two use rt_parameters , only : iw use metrics use dielectric_tensor use dispersion_equation use partial_derivatives use decrements implicit none real ( wp ), intent ( in ) :: pa ! ro real ( wp ), intent ( in ) :: yn2 ! ??? real ( wp ), intent ( in ) :: ptet ! theta real ( wp ), intent ( out ) :: xnro ! ??? real ( wp ), intent ( out ) :: prt ! ??? real ( wp ), intent ( out ) :: prm ! ??? integer :: jr real ( wp ) :: dl1 , ynpopq1 , al , bl , cl , cl1 , dll real ( wp ) :: dl2 , xnr !print *, 'disp2 ivar=', ivar iconv = 0 irefl = 0 if ( pa . ge . one . or . pa . le . zero ) goto 70 icall1 = icall1 + 1 call calculate_metrics ( pa , ptet ) call calculate_dielectric_tensor ( pa ) call calculate_dispersion_equation ( yn2 , yn3 ) if ( dls . lt . zero ) then ! conversion iconv = 1 if ( ivar . ne . 0 ) ivar =- 1 return end if 30 continue dl1 = dfloat ( iw ) * dsqrt ( dls ) / two / as if ( iw . eq . - 1 ) ynpopq =- bs / ( two * as ) + dl1 ! = (-bs + sqrt(dls)) / (2*as) if ( iw . eq . 1 ) ynpopq = two * cs / ( - bs - two * as * dl1 ) ! = (-bs - sqrt(dls)) * (2*cs) !cc      write(*,*)'iw=',iw,' izn=',izn,' Nperp=',dsqrt(ynpopq) !cc      write(*,*)'Nperp2=',ynpopq,' ynpopq1=',-bs/(two*as)-dl1 !cc      pause if ( ynpopq . lt . zero ) goto 70 al = g22 / xj bl =- yn2 * g12 / xj cl = g11 * yn2 ** 2 / xj + yn3 ** 2 / g33 - ynzq - ynpopq dll = bl * bl - al * cl if ( dll . lt . zero ) goto 70 40 dl2 =- dfloat ( izn ) * dsqrt ( dll ) / al if ( izn . eq . 1 ) xnr =- bl / al + dl2 ! =      (-bl - sqrt(dll)) / al if ( izn . eq . - 1 ) xnr = cl / ( - bl - al * dl2 ) ! = cl / (-bl + sqrt(dll)) xnro = xnr if ( ivar . gt . 1 ) then !cccccc  find Nr of reflected wave dnx = two * as * ynpopq + bs dhdnr = dnx * ( two * g22 * xnr - two * g12 * yn2 ) / xj if ( - znakstart * dhdnr . gt . zero ) then izn =- izn goto 40 end if return end if !-------------------------------------- !   calculation of derivatives !-------------------------------------- call calculate_partial_derivatives ( yn2 , yn3 , dl1 , ynpopq , al , bl , dl2 , prt , prm ) if ( ipow . gt . 0 ) then !-------------------------------------- !  calculation of decrements !-------------------------------------- call calculate_decrements ( pa , yn2 , ptet , yn3 , ynpopq , xnr , jfoundr , izn ) end if return !  reflection 70 irefl = 1 if ( ivar . gt . 1. and . ivar . ne . 10 ) then iw =- iw ivar = 10 goto 30 end if if ( ivar . eq . 10 ) ivar =- 1 return end subroutine disp2_iroot3 ( pa , yn2 , ptet , xnro , pg1 , pg2 , pg3 , pg4 ) ! case iroot == 3  ivar=0 use constants , only : zero , one , two use rt_parameters , only : iw use metrics use dielectric_tensor use dispersion_equation implicit none real ( wp ), intent ( in ) :: pa ! ro real ( wp ), intent ( in ) :: yn2 ! ??? real ( wp ), intent ( in ) :: ptet ! theta real ( wp ), intent ( in ) :: xnro ! ??? real ( wp ), intent ( out ) :: pg1 , pg2 , pg3 , pg4 integer :: jr real ( wp ) :: xnr1 , xnr2 , xnr3 , xnr4 real ( wp ) :: dl1 , ynpopq1 , al , bl , cl , cl1 , dll real ( wp ) :: dl2 , xnr real ( wp ) :: dll1 iconv = 0 irefl = 0 if ( pa . ge . one . or . pa . le . zero ) then print * , 'disp2_iroot3 ivar=' , ivar pause return endif icall1 = icall1 + 1 call calculate_metrics ( pa , ptet ) call calculate_dielectric_tensor ( pa ) call calculate_dispersion_equation ( yn2 , yn3 ) if ( dls . lt . zero ) then xnr1 = 1 d + 10 xnr2 = 1 d + 10 xnr3 = 1 d + 10 xnr4 = 1 d + 10 else dl1 = dfloat ( iw ) * dsqrt ( dls ) / two / as if ( iw . eq . - 1 ) ynpopq =- bs / ( two * as ) + dl1 if ( iw . eq . 1 ) ynpopq = two * cs / ( - bs - two * as * dl1 ) !cc      write(*,*)'iw=',iw,' izn=',izn,' Nperp=',dsqrt(ynpopq) !cc      write(*,*)'Nperp2=',ynpopq,' ynpopq1=',-bs/(two*as)-dl1 !cc      pause al = g22 / xj bl =- yn2 * g12 / xj cl = g11 * yn2 ** 2 / xj + yn3 ** 2 / g33 - ynzq - ynpopq dll = bl * bl - al * cl !--------------------------- !  find all roots !---------------------------- if ( dll . ge . zero ) then dl2 =- dfloat ( izn ) * dsqrt ( dll ) / al if ( izn . eq . 1 ) xnr =- bl / al + dl2 if ( izn . eq . - 1 ) xnr = cl / ( - bl - al * dl2 ) !xnro=xnr xnr1 = xnr xnr2 =- bl / al - dl2 else xnr1 = 1 d + 10 xnr2 = 1 d + 10 end if ynpopq1 =- bs / ( two * as ) - dl1 cl1 = g11 * yn2 ** 2 / xj + yn3 ** 2 / g33 - ynzq - ynpopq1 dll1 = bl ** 2 - al * cl1 if ( dll1 . lt . zero ) then xnr3 = 1 d + 10 xnr4 = 1 d + 10 else xnr3 =- bl / al - izn * dsqrt ( dll1 ) / al xnr4 =- bl / al + izn * dsqrt ( dll1 ) / al end if end if !ipric      if (ipri.gt.2) then !ipric       write (*,*)'nr check, r=',rnew,' tet=',tetnew !ipric       write (*,*)'iw=',iw,' izn=',izn !ipric       write (*,*) xnrnew,xnr1 !ipric       write (*,*) xnr2,xnr3,xnr4 !ipric       pause !ipric      end if pg1 = abs ( xnro - xnr1 ) pg2 = abs ( xnro - xnr2 ) pg3 = abs ( xnro - xnr3 ) pg4 = abs ( xnro - xnr4 ) end subroutine disp2_iroot2 ( pa , yn2 , ptet , prt , prm ) ! case iroot == 2 use constants , only : zero , one , two use rt_parameters , only : iw use metrics use dielectric_tensor use dispersion_equation use decrements , only : dhdnr !!!!! implicit none real ( wp ), intent ( in ) :: pa ! ro real ( wp ), intent ( in ) :: yn2 ! ??? real ( wp ), intent ( in ) :: ptet ! theta !real(wp), intent(out) :: xnro ! ??? real ( wp ), intent ( out ) :: prt ! ??? real ( wp ), intent ( out ) :: prm ! ??? integer :: jr real ( wp ) :: dl1 , ynpopq1 , al , bl , cl , cl1 , dll real ( wp ) :: dl2 , xnr , ynyt , dnym real ( wp ) :: dnx , dll1 , e1t !print *, 'disp2 ivar=', ivar iconv = 0 irefl = 0 if ( pa . ge . one . or . pa . le . zero ) then irefl = 1 pause return endif icall1 = icall1 + 1 call calculate_metrics ( pa , ptet ) call calculate_dielectric_tensor ( pa ) call calculate_dispersion_equation ( yn2 , yn3 ) if ( dls . lt . zero ) then prt = dls prm = 666 d0 return end if dl1 = dfloat ( iw ) * dsqrt ( dls ) / two / as if ( iw . eq . - 1 ) ynpopq =- bs / ( two * as ) + dl1 if ( iw . eq . 1 ) ynpopq = two * cs / ( - bs - two * as * dl1 ) !cc      write(*,*)'iw=',iw,' izn=',izn,' Nperp=',dsqrt(ynpopq) !cc      write(*,*)'Nperp2=',ynpopq,' ynpopq1=',-bs/(two*as)-dl1 !cc      pause al = g22 / xj bl =- yn2 * g12 / xj cl = g11 * yn2 ** 2 / xj + yn3 ** 2 / g33 - ynzq - ynpopq dll = bl * bl - al * cl prt = dls prm = dll if ( dll . ge . zero ) then !эта ветка нужна для определения znakstart !!old variant: !cc        dl2=-dfloat(izn)*dsqrt(dll)/al !cc        if(izn.eq.1) xnr=-bl/al+dl2 !cc        if(izn.eq.-1) xnr=cl/(-bl-al*dl2) !cc        xnro=xnr !cc       end if !cc       return !cc      end if !!!!!!!!!!!!!! !!new variant: izn = 1 dl2 =- dsqrt ( dll ) / al xnr =- bl / al + dl2 znakstart = dhdomega ( pa , ptet , xnr , yn2 ) !cc        write(*,*)'#1: izn=',izn,' dl2=',dl2,' xnr=',xnr !cc        write(*,*)'znak=',znakstart,' -znak*dhdnr=',-znakstart*dhdnr if ( - znakstart * dhdnr . gt . zero ) then izn =- 1 dl2 = dsqrt ( dll ) / al xnr = cl / ( - bl - al * dl2 ) znakstart = dhdomega ( pa , ptet , xnr , yn2 ) !cc         write(*,*)'#2: izn=',izn,' dl2=',dl2,' xnr=',xnr !cc         write(*,*)'znak=',znakstart,' -znak*dhdnr=',-znakstart*dhdnr if ( - znakstart * dhdnr . gt . zero ) then write ( * , * ) 'Exception: both modes go outward !!' stop end if end if !xnro=xnr end if end subroutine subroutine disp4 ( in_pa , ptet , xnr , yn2 ) use constants , only : zero , one , two , c0 , c1 , pi , zalfa , xlog , xmalfa use approximation use plasma , only : fn1 , fn2 , fvt , zefff , ft use plasma , only : cdl , cly , cgm , cmy , ncoef use plasma , only : r0 , rm , b_tor , ww , xmi , xsz use plasma , only : cltn , cnye , cnyi , cnstal use rt_parameters , only : inew , itend0 use metrics use dispersion_equation , only : ynz use decrements , only : dhdnr !!!!! use source_new_mod , only : source_new implicit none real ( wp ), intent ( in ) :: in_pa ! ro real ( wp ), intent ( in ) :: yn2 ! ??? real ( wp ), intent ( in ) :: ptet ! theta real ( wp ), intent ( inout ) :: xnr ! ??? real ( wp ) :: pa , pn real ( wp ) :: fnr , fnrr real ( wp ) :: wpq real ( wp ) :: xdl , xdlp , xdlpp real ( wp ) :: xly , xlyp , xlypp , xlyv real ( wp ) :: xgm , xgmp , xgmpp real ( wp ) :: xmy , xmyp real ( wp ) :: dxrt real ( wp ) :: dxdrdr , dxdtdr real ( wp ) :: dzdrdr , dzdtdr real ( wp ) :: dvdr , du1dr , dudr , du1dt , dudt real ( wp ) :: cotet , sitet real ( wp ) :: x0r , xjr !real(wp) :: dxdt, dzdrdt real ( wp ) :: g2gq , g22q , g33q real ( wp ) :: bpr , btr real ( wp ) :: bar real ( wp ) :: sit , cot , sir , cor real ( wp ) :: v , vt , vpop , vpopr , vpopt , u , u1 real ( wp ) :: sl1 , pnye , pnyi , tmp real ( wp ) :: fcoll , dek1 , dek2 real ( wp ) :: e1 , e2 , e3 real ( wp ) :: e1t , e1r , e2t , e2r , e3r real ( wp ) :: ynzr , ynzt , ynzqr , ynzqt , ynpopqr , ynpopqt real ( wp ) :: whe , wde3dw , wdbsdw , wdcsdw , wdhdw real ( wp ) :: yny , ynzq , ynyr , ynyt real ( wp ) :: gpr , dgpr , gdop , gprr , gdopr , gdopt real ( wp ) :: as , bs , cs real ( wp ) :: asr , bsr , csr , ast , bst , cst real ( wp ) :: dhdv , dhdu real ( wp ) :: dnx , dny , dnz , ddn2 real ( wp ) :: gr , gt , g11r , g22r , g12r real ( wp ) :: g22qr , g22qt , g33qr , g33qt real ( wp ) :: g2jqr real ( wp ) :: g33r real ( wp ) :: g2gqt , g2gqr real ( wp ) :: source real ( wp ) :: aimh !common /bcef/ ynz,ynpopq !common /aef2/ icall1,icall2 !integer :: irefl, iconv !common /cefn/ iconv,irefl !common /df/ pdec14,pdec24,pdec34,idec !common/metrika/g11,g12,g22,g33,gg,g,si,co !common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u !common/fjham/ham pa = in_pa irefl = 0 iconv = 0 if ( pa . eq . zero ) pa = 1.d-7 ! TODO не хорошо, что изменяется pa if ( pa . lt . zero ) pa = dabs ( pa ) !sav2008      if(pa.gt.one) then !sav2008       dhdm=666d0 !sav2008       dhdtet=-666d0 !sav2008       dhdnr=666d0 !sav2008       dhdr=-666d0 !sav2008       irefl=1 !sav2008       return !sav2008      end if icall2 = icall2 + 1 !!      pn=fn1(pa,fnr) !!      pn=fn2(pa,fnr,fnrr) if ( inew . eq . 0 ) then !vardens pn = fn1 ( pa , fnr ) else pn = fn2 ( pa , fnr , fnrr ) end if !cc        hstp=1.d-7 !cc        pplus=fn2(pa+hstp,fnr2,fnrr2) !cc        pminus=fn2(pa-hstp,fnr1,fnrr1) !cc        fnr=0.5d0*(pplus-pminus)/hstp !cc        fnrr=0.5d0*(fnr2-fnr1)/hstp !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! wpq = c0 ** 2 * pn xdl = fdfddf ( pa , cdl , ncoef , xdlp , xdlpp ) xly = fdfddf ( pa , cly , ncoef , xlyp , xlypp ) xgm = fdfddf ( pa , cgm , ncoef , xgmp , xgmpp ) xmy = fdf ( pa , cmy , ncoef , xmyp ) cotet = dcos ( ptet ) sitet = dsin ( ptet ) xlyv = xly + xlyp * pa !-------------------------------------- ! components of metric tensor !-------------------------------------- dxdr =- xdlp + cotet - xgmp * sitet ** 2 dxdt =- ( pa + two * xgm * cotet ) * sitet dzdr = xlyv * sitet dzdt = xly * pa * cotet x0 = r0 / rm - xdl + pa * cotet - xgm * sitet ** 2 dxdrdr =- xdlpp - xgmpp * sitet ** 2 dxdtdt =- cotet * ( pa + two * xgm * cotet ) + sitet ** 2 * two * xgm dxdtdr =- sitet * ( one + two * xgmp * cotet ) dxdrdt = dxdtdr dzdrdr = ( two * xlyp + pa * xlypp ) * sitet dzdtdt =- xly * pa * sitet dzdtdr = xlyv * cotet dzdrdt = dzdtdr x0t = dxdt x0r = dxdr g11 = dxdr ** 2 + dzdr ** 2 g22 = dxdt ** 2 + dzdt ** 2 g12 = dxdr * dxdt + dzdr * dzdt g33 = x0 ** 2 xj = ( dzdr * dxdt - dxdr * dzdt ) ** 2 !gg=g11*g22-g12*g12 gg = xj g = xj * g33 g2jq = dsqrt ( g22 / xj ) g2gq = dsqrt ( g22 / g ) g22q = dsqrt ( g22 ) g33q = dsqrt ( g33 ) !c-------------------------------------- !c  magnetic field !c-------------------------------------- bt = b_tor * ( r0 / rm ) / x0 bp = g2gq * xmy ! dsqrt(g22/(xj*g33)) b = dsqrt ( bp * bp + bt * bt ) whe = b * c1 si = bp / b co = bt / b !c--------------------------------------- !c components of dielectric tensor !c--------------------------------------- v = wpq / ww ** 2 u1 = whe / ww u = u1 ** 2 e1 = one - v * ( one / xmi - one / u ) e2 = v / u1 e3 = one - v !c------------------------------------- !c dispersion equation !c-------------------------------------- ynz = yn2 * si / g22q + yn3 * co / g33q ynzq = ynz ** 2 vpop = xnr ** 2 * g22 - two * xnr * yn2 * g12 + g11 * yn2 ** 2 ynpopq = vpop / xj + yn3 ** 2 / g33 - ynzq as = e1 bs =- ( e1 ** 2 - e2 ** 2 + e1 * e3 - ( e1 + e3 ) * ynzq ) cs = e3 * ( e1 ** 2 - e2 ** 2 - two * e1 * ynzq + ynzq ** 2 ) !c---------------------------------------------------- !sav2009 dhdv = ( 1.d0 / ( u ** 2 * xmi ** 2 )) * (( 2.d0 - 2.d0 * ynpopq - 3.d0 * v ) * v * xmi ** 2 - & u ** 2 * ( 3.d0 * v ** 2 + 2.d0 * v * ( - 1.d0 + ynpopq * ( 1.d0 + xmi )& + 2.d0 * xmi * ( - 1.d0 + ynzq )) + & xmi * ( - 2.d0 + ynpopq + xmi * ( - 1.d0 + ynzq )) * ( - 1.d0 + ynpopq + ynzq ))& + u * xmi * ( 3.d0 * v ** 2 * ( 2.d0 + xmi )& + ( - 2.d0 + ynpopq ) * xmi * ( - 1.d0 + ynpopq + ynzq )& + v * ( - 4.d0 + 4.d0 * ynpopq * ( 1.d0 + xmi ) + xmi * ( - 6.d0 + 4.d0 * ynzq )))) dhdu =- ( 1.d0 / ( u ** 3 * xmi )) * ( v * ( - 1.d0 + ynpopq + v ) * ( 2.d0 * u * v - 2.d0 * v * xmi & + u * ( - 2.d0 + ynpopq + v ) * xmi ) + u * v * ( - 2.d0 + ynpopq + 2.d0 * v ) * xmi * ynzq ) dhdv2v = 2.d0 * v * dhdv !w*d(-H)/dv dhdu2u = 2.d0 * u * dhdu !w*d(-H)/du !c---------------------------------------------------- !est !sav2009 if ( inew . gt . 0 ) then if ( inew . eq . 1 ) then yny = - ( yn2 * co / g22q - yn3 * si / g33q ) else if ( inew . eq . 2 ) then yny = - g2jq * ( yn2 * co / g22q - yn3 * si / g33q ) end if gpr = c0 ** 2 / ww ** 2 / u1 * fnr * xsz gdop = yny * gpr bs = bs + gdop cs = cs + gdop * ( ynzq - e3 ) !sav2009: dgpr =- gpr !w*d(gpr)/dw wde3dw = 2.d0 * v !w*d(e3)/dw wdbsdw = yny * dgpr !w*d(bs)/dw wdcsdw = ( ynzq - e3 ) * wdbsdw - gdop * wde3dw !w*d(cs)/dw wdhdw = wdbsdw * ynpopq + wdcsdw !w*d(H1)/dw dhdv2v = dhdv2v - wdhdw !correction to dhdv2v: w*d(-H)/dv+w*d(-H1)/dw end if ham = as * ynpopq ** 2 + bs * ynpopq + cs !sav2009 !-------------------------------------------------------- !!      dl=bs**2-4d0*as*bs !c-------------------------------------- !c   calculation of derivatives !c-------------------------------------- g11r = two * dxdr * dxdrdr + two * dzdr * dzdrdr g22r = two * dxdt * dxdtdr + two * dzdt * dzdtdr g11t = two * dxdr * dxdrdt + two * dzdr * dzdrdt g22t = two * dxdt * dxdtdt + two * dzdt * dzdtdt g12r = dxdrdr * dxdt + dxdr * dxdtdr + dzdrdr * dzdt + dzdr * dzdtdr g12t = dxdrdt * dxdt + dxdr * dxdtdt + dzdrdt * dzdt + dzdr * dzdtdt g33r = two * x0 * x0r g33t = two * x0 * x0t g22qr = g22r / ( g22q * two ) g22qt = g22t / ( g22q * two ) g33qr = g33r / ( g33q * two ) g33qt = g33t / ( g33q * two ) xjr = g11r * g22 + g22r * g11 - two * g12 * g12r xjt = g11t * g22 + g22t * g11 - two * g12 * g12t g2jqr = ( g22r / xj - g22 / xj ** 2 * xjr ) / ( g2jq * two ) !sav2009 g2jqt = ( g22t / xj - g22 / xj ** 2 * xjt ) / ( g2jq * two ) !sav2009 gr = xjr * g33 + g33r * xj gt = xjt * g33 + g33t * xj g2gqt = ( g22t / g - g22 / g ** 2 * gt ) / ( g2gq * two ) g2gqr = ( g22r / g - g22 / g ** 2 * gr ) / ( g2gq * two ) bpt = xmy * g2gqt bpr = g2gqr * xmy + g2gq * xmyp btr =- b_tor * ( r0 / rm ) / x0 ** 2 * x0r btt =- b_tor * ( r0 / rm ) / x0 ** 2 * x0t bat = one / b * ( bp * bpt + bt * btt ) bar = one / b * ( bp * bpr + bt * btr ) sit = bpt / b - bp / b ** 2 * bat cot = btt / b - bt / b ** 2 * bat sir = bpr / b - bp / b ** 2 * bar cor = btr / b - bt / b ** 2 * bar dvdr = fnr * c0 ** 2 / ww ** 2 du1dr = c1 * bar / ww dudr = two * u1 * du1dr du1dt = c1 * bat / ww dudt = two * u1 * du1dt e1r =- dvdr * ( one / xmi - one / u ) - v * dudr / u ** 2 e1t =- v * dudt / u ** 2 e2r = dvdr / u1 - v / u1 ** 2 * du1dr e2t =- v / u1 ** 2 * du1dt e3r =- dvdr ynzr = yn2 * ( sir / g22q - si / g22q ** 2 * g22qr ) + yn3 * ( cor / g33q - co / g33q ** 2 * g33qr ) ynzt = yn2 * ( sit / g22q - si / g22q ** 2 * g22qt ) + yn3 * ( cot / g33q - co / g33q ** 2 * g33qt ) ynzqr = two * ynz * ynzr ynzqt = two * ynz * ynzt vpopr = ( xnr ** 2 * g22r - two * xnr * yn2 * g12r + yn2 ** 2 * g11r ) vpopt = ( xnr ** 2 * g22t - two * xnr * yn2 * g12t + yn2 ** 2 * g11t ) ynpopqr = vpopr / xj - vpop / xj ** 2 * xjr - yn3 ** 2 / g33 ** 2 * g33r - ynzqr ynpopqt = vpopt / xj - vpop / xj ** 2 * xjt - yn3 ** 2 / g33 ** 2 * g33t - ynzqt asr = e1r bsr = ( e3r + e1r ) * ( ynzq - e1 ) + ( e3 + e1 ) * ( ynzqr - e1r ) + two * e2 * e2r csr = e3r * (( ynzq - e1 ) ** 2 - e2 ** 2 ) + e3 * ( two * ( ynzq - e1 ) * ( ynzqr - e1r ) - two * e2 * e2r ) ast = e1t bst = e1t * ( ynzq - e1 ) + ( e3 + e1 ) * ( ynzqt - e1t ) + two * e2 * e2t cst = e3 * ( two * ( ynzq - e1 ) * ( ynzqt - e1t ) - two * e2 * e2t ) !--------------------------------------------------- !est !sav2009 if ( inew . gt . 0 ) then if ( inew . eq . 1 ) then ynyr = - ( yn2 * ( cor / g22q - co / g22q ** 2 * g22qr )& - yn3 * ( sir / g33q - si / g33q ** 2 * g33qr )) ynyt = - ( yn2 * ( cot / g22q - co / g22q ** 2 * g22qt ) - & - yn3 * ( sit / g33q - si / g33q ** 2 * g33qt )) else if ( inew . eq . 2 ) then ynyr = - g2jq * ( yn2 * ( cor / g22q - co / g22q ** 2 * g22qr )& - yn3 * ( sir / g33q - si / g33q ** 2 * g33qr )) ynyr = ynyr - g2jqr * ( yn2 * co / g22q - yn3 * si / g33q ) ynyt = - g2jq * ( yn2 * ( cot / g22q - co / g22q ** 2 * g22qt ) - & - yn3 * ( sit / g33q - si / g33q ** 2 * g33qt )) ynyt = ynyt - g2jqt * ( yn2 * co / g22q - yn3 * si / g33q ) end if gprr = c0 ** 2 / ww ** 2 * ( fnrr / u1 - fnr / u1 ** 2 * du1dr ) * xsz gprt =- c0 ** 2 / ww ** 2 * fnr / u1 ** 2 * du1dt * xsz gdopr = ynyr * gpr + yny * gprr gdopt = ynyt * gpr + yny * gprt bsr = bsr + gdopr csr = csr + gdopr * ( ynzq - e3 ) + gdop * ( ynzqr - e3r ) bst = bst + gdopt cst = cst + gdopt * ( ynzq - e3 ) + gdop * ynzqt end if !c--------------------------------------------------- dhdr = asr * ynpopq ** 2 + bsr * ynpopq + & as * two * ynpopq * ynpopqr + bs * ynpopqr + csr dhdtet = ast * ynpopq ** 2 + bst * ynpopq + & as * two * ynpopq * ynpopqt + bs * ynpopqt + cst dnx = two * as * ynpopq + bs dnz = ynpopq * ( e1 + e3 ) + two * ( ynzq - e1 ) * e3 dhdnr = dnx * two * ( g22 * xnr - g12 * yn2 ) / xj dhdm = dnx * two * ( yn2 * g11 - xnr * g12 ) / xj + ( dnz - dnx ) * two * ynz * si / g22q !sav2009 dhdn3 = two * (( yn3 - ynz * co * g33q ) * dnx + ynz * co * g33q * dnz ) / g33 !sav2009 !c---------------------------------------------------------------- !est !sav2009 if ( inew . gt . 0 ) then if ( inew . eq . 1 ) then dny = - gpr * ( ynpopq + ynzq - e3 ) else if ( inew . eq . 2 ) then dny = - g2jq * gpr * ( ynpopq + ynzq - e3 ) end if dhdm = dhdm + dny * co / g22q + two * ynz * yny * gpr * si / g22q dhdn3 = dhdn3 - dny * si / g33q + two * ynz * yny * gpr * co / g33q !sav2009 end if !c--------------------------------------------------- !sav2009 ddn2 = g11 * dhdnr ** 2 + g22 * dhdm ** 2 + 2.d0 * g12 * dhdnr * dhdm + g33 * dhdn3 ** 2 ddn = dsqrt ( ddn2 ) ! if ( idec . ne . 0 ) then vt = fvt ( pa ) sl1 = ( ynzq - e1 ) * ( ynzq + ynpopq - e1 ) - e2 ** 2 aimh = wpq / ww ** 2 * pi * sl1 * cltn ** 2 / ynzq pdec14 = dabs ( aimh / xsz / ddn ) pnye = cnye * wpq ** 2 / ( pn * vt ** 3 ) pnyi = cnyi * pnye * zefff ( pa ) pdec24 = dabs ( pnyi / ww * ( wpq / whe ** 2 * ynpopq + wpq / ww ** 2 * ynzq ) * ynpopq / & xsz / ddn ) if ( itend0 . gt . 0 ) then tmp = ft ( pa ) / 0.16d-8 fcoll = . 5 d - 13 * pn * zalfa ** 2 * xlog / xmalfa / tmp ** 1.5d0 !cc        ddens=dn1*pn !cc        tdens=dn2*pn !cc        tt=fti(pa)**0.33333d0    ! (ti, kev)&#94;1/3 !cc        source=4d-12*factor*ddens*tdens*dexp(-20d0/tt)/tt**2 call source_new ( pa , source ) dek1 = cnstal * pdec14 * ( 1.d0 - e3 / ynpopq ) ** 2 / dsqrt ( ynpopq ) dek2 = source / ( fcoll * pn ) pdec34 = dek1 * dek2 end if end if end function dhdomega ( rho , theta , yn1 , yn2 ) result ( znak ) !! вычисляет znakstart use decrements , only : dhdnr !!!!! implicit none real ( wp ), intent ( in ) :: rho real ( wp ), intent ( in ) :: theta real ( wp ), intent ( inout ) :: yn1 real ( wp ), intent ( in ) :: yn2 real ( wp ) :: wdhdw , znak !common /a0ef2/ ww !common /abefo/ yn3 !common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u !common/direct/znakstart !parameter(zero=0.d0,h=1.d-6) call disp4 ( rho , theta , yn1 , yn2 ) !!w*dH/dw=wdhdw: wdhdw =- ( yn1 * dhdnr + yn2 * dhdm + yn3 * dhdn3 + dhdv2v + dhdu2u ) znak = dsign ( 1.d0 , wdhdw ) !znakstart=znak !c      write(*,*)'formula: znak=',znak !c      write(*,*)'wdhdw=',wdhdw,' H=',ham !c      write(*,*)'rho=',rho,' teta=',theta !c      write(*,*)'yn1=',yn1,' yn2=',yn2 !c      write(*,*)'dhdnr=',dhdnr,' dhdm=',dhdm !c      write(*,*)'dhdr=',dhdr,' dhdtet=',dhdtet !c      write(*,*)'dhdn3=',dhdn3,' yn3=',yn3 !c      write(*,*)'yn1*dhdnr=',yn1*dhdnr,' yn2*dhdm=',yn2*dhdm !c      write(*,*)'yn1*dhdnr+yn2*dhdm=',yn1*dhdnr+yn2*dhdm !cc      pause end subroutine extd4 ( x , y , dydx ) !use dispersion_module use decrements , only : dhdnr !!!!! implicit none !implicit real(wp) (a-h,o-z) real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y (:) real ( wp ), intent ( inout ) :: dydx (:) !common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u !common/direct/znakstart real ( wp ) :: znak , xxx , ptet , yn2 , pa , yn1 znak = znakstart xxx = x ptet = y ( 1 ) yn2 = y ( 2 ) pa = y ( 3 ) yn1 = y ( 4 ) call disp4 ( pa , ptet , yn1 , yn2 ) !new variant dydx ( 1 ) =- znak * dhdm / ddn dydx ( 2 ) = znak * dhdtet / ddn dydx ( 3 ) =- znak * dhdnr / ddn dydx ( 4 ) = znak * dhdr / ddn !dydx(5)=-znak*dhdn3/ddn !! возможен выход за границы массива !c      dydx(1)=znak*dhdm/ddn !c      dydx(2)=-znak*dhdtet/ddn !c      dydx(3)=znak*dhdnr/ddn !c      dydx(4)=-znak*dhdr/ddn !c      dydx(5)=znak*dhdn3/ddn !old variant: !      dydx(1)=dhdm/ddn !      dydx(2)=-dhdtet/ddn !      dydx(3)=dhdnr/ddn !      dydx(4)=-dhdr/ddn !      dydx(5)=dhdn3/ddn end end module dispersion_module","tags":"","loc":"sourcefile\\3_dispersion.f90.html"},{"title":"3_FokkerPlanck.f90 – FRTС project","text":"Source Code module FokkerPlanck_module use kind_module implicit none contains !! calculation of distribution functions at time t1=t+dtau !! subroutine fokkerplanck_compute ( time , TAU ) use FokkerPlanck1D_mod use utils use rt_parameters use writer_module use maxwell use plasma , only : fvt , enorm , fst implicit none type ( FokkerPlanck1D ) fokker_planck !type(Timer) my_timer real ( wp ), intent ( in ) :: time , TAU real ( wp ) t , dtstep , dtau !integer nr !common /a0ab/ nr integer , parameter :: ntau = 10 !integer i0 !parameter(i0=1002) !real(wp) vij,fij0,fij,dfij,dij,enorm,fst !common/lh/vij(i0,100),fij0(i0,100,2),fij(i0,100,2),dfij(i0,100,2), dij(i0,100,2),enorm(100),fst(100) integer n , i , j , it , nt , k real ( wp ) xend , h , dt real ( wp ) znak , alfa2 , dt0 , h0 , r !common/ef/ alfa2 !real(wp) d0 !integer jindex,kindex !common/dddql/ d0,jindex,kindex parameter ( dt0 = 0.1d0 , h0 = 0.1d0 ) dtstep = TAU / dble ( ntau ) !seconds print * , 'fokkerplanck_compute' write ( * , * ) 'time=' , time , ' dt=' , dtstep !call my_timer%start do j = 1 , nr jindex = j !common/dddql/ dtau = dtstep * fst ( j ) nt = 1 if ( dtau . gt . dt0 ) then nt = 1 + dtau / dt0 end if dt = dtau / nt r = dble ( j ) / dble ( nr + 1 ) xend = 3.d10 / fvt ( r ) do k = 1 , 2 kindex = k flag_d0 = . TRUE . ! d(x) enable znak = 2.d0 * dble ( k ) - 3.d0 fokker_planck = FokkerPlanck1D ( znak * enorm ( j ), xend , vij (:, j ), fij0 (:, j , k )) call fokker_planck % init_zero_diffusion do i = 1 , ntau call fokker_planck % solve_time_step ( dt , nt ) !call fokkerplanck1D_iter(alfa2, h, n, dt, nt, xend, d1, d2, d3, vij(:,j), fij0(:,j,k), out_fj) end do fij0 (:, j , k ) = fokker_planck % f flag_d0 = . FALSE . ! d(x) disable fokker_planck = FokkerPlanck1D ( znak * enorm ( j ), xend , vij (:, j ), fij (:, j , k )) call fokker_planck % init_diffusion ( dij (:, j , k )) do i = 1 , ntau call fokker_planck % solve_time_step ( dt , nt ) !call fokkerplanck1D_iter(alfa2, h, n, dt, nt, xend, d1, d2, d3, vij(:,j), fij(:,j,k),out_fj, dfij(:,j,k)) end do fij (:, j , k ) = fokker_planck % f end do call write_distribution ( fij0 (:, j , 2 ), i0 , time ) !call write_distribution(out_fj, n, time) end do write ( * , * ) 'fokkerplanck nr= ' , nr , ' ntau =' , ntau , 'nt =' , nt call binary_write_array ( vij , fij0 (:, 1 : nr ,:), time , 'maxwell_fij0' ) call write_v_array ( vij , fij0 (:, 1 : nr ,:), time , 'maxwell' ) call write_v_array ( vij , dij (:, 1 : nr ,:), time , 'diffusion' ) !call write_matrix(dij(1:i0,1:nr,1), time, 'diffusion') !time2 = sys_time() - time1 !call my_timer%stop !print *, 'fokkerplanck elapsed_time: ', my_timer%elapsed_time ! print *, 'fokkerplanck_new eval time: ', time2 !pause end subroutine init_diffusion ( h , n , vj , dj , d1 , d2 , d3 ) ! инициализация диффузии для схемы савельева use lock_module implicit none integer , intent ( in ) :: n real ( wp ), intent ( in ) :: h real ( wp ), dimension (:), intent ( in ) :: vj , dj real ( wp ), dimension (:), intent ( out ) :: d1 , d2 , d3 real ( wp ), dimension (:), allocatable :: xx integer :: i0 integer i , klo , khi , ierr , klo1 , khi1 integer klo2 , klo3 , khi2 , khi3 , ierr1 , ierr2 , ierr3 i0 = size ( vj ) allocate ( xx ( n + 1 )) do i = 1 , n + 1 xx ( i ) = h / 2.d0 + h * dble ( i - 1 ) !+shift end do do i = 1 , n + 1 call lock ( vj , i0 , xx ( i ), klo1 , khi1 , ierr1 ) call lock ( vj , i0 , xx ( i ) - h / 2 d0 , klo2 , khi2 , ierr2 ) call lock ( vj , i0 , xx ( i ) + h / 2 d0 , klo3 , khi3 , ierr3 ) if ( ierr1 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo1=' , klo1 , 'khi1=' , khi1 , 'i=' , i write ( * , * ) 'vj(1)=' , vj ( 1 ), ' vj(i0)=' , vj ( i0 ) pause stop end if if ( ierr2 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo2=' , klo2 , 'khi2=' , khi2 , 'i=' , i write ( * , * ) 'vj(1)=' , vj ( 1 ), ' vj(i0)=' , vj ( i0 ) pause stop end if if ( ierr3 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo3=' , klo3 , 'khi3=' , khi3 , 'i=' , i write ( * , * ) 'vj(1)=' , vj ( 1 ), ' vj(i0)=' , vj ( i0 ) pause stop end if d1 ( i ) = dj ( klo1 ) d2 ( i ) = dj ( klo2 ) d3 ( i ) = dj ( klo3 ) end do end subroutine end module FokkerPlanck_module","tags":"","loc":"sourcefile\\3_fokkerplanck.f90.html"},{"title":"2_plasma.f90 – FRTС project","text":"Source Code module plasma !! модуль параметров плазмы use kind_module implicit none integer ngrid , nspl !! ASTRA radial grid number real ( wp ) tcur !! время (придумать название для переменной получше) real ( wp ) rm !! minor radius in mid-plane, cm real ( wp ) b_tor0 !! тороидальное магнитное поле !! временно нужно две переменных, тоже нужно исправить real ( wp ) b_tor !! тороидальное магнитное поле real ( wp ) r0 real ( wp ) z0 real ( wp ) rh1 real ( wp ), dimension (:), allocatable :: con , tem , temi , zeff , afld real ( wp ), dimension (:), allocatable :: rh , rha , drhodr , delta , ell , gamm , amy real ( wp ) tet1 , tet2 !!common /a0a2/ real ( wp ) xmi , cnye , cnyi , xsz , vt0 !!/a0ef3/ xmi,cnye,cnyi,xsz,vt0 real ( wp ) cnstvc real ( wp ) ww !!common /a0ef2/ ww real ( wp ) cltn !!common /a0ef1/ cltn real ( wp ) vperp ( 50 , 100 ), cnstal , zza , zze , valfa !,kv !common /a0i5/ vperp(50,100),cnstal,zza,zze,valfa!,kv real ( wp ) vpmax real ( wp ) vk ( 100 ), sk ( 100 ) !common /a0i2/ vk(100) integer , parameter :: ipsy = 5 , ncoef = 5 !!   ipsy = number of polinomial decomposition coefficients !!   used for interpolation of Zakharov's moments. real ( wp ), dimension ( ipsy ) :: cdl , cly , cgm , cmy , coeffs real ( wp ) y2dn ( 501 ), y2tm ( 501 ), y2tmi ( 501 ) !!common /a0l3/ real ( wp ) y2zeff ( 501 ) !!common /a0l5/ integer ncheb real ( wp ) chebne ( 50 ), chebdne ( 50 ), chebddne ( 50 ) !!common/ne_cheb real ( wp ) enorm ( 100 ), fst ( 100 ) !! em поле и еще что-то contains subroutine init_plasma ( NA1 , ABC , BTOR , RTOR , UPDWN , GP2 , AMETR , RHO , SHIF , ELON , TRIA , MU , NE , TE , TI , ZEF , UPL ) use constants use approximation use rt_parameters use spline_module use chebyshev use math_module implicit none integer , intent ( in ) :: NA1 real ( wp ), intent ( in ) :: ABC , BTOR , RTOR , UPDWN , GP2 real ( wp ), dimension ( * ) :: AMETR , RHO , SHIF , ELON , TRIA , MU , NE , TE , TI , ZEF , UPL integer i , k integer , parameter :: N = 501 real ( wp ) :: znak_tor , znak_pol , fpol , dfmy ngrid = NA1 nspl = ngrid if (. not . allocated ( rh )) then allocate ( rh ( N ), rha ( N ), drhodr ( N ), con ( N ), tem ( N ), source = 0.0_wp ) allocate ( temi ( N ), zeff ( N ), afld ( N ), source = 0.0_wp ) allocate ( delta ( N ), ell ( N ), gamm ( N ), amy ( N ), source = 0.0_wp ) end if do i = 1 , ngrid rh ( i ) = AMETR ( i ) / ABC rha ( i ) = RHO ( i ) / ABC !/ABC instead of /ROC is not a mistake! delta ( i ) = ( SHIF ( 1 ) - SHIF ( i )) / ABC !FRTC Shafr. shift. defin. ell ( i ) = ELON ( i ) gamm ( i ) = rh ( i ) * TRIA ( i ) con ( i ) = NE ( i ) tem ( i ) = TE ( i ) temi ( i ) = TI ( i ) zeff ( i ) = ZEF ( i ) afld ( i ) = UPL ( i ) / RTOR / GP2 !!variant end do rh ( ngrid ) = 1.d0 rh1 = rh ( 1 ) !saving the first ASTRA radial grid element rh ( 1 ) = 0.0d0 !shifting the first element to zero rha ( 1 ) = 0.0d0 !shifting the first element to zero delta ( 1 ) = 0.0d0 !putting delta(rh=0.)=0. gamm ( 1 ) = 0.0d0 !putting gamm(rh=0.)=0. b_tor0 = 1.d4 * BTOR * RTOR / ( RTOR + SHIF ( 1 )) !B_tor_(magnetic axis), Gauss rm = 1.d2 * ABC !minor radius in mid-plane, cm r0 = 1.d2 * ( RTOR + SHIF ( 1 )) !x-coordinate of the magnetic axis, cm z0 = 1.d2 * UPDWN !z-coordinate of the magnetic axis, cm !   spline approximation of plasma profiles ! !   shift as a function of \"minor radius\": call approx ( rh , delta , ngrid , polin1 , ipsy - 1 , coeffs ) cdl ( 1 ) = 0.0d0 do k = 2 , ipsy cdl ( k ) = coeffs ( k - 1 ) end do !   triangularity as a function of \"minor radius\": call approx ( rh , gamm , ngrid , polin1 , ipsy - 1 , coeffs ) cgm ( 1 ) = 0.0d0 do k = 2 , ipsy cgm ( k ) = coeffs ( k - 1 ) end do !   ellipticity as a function of \"minor radius\": call approx ( rh , ell , ngrid , polin , ipsy , cly ) !  \"poloidal magnetic field\": call diff ( rh , rha , ngrid , drhodr ) do i = 2 , ngrid amy ( i ) = 1.d4 * BTOR * MU ( i ) * rha ( i ) * drhodr ( i ) !print *, amy(i), BTOR, MU(i) end do !print *, '----------------' amy ( 1 ) = 0.d0 !! amy=(btor/q)*rho*(drho/dr) is a function of \"minor radius\" r=rh(i). !! Poloidal magnetic field: B_pol=amy(r)*sqrt(g22/g), where g is !! determinant of 3D metric tensor and g22 is the (22) element of !! the tensor, normalized on ABC&#94;4 and ABC&#94;2, correspondingly. !! !!  Polinomial approximation of the amy(r): !    inpt2=ngrid-3 call approx ( rh , amy , ngrid - 3 , polin1 , ipsy - 1 , coeffs ) cmy ( 1 ) = 0.d0 do k = 2 , ipsy cmy ( k ) = coeffs ( k - 1 ) end do ! зачем-то меняет знак коэффициентов???? znak_tor = dsign ( 1.d0 , dble ( itor )) b_tor = znak_tor * dabs ( b_tor0 ) fpol = fdf ( 1.d0 , cmy , ncoef , dfmy ) znak_pol = dsign ( 1.d0 , dble ( i_pol )) * dsign ( 1.d0 , fpol ) do i = 1 , ncoef cmy ( i ) = znak_pol * cmy ( i ) end do !!!!!!!!!!!!!!! spline approximation of plasma profiles !!!!!!!!!!!!!!!! call splne ( rh , con , nspl , y2dn ) call splne ( rh , tem , nspl , y2tm ) call splne ( rh , zeff , nspl , y2zeff ) call splne ( rh , temi , nspl , y2tmi ) if ( inew . ne . 0 ) then ncheb = 20 call chebft1 ( zero , 1.d0 , chebne , ncheb , fn ) call chder ( zero , 1.d0 , chebne , chebdne , ncheb ) call chder ( zero , 1.d0 , chebdne , chebddne , ncheb ) end if call init_parameters call find_volums_and_surfaces end subroutine subroutine init_parameters use constants use approximation use rt_parameters implicit none real ( wp ) :: xly , xlyp , arg1 , arg2 real ( wp ) :: hr , dn1 , dn2 , dn3 , sss !!! xly = fdf ( one , cly , ncoef , xlyp ) arg1 = ( zplus - z0 ) / ( xly * rm ) arg2 = ( zminus - z0 ) / ( xly * rm ) if ( dabs ( arg1 ). lt . 1.d0 ) then tet1 = dasin ( arg1 ) ! upper grill corner poloidal coordinate else tet1 = 0.5d0 * pi ! upper grill corner poloidal coordinate end if if ( dabs ( arg2 ). lt . 1.d0 ) then tet2 = dasin ( arg2 ) ! lower grill corner poloidal coordinate else tet2 =- 0.5d0 * pi ! lower grill corner poloidal coordinate end if !------------------------------------------------------------ ! calculate constants !--------------------------------------- hr = 1.d0 / dble ( nr + 1 ) dn1 = 1 d0 / ( zi1 + dni2 * zi2 + dni3 * zi3 ) dn2 = dni2 * dn1 dn3 = dni3 * dn1 sss = zi1 ** 2 * dn1 / xmi1 + zi2 ** 2 * dn2 / xmi2 + zi3 ** 2 * dn3 / xmi3 xmi = 183 6.d0 / sss cnstvc = (. 75 d0 * piq * sss / 183 6.d0 ) ** one_third ww = freq * pi2 * 1.0d+09 cnye = xlog / pi4 cnyi = dsqrt ( 2 d0 ) / ( 3 d0 * piq ) !%for Vt=sqrt(Te/m) vt0 = fvt ( zero ) !!!!!!!!      ptkev=ft(zero)/0.16d-8  !Te in keV cltn = clt / vt0 xsz = clt / ww / rm !ccur=pqe*vt0*0.333d-9 !!      ccurnr=pqe*pqe*0.333d-9/pme rrange = rrange * hr !ToDo если вызывается несколько раз то будут проблемы valfa = 1.d9 * dsqrt ( 1.91582d0 * talfa / xmalfa ) !  valfa (cgs units) = birth velocity zza = cnst1 * ( zalfa / xmalfa / valfa ) ** 2 * ( clt / valfa ) ** 3 / pi zze = cnst2 * 2.d9 * freq cnstal = ( dsqrt ( cnst1 ) / xmalfa / pi ) * ( zalfa * vt0 / valfa ) ** 2 * clt / valfa vpmax = dsqrt ( energy / talfa ) !  \"vpmax\" in valfa velocity units ! end subroutine subroutine write_plasma ( time_stamp ) real ( wp ), intent ( in ) :: time_stamp character ( 120 ) fname integer , parameter :: iu = 20 integer i write ( fname , '(\"lhcd/plasma/\", f9.7,\".dat\")' ) time_stamp print * , fname open ( iu , file = fname , status = 'new' ) write ( iu , '(A)' ), '#vars' write ( iu , '(14A23)' ) 'b_tor0' , 'rm' , 'r0' , 'z0' write ( iu , ' (14(ES23.14))' ) b_tor0 , rm , r0 , z0 write ( iu , * ) write ( iu , '(A)' ), '#approx' write ( iu , '(14A23)' ) 'cdl' , 'cly' , 'cgm' , 'cmy' do i = 1 , ncoef write ( iu , ' (14(ES23.14))' ) cdl ( i ), cly ( i ), cgm ( i ), cmy ( i ) end do write ( iu , * ) write ( iu , '(A)' ), '#radial_data' write ( iu , '(14A23)' ) 'rh' , 'rha' , 'delta' , 'ell' , 'gamm' , 'con' , 'tem' , 'temi' , 'zeff' , 'afld' do i = 1 , ngrid write ( iu , ' (14(ES23.14))' ) rh ( i ), rha ( i ), delta ( i ), ell ( i ), gamm ( i ), con ( i ), tem ( i ), temi ( i ), zeff ( i ), afld ( i ) end do close ( iu ) end subroutine subroutine write_lcms !! write lcms use constants use approximation integer , parameter :: iu = 20 integer :: i real ( wp ) :: xr , th real ( wp ) :: xdl , xdlp , xly , xlyp , xgm , xgmp real ( wp ) :: x , xx , z , zz , pl , pc , pa real ( wp ) :: cotet , sitet open ( iu , file = 'lhcd/out/lcms.dat' ) write ( iu , * ) '     R(m)            Z(m)' write ( iu , * ) xr = 1.d0 xdl = fdf ( xr , cdl , ncoef , xdlp ) xly = fdf ( xr , cly , ncoef , xlyp ) xgm = fdf ( xr , cgm , ncoef , xgmp ) do i = 1 , 101 th = dble ( i - 1 ) * pi2 / dble ( 100 ) cotet = dcos ( th ) sitet = dsin ( th ) xx =- xdl + xr * cotet - xgm * sitet ** 2 zz = xr * xly * sitet x = ( r0 + rm * xx ) / 1 d2 z = ( z0 + rm * zz ) / 1 d2 write ( iu , '(6(e13.6,3x))' ) x , z end do close ( iu ) end subroutine subroutine find_volums_and_surfaces use constants use rt_parameters , only : nr implicit none integer j real ( wp ) hr , rxx , vk0 , sk0 real ( wp ), parameter :: eps = 1.d-6 !-------------------------------------------------------- ! find volums and surfaces !-------------------------------------------------------- hr = 1.d0 / dble ( nr + 1 ) vk0 = pi2 * hr * rm ** 3 sk0 = hr * rm ** 2 do j = 1 , nr rxx = hr * dble ( j ) vk ( j ) = vk0 * gaussint ( obeom , zero , pi2 , rxx , eps ) sk ( j ) = sk0 * gaussint ( ploshad , zero , pi2 , rxx , eps ) end do end subroutine real ( wp ) function fn ( x ) !! plasma  density,  cm&#94;-3 use constants , only : zero use spline_module real ( wp ), intent ( in ) :: x real ( wp ) :: pa , r , y , dy real ( wp ), parameter :: alfa = 4.d0 , dr = . 02 d0 pa = dabs ( x ) if ( pa . le . rh ( nspl )) then call splnt ( rh , con , y2dn , nspl , pa , y , dy ) else r = pa - rh ( nspl ) y = con ( nspl ) * dexp ( - alfa * ( r / dr ) ** 2 ) end if fn = y * 1.d+13 !cm&#94;-3 end real ( wp ) function fvt ( r ) !! нет описания real ( wp ), intent ( in ) :: r real ( wp ) :: pt pt = ft ( r ) fvt = sqrt ( pt / 9.11d-28 ) end real ( wp ) function fn1 ( x , fnp ) !! plasma density and its derivative use constants , only : zero use spline_module real ( wp ), intent ( in ) :: x real ( wp ), intent ( out ) :: fnp real ( wp ) :: r , pa , y1 , y , s , dy , dy1 real ( wp ), parameter :: alfa = 4.d0 , dr = . 02 d0 pa = abs ( x ) if ( pa . le . rh ( nspl )) then call splnt ( rh , con , y2dn , nspl , pa , y , dy ) else call splnt ( rh , con , y2dn , nspl , rh ( nspl ), y1 , dy1 ) r = pa - rh ( nspl ) y = rh ( nspl ) * exp ( - alfa * ( r / dr ) ** 2 ) dy =- 2.d0 * alfa * y * r / dr ** 2 !corrected end if fn1 = y * 1.d+13 !cm&#94;-3 fnp = dy * 1.d+13 end real ( wp ) function fn2 ( r , fnp , fnpp ) !! plasma density and its first and second derivatives use constants , only : zero use chebyshev real ( wp ), intent ( in ) :: r real ( wp ), intent ( out ) :: fnp , fnpp real ( wp ) :: x , y1 , y , s , dy , ddy real ( wp ), parameter :: alfa = 4.d0 , dr = . 02 d0 x = abs ( r ) if ( x . le . 1.d0 ) then y = chebev ( zero , 1.d0 , chebne , ncheb , x ) dy = chebev ( zero , 1.d0 , chebdne , ncheb , x ) ddy = chebev ( zero , 1.d0 , chebddne , ncheb , x ) else y1 = chebev ( zero , 1.d0 , chebne , ncheb , 1.d0 ) s = x - 1.d0 y = y1 * exp ( - alfa * ( s / dr ) ** 2 ) dy =- 2.d0 * alfa * y * s / dr ** 2 ddy =- 2.d0 * alfa * y * ( 1.d0 - 2.d0 * alfa * ( s / dr ) ** 2 ) / dr ** 2 end if fn2 = y !cm&#94;-3 fnp = dy fnpp = ddy end real ( wp ) function ft ( x ) !! electron temperature, erg use constants , only : zero use spline_module real ( wp ), intent ( in ) :: x real ( wp ) :: pa , r , y , dy real ( wp ), parameter :: alfa = 4.d0 , dr = . 02 d0 pa = abs ( x ) !#@sav if ( pa . le . rh ( nspl )) then call splnt ( rh , tem , y2tm , nspl , pa , y , dy ) else r = pa - rh ( nspl ) y = tem ( nspl ) * exp ( - alfa * ( r / dr ) ** 2 ) end if !!      ft=y            ! kev ft = y * 0.16d-8 ! erg end real ( wp ) function fti ( x ) !! ion temperature, kev use constants , only : zero use spline_module real ( wp ), intent ( in ) :: x real ( wp ) :: pa , r , y , dy real ( wp ), parameter :: alfa = 4.d0 , dr = . 02 d0 pa = abs ( x ) !#@sav if ( pa . le . rh ( nspl )) then call splnt ( rh , temi , y2tmi , nspl , pa , y , dy ) else r = pa - rh ( nspl ) y = temi ( nspl ) * exp ( - alfa * ( r / dr ) ** 2 ) end if fti = y ! kev end real ( wp ) function zefff ( x ) !! z_effective profile use constants , only : zero use spline_module real ( wp ), intent ( in ) :: x real ( wp ) :: pa , r , y , dy real ( wp ), parameter :: alfa = 4.d0 , dr = . 02 d0 pa = abs ( x ) !#@sav if ( pa . le . rh ( nspl )) then call splnt ( rh , zeff , y2zeff , nspl , pa , y , dy ) else r = pa - rh ( nspl ) y = zeff ( nspl ) * exp ( - alfa * ( r / dr ) ** 2 ) end if zefff = y end subroutine calc_enorm use constants use rt_parameters , only : nr , inew use spline_module use maxwell use lock_module implicit none integer j , klo , khi , ierr real ( wp ) :: efld real ( wp ) :: r , pn , vt , tmp , xlogj , vmax real ( wp ) :: fnr , fnrr , dens !real*8 fn1,fn2 do j = 1 , nr r = dble ( j ) / dble ( nr + 1 ) call lock ( rh , nspl , r , klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error in saveprofiles, Efield' write ( * , * ) 'j=' , j , ' rh(j)=' , rh ( j ), ' r=' , r pause stop end if call linf ( rh , afld , r , efld , klo , khi ) if ( inew . eq . 0 ) then !vardens pn = fn1 ( r , fnr ) else pn = fn2 ( r , fnr , fnrr ) end if vt = fvt ( r ) tmp = ft ( r ) / 0.16d-8 !Te,  KeV dens = pn / 1.d+13 !10&#94;13 cm&#94;-3 xlogj = dlog ( 5.1527d7 * tmp * 1 6.d0 * dsqrt ( tmp ) / dsqrt ( dens )) enorm ( j ) = ( 3.835d0 / xlogj ) * efld * tmp / dens enorm ( j ) = enorm ( j ) * 5.d0 / ( 5.d0 + zefff ( r )) !!fst(j)=pn*xlogj*c0**4/pi4/vt**3 fst ( j ) = (( 5.d0 + zefff ( r )) / 5.d0 ) * pn * xlogj * c0 ** 4 / pi4 / vt ** 3 end do end subroutine subroutine init_maxwell use constants use rt_parameters , only : nr , inew use spline_module use maxwell implicit none integer j real ( wp ) r , vclt do j = 1 , nr r = dble ( j ) / dble ( nr + 1 ) vclt = 3.d10 / fvt ( r ) !print *, vclt !call init_vi(vclt, vij(:,j)) vij ( 1 : i0 , j ) = create_vt_grid ( vclt ) call init_fmaxw_classic ( vclt , enorm ( j ), fij (:, j , 1 ), dfij (:, j , 1 )) call init_fmaxw_ext ( vclt , enorm ( j ), fij (:, j , 2 ), dfij (:, j , 2 )) end do fij0 (:,:,:) = fij (:,:,:) dij (:,:,:) = zero end subroutine real ( wp ) function obeom ( ptet , pa ) use constants use approximation implicit real * 8 ( a - h , o - z ) !common /a0befr/ pi,pi2 !common /a0ef1/ cltn !common /a0k/ cdl(10),cly(10),cgm(10),cmy(10),ncoef parameter ( pa0 = 0.d0 ) xdl = fdf ( pa , cdl , ncoef , xdlp ) xly = fdf ( pa , cly , ncoef , xlyp ) xgm = fdf ( pa , cgm , ncoef , xgmp ) xlyv = xlyp * pa + xly cotet = dcos ( ptet ) sitet = dsin ( ptet ) dxdr =- xdlp + cotet - xgmp * sitet ** 2 dxdt =- ( pa + two * xgm * cotet ) * sitet dzdr = xlyv * sitet dzdt = xly * pa * cotet x0 = r0 / rm - xdl + pa * cotet - xgm * sitet ** 2 dxdrdt =- sitet - two * xgmp * sitet * cotet dzdrdt = xlyv * cotet dxdtdt =- pa * cotet - two * xgm * ( cotet ** 2 - sitet ** 2 ) dzdtdt =- xly * pa * sitet x0t = dxdt !-------------------------------------- ! components of metric tensor !-------------------------------------- g11 = dxdr ** 2 + dzdr ** 2 g22 = dxdt ** 2 + dzdt ** 2 g12 = dxdr * dxdt + dzdr * dzdt g33 = x0 ** 2 xj = ( dzdr * dxdt - dxdr * dzdt ) ** 2 !gg=g11*g22-g12*g12 g = xj * g33 obeom = dsqrt ( g ) end real ( wp ) function ploshad ( ptet , pa ) use constants use approximation implicit real * 8 ( a - h , o - z ) !common /a0befr/ pi,pi2 !common /a0ef1/ cltn !common /a0k/ cdl(10),cly(10),cgm(10),cmy(10),ncoef parameter ( pa0 = 0.d0 ) xdl = fdf ( pa , cdl , ncoef , xdlp ) xly = fdf ( pa , cly , ncoef , xlyp ) xgm = fdf ( pa , cgm , ncoef , xgmp ) xlyv = xlyp * pa + xly cotet = dcos ( ptet ) sitet = dsin ( ptet ) dxdr =- xdlp + cotet - xgmp * sitet ** 2 dxdt =- ( pa + two * xgm * cotet ) * sitet dzdr = xlyv * sitet dzdt = xly * pa * cotet x0 = r0 / rm - xdl + pa * cotet - xgm * sitet ** 2 dxdrdt =- sitet - two * xgmp * sitet * cotet dzdrdt = xlyv * cotet dxdtdt =- pa * cotet - two * xgm * ( cotet ** 2 - sitet ** 2 ) dzdtdt =- xly * pa * sitet x0t = dxdt !-------------------------------------- ! components of metric tensor !-------------------------------------- g11 = dxdr ** 2 + dzdr ** 2 g22 = dxdt ** 2 + dzdt ** 2 g12 = dxdr * dxdt + dzdr * dzdt xj = ( dzdr * dxdt - dxdr * dzdt ) ** 2 !gg=g11*g22-g12*g12 ploshad = dsqrt ( xj ) end real ( wp ) function gaussint ( f , a , b , r , eps ) !! что-то про гаусс implicit none real ( wp ) w ( 12 ), x ( 12 ) real ( wp ) f , a , b , r , eps real ( wp ) aa , bb , c1 , c2 , s8 , s16 , u , y , delta integer i !!      save w,x,const !sav# real ( wp ), parameter :: const = 1.0d-12 data w & / 0.101228536290376 , 0.222381034453374 , 0.313706645877887 , & 0.362683783378362 , 0.027152459411754 , 0.062253523938648 , & 0.095158511682493 , 0.124628971255534 , 0.149595988816577 , & 0.169156519395003 , 0.182603415044924 , 0.189450610455069 / data x & / 0.960289856497536 , 0.796666477413627 , 0.525532409916329 , & 0.183434642495650 , 0.989400934991650 , 0.944575023073233 , & 0.865631202387832 , 0.755404408355003 , 0.617876244402644 , & 0.458016777657227 , 0.281603550779259 , 0.095012509837637 / delta = const * dabs ( a - b ) gaussint = 0 d0 aa = a 5 y = b - aa if ( dabs ( y ). le . delta ) return 2 bb = aa + y c1 = 0.5d0 * ( aa + bb ) c2 = c1 - aa s8 = 0 d0 s16 = 0 d0 do i = 1 , 4 u = x ( i ) * c2 s8 = s8 + w ( i ) * ( f ( c1 + u , r ) + f ( c1 - u , r )) end do do i = 5 , 12 u = x ( i ) * c2 s16 = s16 + w ( i ) * ( f ( c1 + u , r ) + f ( c1 - u , r )) end do s8 = s8 * c2 s16 = s16 * c2 if ( dabs ( s16 - s8 ) . gt . eps * ( 1 d0 + dabs ( s16 ))) go to 4 gaussint = gaussint + s16 aa = bb go to 5 4 y = 0.5d0 * y if ( dabs ( y ) . gt . delta ) go to 2 write ( * , 7 ) gaussint = 0 d0 return 7 format ( 1 x , 'gaussint ... too high accuracy required' ) end end module plasma","tags":"","loc":"sourcefile\\2_plasma.f90.html"},{"title":"1_savelyev_solver.f90 – FRTС project","text":"Source Code module savelyev_solver_module use kind_module implicit none PRIVATE :: q , k , d contains subroutine savelyev_solver ( alfa2 , nt , h , dt , n , ybeg , yend , d1 , d2 , d3 , y ) !! разностная схема Савельева для уравнения Фоккера-Планка implicit none real ( wp ), intent ( in ) :: alfa2 integer , intent ( in ) :: nt , n real ( wp ), intent ( in ) :: h , dt real ( wp ), intent ( in ) :: ybeg , yend real ( wp ), intent ( in ) :: d1 ( n + 1 ), d2 ( n + 1 ), d3 ( n + 1 ) real ( wp ), intent ( inout ) :: y ( n ) integer i , it real ( wp ) xx ( n + 1 ), a ( n ), b ( n ), c ( n ), f ( n ) do i = 1 , n + 1 xx ( i ) = h / 2.d0 + h * dble ( i - 1 ) !+shift end do do it = 1 , nt call savelyev_abccoef ( alfa2 , a , b , c , f , y , dt , n , ybeg , yend , xx , h , d1 , d2 , d3 ) call tridag ( a , b , c , f , y , n ) end do end subroutine subroutine savelyev_abccoef ( alfa2 , a , b , c , f , y , dt , n , ybeg , yend , xx , h , d1 , d2 , d3 ) !! -- fill abc matrix implicit none real ( wp ), intent ( in ) :: alfa2 real ( wp ), intent ( inout ) :: a ( n ), b ( n ), c ( n ), f ( n ), y ( n ) real ( wp ), intent ( in ) :: dt integer , intent ( in ) :: n real ( wp ), intent ( in ) :: ybeg , yend , h real ( wp ), intent ( in ) :: xx ( n + 1 ) real ( wp ), intent ( in ) :: d1 ( n + 1 ), d2 ( n + 1 ), d3 ( n + 1 ) integer i , iunit , iunit2 real ( wp ) a1 ( n ), b1 ( n ), c1 ( n ), f1 ( n ), a2 ( n ), b2 ( n ), c2 ( n ), f2 ( n ) !real(wp) kinv,rs,rmink,rplusk,q,qf,r1,rmink2,rplusk2,kinv2 real ( wp ) r , kappa , sum , bmin , bplus , sum2 , sum3 , sum4 real ( wp ) dc , as ( n + 1 ) !external kinv,rs,rmink,rplusk,q,kinv2,rmink2,rplusk2,d sum = ( kinv ( xx ( 1 ) - h / 2 d0 , d2 ( 1 )) + kinv ( xx ( 1 ) + h / 2 d0 , d3 ( 1 ))) * h / 2 d0 as ( 1 ) = h / sum sum = ( kinv ( xx ( 2 ) - h / 2 d0 , d2 ( 2 )) + kinv ( xx ( 2 ) + h / 2 d0 , d3 ( 2 ))) * h / 2 d0 as ( 2 ) = h / sum r = h / 2 d0 * dabs ( rs ( xx ( 1 ) + h / 2 d0 , alfa2 )) / k ( xx ( 1 ) + h / 2 d0 , d3 ( 1 )) kappa = 1 d0 / ( 1 d0 + r ) sum = ( rmink ( xx ( 1 ), d1 ( 1 ), alfa2 ) + rmink ( xx ( 2 ), d1 ( 2 ), alfa2 )) * h / 2 d0 bmin = sum / h sum = ( rplusk ( xx ( 1 ), d1 ( 1 ), alfa2 ) + rplusk ( xx ( 2 ), d1 ( 2 ), alfa2 )) * h / 2 d0 bplus = sum / h sum = qf ( xx ( 2 )) - qf ( xx ( 1 )) dc = sum / h a ( 1 ) = as ( 1 ) * ( kappa / h ** 2 - bmin / h ) c ( 1 ) = as ( 2 ) * ( kappa / h ** 2 + bplus / h ) b ( 1 ) = - ( 1 d0 / dt + a ( 1 ) + c ( 1 ) + dc ) f ( 1 ) = - y ( 1 ) / dt - a ( 1 ) * ybeg do i = 2 , n sum = ( kinv ( xx ( i + 1 ) - h / 2 d0 , d2 ( i + 1 )) + kinv ( xx ( i + 1 ) + h / 2 d0 , d3 ( i + 1 ))) sum = sum * h / 2 d0 as ( i + 1 ) = h / sum r = h / 2 d0 * dabs ( rs ( xx ( i ) + h / 2 d0 , alfa2 )) / k ( xx ( i ) + h / 2 d0 , d3 ( i )) kappa = 1 d0 / ( 1 d0 + r ) sum = ( rmink ( xx ( i ), d1 ( i ), alfa2 ) + rmink ( xx ( i + 1 ), d1 ( i + 1 ), alfa2 )) * h / 2 d0 bmin = sum / h sum = ( rplusk ( xx ( i ), d1 ( i ), alfa2 ) + rplusk ( xx ( i + 1 ), d1 ( i + 1 ), alfa2 )) * h / 2 d0 bplus = sum / h sum = qf ( xx ( i + 1 )) - qf ( xx ( i )) dc = sum / h a ( i ) = as ( i ) * ( kappa / h ** 2 - bmin / h ) c ( i ) = as ( i + 1 ) * ( kappa / h ** 2 + bplus / h ) b ( i ) = - ( 1 d0 / dt + a ( i ) + c ( i ) + dc ) f ( i ) = - y ( i ) / dt end do f ( n ) = f ( n ) - c ( n ) * yend a ( 1 ) = 0 d0 c ( n ) = 0 d0 end real ( wp ) function rplusk ( x , dif , alfa2 ) implicit none real ( wp ), intent ( in ) :: x , dif real ( wp ), intent ( in ) :: alfa2 rplusk = 0.5d0 * ( rs ( x , alfa2 ) + dabs ( rs ( x , alfa2 ))) / k ( x , dif ) end real ( wp ) function rplusk2 ( x , dif , alfa2 ) implicit none real ( wp ), intent ( in ) :: x , dif real ( wp ), intent ( in ) :: alfa2 rplusk2 = 0.5d0 * ( rs ( x , alfa2 ) + dabs ( rs ( x , alfa2 ))) / k2 ( x , dif ) end real ( wp ) function rmink ( x , dif , alfa2 ) implicit none real ( wp ), intent ( in ) :: x , dif real ( wp ), intent ( in ) :: alfa2 rmink = 0.5d0 * ( rs ( x , alfa2 ) - dabs ( rs ( x , alfa2 ))) / k ( x , dif ) end real ( wp ) function rmink2 ( x , dif , alfa2 ) implicit none real ( wp ), intent ( in ) :: x , dif real ( wp ), intent ( in ) :: alfa2 rmink2 = 0.5d0 * ( rs ( x , alfa2 ) - dabs ( rs ( x , alfa2 ))) / k2 ( x , dif ) end real ( wp ) function rs ( x , alfa2 ) implicit none real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: alfa2 !common/ef/ alfa2 rs = 1 d0 / x ** 2 - alfa2 end real ( wp ) function q ( x ) implicit none real ( wp ), intent ( in ) :: x q = 2 d0 / x ** 3 end real ( wp ) function qf ( x ) implicit none real ( wp ), intent ( in ) :: x qf =- 1 d0 / x ** 2 end real ( wp ) function k ( x , dif ) implicit none real ( wp ), intent ( in ) :: x , dif k = dif + 1 d0 / x ** 3 end real ( wp ) function k2 ( x , dif ) implicit none real ( wp ), intent ( in ) :: x , dif k2 = d ( x ) + 1 d0 / x ** 3 end real ( wp ) function kinv ( x , dif ) implicit none real ( wp ), intent ( in ) :: x , dif kinv = x ** 3 / ( dif * x ** 3 + 1 d0 ) end real ( wp ) function kinv2 ( x , dif ) implicit none real ( wp ), intent ( in ) :: x , dif kinv2 = x ** 3 / ( d ( x ) * x ** 3 + 1 d0 ) end subroutine tridag ( a , b , c , r , u , n ) !! создает трехдиагональнйю матрицу implicit none integer , intent ( in ) :: n real ( wp ), intent ( in ) :: a ( n ), b ( n ), c ( n ), r ( n ) real ( wp ), intent ( inout ) :: u ( n ) integer , parameter :: nmax = 1000000 integer j real ( wp ) bet , gam ( nmax ) if ( b ( 1 ). eq . 0.d0 ) pause 'tridag: rewrite equations' bet = b ( 1 ) u ( 1 ) = r ( 1 ) / bet do j = 2 , n gam ( j ) = c ( j - 1 ) / bet bet = b ( j ) - a ( j ) * gam ( j ) if ( bet . eq . 0.d0 ) then write ( * , * ) 'b(j)=' , b ( j ), 'a(j)=' , a ( j ), 'gam(j)=' , gam ( j ) pause 'tridag failed' end if u ( j ) = ( r ( j ) - a ( j ) * u ( j - 1 )) / bet end do do j = n - 1 , 1 , - 1 u ( j ) = u ( j ) - gam ( j + 1 ) * u ( j + 1 ) end do end subroutine real ( wp ) function d ( x ) !! возможно одна из самых замедляющих функций use maxwell use lock_module implicit none !integer i0 !parameter(i0=1002) !real*8 vij,fij0,fij,dfij,dij,enorm,fst !common/lh/vij(i0,100),fij0(i0,100,2),fij(i0,100,2),dfij(i0,100,2),dij(i0,100,2),enorm(100),fst(100) real ( wp ), dimension (:), allocatable :: vvj , ddj integer klo , khi , ierr real ( wp ) x integer k , j , i !common/dddql/ d0,jindex,kindex d = zero if ( flag_d0 ) return j = jindex if ( x . ge . vij ( i0 , j )) return k = kindex allocate ( vvj ( i0 ), ddj ( i0 )) do i = 1 , i0 vvj ( i ) = vij ( i , j ) ddj ( i ) = dij ( i , j , k ) end do call lock ( vvj , i0 , x , klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , j , ' v=' , x write ( * , * ) 'vj(1)=' , vvj ( 1 ), ' vj(i0)=' , vvj ( i0 ) pause stop end if d = ddj ( klo ) deallocate ( vvj , ddj ) end end module savelyev_solver_module","tags":"","loc":"sourcefile\\1_savelyev_solver.f90.html"},{"title":"3_trajectory_module.f90 – FRTС project","text":"Source Code module trajectory_module use kind_module use trajectory_data implicit none !integer, parameter :: mpnt = 100000 !integer nrefj(mpnt) !!common/refl/nrefj(mpnt) !integer mbeg(mpnt),mend(mpnt),mbad(mpnt) integer , parameter :: max_num_trajectories = 10000 type ( Trajectory ), target :: trajectories ( max_num_trajectories ) contains subroutine init_trajectory use constants use driver_module implicit none !nrefj = 0 !dland = zero !dcoll = zero !perpn = zero !dalf  = zero !vel = zero !jrad = zero !iww = zero !tetai = zero !xnpar = zero !izz = zero !mbeg = zero !mend = zero !mbad = zero end subroutine subroutine view ( tview , ispectr , nnz , ntet ) !sav2008 !!!writing trajectories into a file use constants use approximation use plasma use decrements , only : pdec1 , pdec2 , pdec3 , pdecv , pdecal , dfdv use decrements , only : zatukh use rt_parameters , only : nr , itend0 , kv , nmaxm use iterator_mod , only : dflf , dfrt , distr use driver_module !, only: jrad, iww, izz, length use trajectory_data implicit none real ( wp ), intent ( in ) :: tview integer , intent ( in ) :: ispectr , nnz , ntet !sav# type ( Trajectory ) :: traj type ( TrajectoryPoint ) :: tp !common /bcef/ ynz,ynpopq !common /vth/ vthc(length),poloidn(length) real ( wp ) vthcg , npoli !common /a0ghp/ vlf,vrt,dflf,dfrt integer i , n , itr , ntraj integer jrc , nturn , ib , ie , jr , ifast , idir , iv integer jznak , jdlt , mn , mm , jchek , itet , inz integer , parameter :: unit_bias = 10 integer , parameter :: m = 7 real ( wp ), parameter :: pleft = 1.d-10 !m may be chaged together with name(m) real ( wp ) :: htet , h , xr , xdl , xdlp , xly , xlyp , xgm , xgmp , th real ( wp ) :: x , xx , z , zz , pl , pc , pa real ( wp ) :: pdec1z , pdec3z , pintld , pintal real ( wp ) :: cotet , sitet real ( wp ) :: v , refr , dek3 , parn , argum real ( wp ) :: df , powpr , powd , powal , pil , pic real ( wp ) :: powcol , pia , pt , denom , powdamped , domin , fff character ( 14 ) folder character ( 40 ) ver_fn character ( 40 ) fname print * , 'view_time=' , tview !print *, name(m) if ( ispectr > 0 ) then folder = \"lhcd/traj/pos/\" else folder = \"lhcd/traj/neg/\" endif write ( ver_fn , '(A, \"v2\")' ) folder print * , ver_fn open ( 1 , file = ver_fn ) write ( 1 , * ) 'version 2' close ( 1 ) write ( fname , '(A, f9.7,\".dat\")' ) folder , tview print * , fname htet = zero h = 1 d0 / dble ( nr + 1 ) if ( ntet . ne . 1 ) htet = ( tet2 - tet1 ) / ( ntet - 1 ) open ( 1 , file = fname ) ntraj = 0 !sav2008 do itr = 1 , nnz * ntet !sav2008 pow = 1.d0 pl = zero pc = zero pa = zero pdec1 = zero pdec1z = zero pdec3 = zero pdec3z = zero pdecv = zero pintld = zero pintal = zero jrc = nr + 1 jznak =- 1 nturn = 1 traj = trajectories ( itr ) call traj % write_info ( 1 ) if ( traj % mbad . eq . 0 ) then ntraj = ntraj + 1 write ( 1 , 3 ) !write header do i = 1 , traj % size tp = traj % points ( i ) v = tp % vel jr = tp % jrad refr = tp % perpn npoli = tp % poloidn ifast = tp % iww vthcg = tp % vthc idir = tp % izz dek3 = zero th = tp % tetai parn = tp % xnpar if ( itend0 . gt . 0 ) then argum = clt / ( refr * valfa ) dek3 = zatukh ( argum , abs ( jr ), vperp , kv ) end if call distr ( v , abs ( jr ), iv , df ) if ( jr . lt . 0 ) then !case of turn jr =- jr !variant          pintld=-dland(i)*df !!          pintld=-dland(i)*(dflf+dfrt)/2d0 pintld = dabs ( tp % dland * ( dflf + dfrt ) / 2 d0 ) pdec2 = dexp ( - 2 d0 * tp % dcoll ) pintal = dabs ( tp % dalf * dek3 ) else pdec2 = tp % dcoll pdecv = tp % dland !!          pdec1=-pdecv*df pdec1 = dabs ( pdecv * df ) pdec3 = dabs ( tp % dalf * dek3 ) pintld = ( pdec1 + pdec1z ) / 2 d0 * h pintal = ( pdec3 + pdec3z ) / 2 d0 * h pdec1z = pdec1 pdec3z = pdec3 end if powpr = pow powd = pow * dexp ( - 2 d0 * pintld ) powcol = powd * pdec2 powal = powcol * dexp ( - 2 d0 * pintal ) pow = powal pil = pintld pic = . 5 d0 * dabs ( dlog ( pdec2 )) pia = pintal pt = 1.d0 - pow !total absorbed power denom = pil + pic + pia powdamped = 1.d0 - dexp ( - 2.d0 * denom ) domin = powpr * powdamped if ( denom . ne . zero ) then fff = domin / denom pl = pl + dabs ( pil * fff ) !el. Landau absorbed power pc = pc + dabs ( pic * fff ) !el. collisions absorbed power pa = pa + dabs ( pia * fff ) !alpha Landau absorbed power end if xr = tp % rho !h*dble(jr) cotet = dcos ( th ) sitet = dsin ( th ) xdl = fdf ( xr , cdl , ncoef , xdlp ) xly = fdf ( xr , cly , ncoef , xlyp ) xgm = fdf ( xr , cgm , ncoef , xgmp ) xx =- xdl + xr * cotet - xgm * sitet ** 2 zz = xr * xly * sitet x = ( r0 + rm * xx ) / 1 d2 z = ( z0 + rm * zz ) / 1 d2 jdlt = jr - jrc jrc = jr if ( jdlt * jznak . lt . 0. and . nturn . lt . m - 1 ) then nturn = nturn + 1 jznak =- jznak end if !   R, Z, rho, theta, N_par, N_pol, P_tot,P_land, P_coll, vth,  'slow=1','out=1', driver, N_traj write ( 1 , 7 ) x , z , xr , th , parn , npoli , pt , pl , pc , vthcg , ifast , idir , tp % driver , itr if ( pt . ge . 1 d0 - pleft ) go to 11 !maximal absorbed power along a ray end do 11 continue write ( 1 , * ) end if end do close ( 1 ) 1 format ( 2 x , 'N_traj' , 3 x , 'mbad' , 6 x , 'theta' , 9 x , 'Npar' , 9 x , 'rho_start' ) 2 format ( 'R_pass' , 4 x , 'Ptot' , 6 x , 'Pland' , 6 x , 'Pcoll' , 8 x , 'Pa' , 7 x , 'dPtot' , 6 x , 'dPland' , 5 x , 'dPcoll' , 6 x , 'dPa' ) 3 format ( 5 x , 'R' , 10 x , 'Z' , 11 x , 'rho' , 8 x , 'theta' , 7 x , 'N_par' , 7 x , 'N_pol' , 6 x , 'P_tot' , 7 x , 'P_land' , 6 x , 'P_coll' , 6 x , 'vth' , 4 x , 'slow=1' , 4 x , 'out=1' , 2 x , 'driver' , 2 x 'N_traj' , 6 x ) 4 format ( i3 , 5 x , 8 ( f6 . 3 , 5 x )) 5 format ( 6 ( e13 . 6 , 3 x )) 6 format ( 2 ( i6 , 2 x ), 4 ( e13 . 6 , 1 x )) 7 format ( 10 ( e11 . 4 , 1 x ), i5 , 2 x , i5 , 2 x , i5 , 2 x , i5 ) 8 format ( 'after radial pass=' , i3 , 2 x , ' P_tot=' , f6 . 3 , 2 x , ' P_land=' , f5 . 3 , 2 x , ' P_coll=' , f6 . 3 , 2 x , ' P_a=' , f6 . 3 ) 9 format ( 'Total passes:           P_tot=' , f6 . 3 , 2 x , ' P_land=' , f5 . 3 , 2 x , ' P_coll=' , f6 . 3 , 2 x , ' P_a=' , f6 . 3 ) 20 format ( 'written time slice (seconds) =' , f9 . 3 ) end !subroutine traj(xm0, tet0, xbeg, nmax, nb1, nb2, pabs) subroutine tracing ( traj , nmax , nb1 , nb2 , pabs ) use constants , only : tiny1 use rt_parameters , only : eps , rrange , hdrob , nr , ipri , iw use dispersion_module , only : izn , yn3 use dispersion_module , only : extd4 , disp2 , disp2_iroot3 , disp2_ider0 use driver_module , only : im4 , hrad , irs , iabsorp , iznzz , iwzz , irszz , rzz use driver_module , only : tetzz , xmzz use driver_module , only : driver2 , driver4 use dispersion_equation , only : ynz use trajectory_data implicit none class ( Trajectory ), intent ( inout ) :: traj real ( wp ), intent ( in ) :: pabs integer , intent ( inout ) :: nmax integer , intent ( inout ) :: nb1 , nb2 !integer,  intent(in)    :: nomth, nomnz real ( wp ) :: xm0 real ( wp ) :: tet0 real ( wp ) :: xbeg integer :: nrefl integer :: irep integer :: irf , irf1 integer :: ib2 integer :: irs0 integer :: inak_saved real ( wp ), parameter :: pgdop = 0.02d0 real ( wp ), parameter :: hmin = 0.d-7 !sav2008, old hmin=1.d-7 real ( wp ) :: eps0 real ( wp ) :: rrange0 , hdrob0 , tet , xm , hr real ( wp ) :: xsav , xend , hsav , h1 real ( wp ) :: ystart ( 2 ), yy ( 4 ) real ( wp ) :: xnr real ( wp ) :: ynz0 , x1 , x2 , rexi , tetnew real ( wp ) :: xmnew , rnew , xnrnew real ( wp ) :: pg1 , pg2 , pg3 , pg4 , pg ! copy initial parameters for a trajectory xm0 = traj % xmzap tet0 = traj % tetzap xbeg = traj % rzap yn3 = traj % yn3zap irs = traj % irszap iw = traj % iwzap izn = traj % iznzap eps0 = eps rrange0 = rrange hdrob0 = hdrob nrefl = 0 im4 = 0 nb1 = 0 nb2 = 0 irep = 0 tet = tet0 xm = xm0 hr = 1.d0 / dble ( nr + 1 ) !sav2008 hrad = hr !--------------------------------------- ! find saving point and define ! parameters, depending on direction !--------------------------------------- 10 irf1 = idnint ( xbeg / hr ) if ( dabs ( irf1 * hr - xbeg ). lt . tiny1 ) then xsav = hr * irf1 else irf = int ( xbeg / hr ) if ( irs . eq . 1 ) xsav = hr * irf if ( irs . eq . - 1 ) xsav = hr * ( irf + 1 ) end if xend = 0.5d0 - 0.5d0 * irs + tiny1 * irs if ( ipri . gt . 2 ) write ( * , * ) 'xbeg-xend' , xbeg , xend hsav = - hr * irs h1 = hsav !--------------------------------------- ! solve eqs. starting from xbeg !--------------------------------------- ystart ( 1 ) = tet ystart ( 2 ) = xm call driver2 ( ystart , xbeg , xend , xsav , hmin , h1 , pabs ) tet = ystart ( 1 ) xm = ystart ( 2 ) ib2 = 0 !--------------------------------------- ! absorption !--------------------------------------- if ( iabsorp . ne . 0 ) then if ( ipri . gt . 2 ) write ( * , * ) 'in traj() iabsorp=' , iabsorp nmax = nrefl !return goto 90 end if if ( xend . eq . xbeg ) nb1 = nb1 + 1 !sav2008 20    continue !-------------------------------------------------------- !  pass turning point !-------------------------------------------------------- irs0 = irs call disp2_ider0 ( xend , xm , tet , xnr ) ynz0 = ynz 40 yy ( 1 ) = tet yy ( 2 ) = xm yy ( 3 ) = xend yy ( 4 ) = xnr x1 = 0 d0 x2 = 1 d + 10 rexi = xend inak_saved = current_trajectory % size !inak call driver4 ( yy , x1 , x2 , rexi , hmin , extd4 ) if ( iabsorp . eq . - 1 ) goto 90 !return !failed to turn tetnew = yy ( 1 ) xmnew = yy ( 2 ) rnew = yy ( 3 ) xnrnew = yy ( 4 ) if ( ipri . gt . 2 ) write ( * , * ) 'from r=' , rexi , 'to r=' , rnew !--------------------------------------- ! find mode !--------------------------------------- call disp2_iroot3 ( rnew , xmnew , tetnew , xnrnew , pg1 , pg2 , pg3 , pg4 ) pg = dmin1 ( pg1 , pg2 , pg3 , pg4 ) if ( dabs ( pg / xnrnew ). gt . pgdop ) then !--------------------------------------------- ! bad accuracy, continue with 4 equations !-------------------------------------------- ib2 = ib2 + 1 nb2 = nb2 + 1 if ( ib2 . gt . 4 ) then if ( ipri . gt . 1 ) write ( * , * ) 'error: cant leave 4 eqs' iabsorp =- 1 print * , 'exit ib2.gt.4' !return goto 90 end if eps = eps / 5 d0 rrange = rrange * 2 d0 hdrob = hdrob * 2 d0 call current_trajectory % reset ( inak_saved ) ! костыль - восстанавливаю занчение счетчика точек траектории goto 40 end if !------------------------------------- !          change wave type !------------------------------------- if ( pg . ne . pg1 ) then if ( pg . eq . pg2 ) izn =- izn if ( pg . eq . pg3 ) iw =- iw if ( pg . eq . pg4 ) iw =- iw if ( pg . eq . pg4 ) izn =- izn end if if ( irs0 . ne . irs ) nrefl = nrefl + 1 xbeg = rnew tet = tetnew xm = xmnew im4 = 1 eps = eps0 rrange = rrange0 hdrob = hdrob0 if ( nrefl . lt . nmax ) goto 10 rzz = xbeg tetzz = tet xmzz = xm iznzz = izn iwzz = iw irszz = irs !--------------------------------------- ! remember end point of trajectory !--------------------------------------- 90 traj % rzap = rzz traj % tetzap = tetzz traj % xmzap = xmzz traj % yn3zap = yn3 traj % iznzap = iznzz traj % iwzap = iwzz traj % irszap = irszz end end module trajectory_module","tags":"","loc":"sourcefile\\3_trajectory_module.f90.html"},{"title":"2_FokkerPlanck1D.f90 – FRTС project","text":"Source Code module FokkerPlanck1D_mod ! the module name defines the namespace !! модуль содержит функции для решения одномерного уравнения Фоккер-Планка use , intrinsic :: iso_fortran_env , only : sp => real32 , dp => real64 use savelyev_solver_module implicit none type FokkerPlanck1D !! solver of FP eq !integer          :: direction = 0 !- direction real ( dp ) :: enorm = 0 !! электрическое поле real ( dp ) :: v_lim = 0 !! верхняя граница скорости электронов real ( dp ), allocatable :: v (:) !! сетка скоростей real ( dp ), allocatable :: f (:) !! распределение integer :: i0 = 0 !! size of distribution grid real ( dp ) :: alfa2 = 0 !! поле со знаком integer :: n = 0 !! size of local grid real ( dp ) :: h = 0 !! step of local grid real ( dp ), allocatable :: d1 (:), d2 (:), d3 (:) !! диффузия contains procedure :: print => FokkerPlanck1D_print procedure :: solve_time_step => FokkerPlanck1D_solve_time_step procedure :: init_zero_diffusion => FokkerPlanck1D_init_zero_diffusion procedure :: init_diffusion => FokkerPlanck1D_init_diffusion end type FokkerPlanck1D interface FokkerPlanck1D module procedure :: FokkerPlanck1D_constructor end interface FokkerPlanck1D contains function FokkerPlanck1D_constructor ( e , v_lim , v , f ) result ( this ) !! конструктор для FokkerPlanck1D implicit none type ( FokkerPlanck1D ) :: this real ( dp ), value :: e , v_lim , v (:), f (:) integer :: n real ( dp ) :: h real ( dp ), parameter :: h0 = 0.1d0 !this%inst_field1 = cmplx(0.,0.) this % enorm = abs ( e ) this % v_lim = v_lim this % v = v this % f = f this % i0 = size ( v ) this % alfa2 = e n = v_lim / h0 - 1 h = v_lim / dble ( n + 1 ) if ( h . gt . h0 ) then n = n + 1 h = v_lim / dble ( n + 1 ) end if this % n = n this % h = h end function FokkerPlanck1D_constructor subroutine FokkerPlanck1D_print ( this ) class ( FokkerPlanck1D ), intent ( in ) :: this print * , 'e = ' , this % enorm , 'i0 =' , this % i0 end subroutine FokkerPlanck1D_print subroutine FokkerPlanck1D_init_zero_diffusion ( this ) implicit none class ( FokkerPlanck1D ), intent ( inout ) :: this integer :: n n = this % n allocate ( this % d1 ( n + 1 ), this % d2 ( n + 1 ), this % d3 ( n + 1 )) this % d1 (:) = 0 d0 this % d2 (:) = 0 d0 this % d3 (:) = 0 d0 end subroutine FokkerPlanck1D_init_zero_diffusion subroutine FokkerPlanck1D_init_diffusion ( this , dif ) !! инициализация диффузии для схемы савельева use lock_module implicit none class ( FokkerPlanck1D ), intent ( inout ) :: this integer :: n real ( dp ), dimension (:), intent ( in ) :: dif real ( dp ), dimension (:), allocatable :: xx real ( dp ) h integer :: i0 integer i , klo , khi , ierr , klo1 , khi1 integer klo2 , klo3 , khi2 , khi3 , ierr1 , ierr2 , ierr3 n = this % n h = this % h allocate ( this % d1 ( n + 1 ), this % d2 ( n + 1 ), this % d3 ( n + 1 )) i0 = this % i0 allocate ( xx ( n + 1 )) do i = 1 , n + 1 xx ( i ) = h / 2.d0 + h * dble ( i - 1 ) !+shift end do do i = 1 , n + 1 call lock ( this % v , i0 , xx ( i ), klo1 , khi1 , ierr1 ) call lock ( this % v , i0 , xx ( i ) - h / 2 d0 , klo2 , khi2 , ierr2 ) call lock ( this % v , i0 , xx ( i ) + h / 2 d0 , klo3 , khi3 , ierr3 ) if ( ierr1 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo1=' , klo1 , 'khi1=' , khi1 , 'i=' , i write ( * , * ) 'vj(1)=' , this % v ( 1 ), ' vj(i0)=' , this % v ( i0 ) pause stop end if if ( ierr2 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo2=' , klo2 , 'khi2=' , khi2 , 'i=' , i write ( * , * ) 'vj(1)=' , this % v ( 1 ), ' vj(i0)=' , this % v ( i0 ) pause stop end if if ( ierr3 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo3=' , klo3 , 'khi3=' , khi3 , 'i=' , i write ( * , * ) 'vj(1)=' , this % v ( 1 ), ' vj(i0)=' , this % v ( i0 ) pause stop end if this % d1 ( i ) = dif ( klo1 ) this % d2 ( i ) = dif ( klo2 ) this % d3 ( i ) = dif ( klo3 ) end do end subroutine FokkerPlanck1D_init_diffusion subroutine FokkerPlanck1D_solve_time_step ( this , dt , nt ) use lock_module implicit none class ( FokkerPlanck1D ), intent ( inout ) :: this integer , intent ( in ) :: nt real ( dp ), intent ( in ) :: dt !real*8, intent (inout), optional :: dfj0(:) real ( dp ), parameter :: zero = 0.d0 real ( dp ) y ( this % n + 2 ), x ( this % n + 2 ) real ( dp ), dimension (:), allocatable :: fj , dfj , givi integer i , ii , it , ibeg , klo , khi , ierr , klo1 , khi1 real ( dp ) shift , ybeg , yend , tend , dff !!!!!! grid !!!!!!!!! !!  shift=h*0.1d0 !0.01d0 do i = 1 , this % n + 2 x ( i ) = this % h * dble ( i - 1 ) !+shift end do do i = 1 , this % n + 1 call lock ( this % v , this % i0 , x ( i + 1 ), klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error #1 in finction fokkerplanck' write ( * , * ) 'j=' , 123 , ' v=' , x ( i + 1 ) write ( * , * ) 'vj(1)=' , this % v ( 1 ), ' vj(i0)=' , this % v ( this % i0 ) pause stop end if call linf ( this % v , this % f , x ( i + 1 ), y ( i ), klo , khi ) end do ybeg = this % f ( 1 ) !boundary conditions yend = this % f ( this % i0 ) !zero !print *, ' yend =', yend !!!!!!!!!!!!   solve problem   !!!!!!!!!!!!!!!!!!!!!!!!!! call savelyev_solver ( this % alfa2 , nt , this % h , dt , this % n , ybeg , yend , this % d1 , this % d2 , this % d3 , y ) !call teplova_khavin_solver(this%alfa2, nt, this%h, dt, this%n, ybeg, yend, this%d1,this%d2,this%d3, y) allocate ( fj ( this % n + 2 )) fj ( 1 ) = ybeg fj ( this % n + 2 ) = yend do i = 1 , this % n fj ( i + 1 ) = y ( i ) end do do i = 2 , this % i0 - 1 if ( this % v ( i ). lt . this % v_lim ) then call lock ( x , this % n + 2 , this % v ( i ), klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error #2 in finction fokkerplanck' write ( * , * ) 'j=' , 123 , ' vij=' , this % v ( i ) write ( * , * ) 'x(1)=' , x ( 1 ), ' x(n+2)=' , x ( this % n + 2 ) pause stop end if call linf ( x , fj , this % v ( i ), this % f ( i ), klo , khi ) else this % f ( i ) = zero end if end do deallocate ( fj ) !if (present(dfj0)) then !    call burying_procedure(vj, fj0, dfj0) !else !    call burying_procedure(vj, fj0) !end if end subroutine FokkerPlanck1D_solve_time_step subroutine burying_procedure ( v , f0 , df0 ) !! процедура закапывания use math_module implicit none real * 8 , intent ( in ) :: v (:) real * 8 , intent ( inout ) :: f0 (:) real * 8 , intent ( inout ), optional :: df0 (:) integer i , ii , i0 , ibeg real * 8 , allocatable :: f (:), df (:) real * 8 fout1 , fout2 i0 = size ( f0 ) allocate ( f ( i0 ), df ( i0 )) f (:) = f0 (:) df (:) = 0 d0 do i = 2 , i0 - 1 df ( i ) = 0.5d0 * ( f ( i + 1 ) - f ( i - 1 )) / v ( 2 ) end do df ( 1 ) = 0 d0 df ( i0 ) = ( f ( i0 ) - f ( i0 - 1 )) / v ( 2 ) !   сдвиг расределения вправо. зачем-то ??? ii = 0 ibeg = 0 do i = i0 - 1 , 1 , - 1 if ( df ( i ). gt . 0 d0 ) then !          write(*,*) '#1 positive derivs' !          write(*,*) '#1 df>0: i,j,k=',i,j,k !          write(*,*) '#1 dfj(i),i,j,k=',dfj(i),i,j,k !          write(*,*) f0 ( i ) = f0 ( i + 1 ) if ( present ( df0 )) then df0 ( i ) = df0 ( i + 1 ) end if ii = i end if if ( f0 ( i ). lt . f0 ( i + 1 )) then f0 ( i ) = f0 ( i + 1 ) if ( present ( df0 )) then df0 ( i ) = df0 ( i + 1 ) end if ii = i end if end do if ( ibeg . gt . 0 ) then call integral ( ibeg , i0 , v , f , fout1 ) f (:) = f0 (:) if ( present ( df0 )) then df (:) = df0 (:) end if call integral ( ibeg , i0 , v , f , fout2 ) f0 ( ibeg : i0 ) = f ( ibeg : i0 ) * fout1 / fout2 if ( present ( df0 )) then df0 ( ibeg : i0 ) = df ( ibeg : i0 ) * fout1 / fout2 end if !      write(*,*)'#1 j,k,ibeg=',j,k,ibeg !      write(*,*)'#1 v(ibeg)=',vj(ibeg),' f1/f2=',fout1/fout2 end if deallocate ( f , df ) ibeg = ii end subroutine end module FokkerPlanck1D_mod","tags":"","loc":"sourcefile\\2_fokkerplanck1d.f90.html"},{"title":"3_flux_surface_mod.f90 – FRTС project","text":"Source Code module FluxSurface_mod !! все что связанно с магнитными поверхностями use kind_module type FluxSurface !! класс магнитной поверхности integer :: index !! номер магнитной поверхности real ( wp ) :: r !! радиус real ( wp ) :: vmax !! vmax=cltn/vto real ( wp ) :: vt !! наверно тепловая скорость электронов????? vt=fvt(r) integer :: ipt !! размер vgrid real ( wp ), allocatable :: vgrid (:) !! real ( wp ), allocatable :: vr_grid (:) !! бываший vrj real ( wp ), allocatable :: diffusion (:) !! бывший dijk(i,j,k) или dj(i) !   complex         :: inst_field1 contains !procedure :: set   => set_e !procedure :: print => e_print end type FluxSurface end module FluxSurface_mod","tags":"","loc":"sourcefile\\3_flux_surface_mod.f90.html"},{"title":"1_math.f90 – FRTС project","text":"Source Code module math_module use kind_module implicit none contains subroutine diff ( x , y , n , dy ) implicit real * 8 ( a - h , o - z ) dimension y ( * ), x ( * ), dy ( * ) integer :: k , n dy ( 1 ) = ( y ( 2 ) - y ( 1 )) / ( x ( 2 ) - x ( 1 )) do k = 2 , n - 1 dy ( k ) = ( y ( k + 1 ) - y ( k - 1 )) / ( x ( k + 1 ) - x ( k - 1 )) end do dy ( n ) = ( y ( n ) - y ( n - 1 )) / ( x ( n ) - x ( n - 1 )) return end subroutine integral ( ibeg , iend , x , y , fout ) implicit real * 8 ( a - h , o - z ) integer :: ibeg , iend dimension x ( * ), y ( * ) integer :: i , n1 , n2 , ie fout = 0.d0 if ( ibeg . eq . iend ) return znak = 1.d0 n1 = ibeg n2 = iend if ( n2 . lt . n1 ) then znak =- 1.d0 ie = n1 n1 = n2 n2 = ie end if sum = 0.d0 do i = n1 + 1 , n2 dx = x ( i ) - x ( i - 1 ) dsum = y ( i ) + y ( i - 1 ) sum = sum + . 5 d0 * dsum * dx end do fout = znak * sum end subroutine fsmoth4 ( x , y , n , ys ) use constants , only : zero use approximation implicit real * 8 ( a - h , o - z ) integer , intent ( in ) :: n !external polin2 integer , parameter :: np = 10 , imax = 601 integer , parameter :: m0 = 1 , ndp = 1 ! m0,ndp - parameters of smoothing procedure dimension y ( n ), x ( n ), ys ( n ) dimension yy ( imax ), xx ( imax ) dimension coeffs ( np ), cffs ( np ) dimension dys ( imax ) integer :: i , j , k , id integer :: m , m2 , nmax , jlast if ( n . gt . imax ) stop 'small imax in subroutine fsmoth4()' call diff ( x , y , n , dys ) do k = 1 , n ys ( k ) = y ( k ) end do m = m0 m2 = m + 2 id = m + ndp nmax = n - id xs = x ( 1 ) do j = 1 , nmax do i = 1 , id xx ( i ) = x ( j + i ) - xs yy ( i ) = y ( j + i ) - ys ( j ) - dys ( j ) * xx ( i ) end do call approx ( xx , yy , id , polin2 , m , coeffs ) cffs ( 1 ) = ys ( j ) cffs ( 2 ) = dys ( j ) do k = 1 , m cffs ( k + 2 ) = coeffs ( k ) end do xs = x ( j + 1 ) ys ( j + 1 ) = fdf ( xx ( 1 ), cffs , m2 , dys ( j + 1 )) end do j = nmax + 1 1 continue jlast = j id = n - jlast m = id - 1 if ( m . eq . 0 ) then j = j + 1 xs = x ( j ) ys ( j ) = fdf ( xx ( 2 ), cffs , m2 , dys ( j )) return end if m2 = m + 2 do i = 1 , id xx ( i ) = x ( jlast + i ) - xs yy ( i ) = y ( jlast + i ) - ys ( jlast ) - dys ( jlast ) * xx ( i ) end do call approx ( xx , yy , id , polin2 , m , coeffs ) cffs ( 1 ) = ys ( jlast ) cffs ( 2 ) = dys ( jlast ) do k = 1 , m cffs ( k + 2 ) = coeffs ( k ) end do j = j + 1 xs = x ( j ) ys ( j ) = fdf ( xx ( 1 ), cffs , m2 , dys ( j )) go to 1 end end module math_module","tags":"","loc":"sourcefile\\1_math.f90.html"},{"title":"1_approximation.f90 – FRTС project","text":"Source Code module approximation !! polinomial approximation use kind_module implicit none contains real ( wp ) function polin ( k , x ) implicit none integer k real ( wp ) x polin = 1 d0 if ( k . gt . 1 ) polin = x ** ( k - 1 ) return end real ( wp ) function polin1 ( k , x ) implicit none integer k real ( wp ) x polin1 = x ** k return end real ( wp ) function polin2 ( k , x ) implicit none integer k real ( wp ) x polin2 = x ** ( k + 1 ) return end subroutine approx ( x , y , n , f , m , b ) !!     y(i)=y(x(i))  the data to be approximated. !!     n  number of points in the input data. !!     m  number of coefficients of decomposition !!            over base functions f(k,x) : !!     y(x)=sum_1&#94;m [b(k)*f(k,x)] !!     b(i)  found decomposition coefficients implicit real * 8 ( a - h , o - z ) integer , parameter :: np = 20 real ( wp ), parameter :: zero = 0.d0 real ( wp ) a ( np , np ), indx ( np ) real ( wp ) y ( n ), x ( n ), b ( * ) integer i , j , k , m , n if ( m . gt . np ) then write ( * , * ) 'index error subroutine \"approx\"' return end if do j = 1 , m do k = 1 , j a ( k , j ) = zero do i = 1 , n a ( k , j ) = a ( k , j ) + f ( j , x ( i )) * f ( k , x ( i )) end do end do end do do k = 2 , m do j = 1 , k - 1 a ( k , j ) = a ( j , k ) end do end do do k = 1 , m b ( k ) = zero do i = 1 , n b ( k ) = b ( k ) + y ( i ) * f ( k , x ( i )) end do end do call ludcmp ( a , m , np , indx , d ) call lubksb ( a , m , np , indx , b ) end subroutine ludcmp ( a , n , np , indx , d ) implicit real * 8 ( a - h , o - z ) integer , parameter :: nmax = 501 real ( wp ), parameter :: tiny = 1.d-20 , zero = 0.d0 real ( wp ) a ( np , np ), indx ( n ), vv ( nmax ) integer i , j , k , m , n , np , imax d = 1.d0 do i = 1 , n aamax = zero do j = 1 , n if ( dabs ( a ( i , j )). gt . aamax ) aamax = dabs ( a ( i , j )) end do if ( aamax . eq . zero ) pause 'singular matrix.' vv ( i ) = 1.d0 / aamax end do do j = 1 , n if ( j . gt . 1 ) then do i = 1 , j - 1 sum = a ( i , j ) if ( i . gt . 1 ) then do k = 1 , i - 1 sum = sum - a ( i , k ) * a ( k , j ) end do a ( i , j ) = sum endif end do endif aamax = zero do i = j , n sum = a ( i , j ) if ( j . gt . 1 ) then do k = 1 , j - 1 sum = sum - a ( i , k ) * a ( k , j ) end do a ( i , j ) = sum endif dum = vv ( i ) * dabs ( sum ) if ( dum . ge . aamax ) then imax = i aamax = dum endif end do if ( j . ne . imax ) then do k = 1 , n dum = a ( imax , k ) a ( imax , k ) = a ( j , k ) a ( j , k ) = dum end do d =- d vv ( imax ) = vv ( j ) endif indx ( j ) = imax if ( j . ne . n ) then if ( a ( j , j ). eq . zero ) a ( j , j ) = tiny dum = 1.d0 / a ( j , j ) do i = j + 1 , n a ( i , j ) = a ( i , j ) * dum end do endif end do if ( a ( n , n ). eq . zero ) a ( n , n ) = tiny return end subroutine lubksb ( a , n , np , indx , b ) implicit real * 8 ( a - h , o - z ) real ( wp ), parameter :: zero = 0.d0 real ( wp ) a ( np , np ), indx ( n ), b ( n ) integer i , j , ii , ll , n , np ii = 0 do i = 1 , n ll = indx ( i ) sum = b ( ll ) b ( ll ) = b ( i ) if ( ii . ne . 0 ) then do j = ii , i - 1 sum = sum - a ( i , j ) * b ( j ) end do else if ( sum . ne . zero ) then ii = i endif b ( i ) = sum end do do i = n , 1 , - 1 sum = b ( i ) if ( i . lt . n ) then do j = i + 1 , n sum = sum - a ( i , j ) * b ( j ) end do endif b ( i ) = sum / a ( i , i ) end do return end function fdf ( x , c , n , df ) result ( p ) !! вычисление значения полинома и его производной real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: c ( n ) integer , intent ( in ) :: n real ( wp ), intent ( out ) :: df integer :: j real ( wp ) :: p , dp p = c ( n ) dp = 0.d0 do j = n - 1 , 1 , - 1 dp = dp * x + p p = p * x + c ( j ) end do df = dp end real ( wp ) function fdfddf ( x , c , n , df , ddf ) !! вычисление значения полинома и первой и второй производной real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: c ( n ) integer , intent ( in ) :: n real ( wp ), intent ( out ) :: df real ( wp ), intent ( out ) :: ddf integer j real ( wp ) p , dp , ddp p = c ( n ) dp = 0 d0 ddp = 0 d0 do j = n - 1 , 1 , - 1 ddp = ddp * x + 2 d0 * dp dp = dp * x + p p = p * x + c ( j ) end do fdfddf = p df = dp ddf = ddp end end module approximation","tags":"","loc":"sourcefile\\1_approximation.f90.html"},{"title":"1_writer_module.f90 – FRTС project","text":"Source Code module writer_module use kind_module implicit none contains subroutine binary_write_array ( v , a , time , array_name ) !! сохраняет массивы расределения и скорости implicit none real ( wp ), intent ( in ) :: v (:,:) real ( wp ), intent ( in ) :: a (:,:,:) real ( wp ), intent ( in ) :: time character ( len =* ), intent ( in ) :: array_name real ( wp ), allocatable :: gv (:), ga (:) integer i , N , nshape ( 3 ) character ( 120 ) fname integer , parameter :: iu = 21 if ( MOD ( INT ( time * 100000 ), 10 ) /= 0 ) then return end if nshape = shape ( a ) print * , 'write arr:' , array_name , nshape N = nshape ( 2 ) print * , N write ( fname , '(\"lhcd/\", A,\"/\", f9.7,\".bin\")' ) array_name , time print * , fname open ( iu , file = fname , status = 'new' , action = 'write' , access = 'stream' , form = 'unformatted' ) write ( iu ), nshape ( 1 ), nshape ( 2 ) write ( iu ), v write ( iu ), a !ga = glue_arrays(a(:,i,1), a(:,i,2)) !write (iu, '(2012(ES22.14))') ga(:) close ( iu ) end subroutine subroutine write_v_array ( v , a , time , array_name ) !! сохраняет массивы расределения и скорости implicit none real ( wp ), intent ( in ) :: v (:,:) real ( wp ), intent ( in ) :: a (:,:,:) real ( wp ), intent ( in ) :: time character ( len =* ), intent ( in ) :: array_name real ( wp ), allocatable :: gv (:), ga (:) integer i , N , nshape ( 3 ) character ( 120 ) fname integer , parameter :: iu = 21 if ( MOD ( INT ( time * 100000 ), 10 ) /= 0 ) then return end if nshape = shape ( a ) print * , 'write arr:' , array_name , nshape N = nshape ( 2 ) print * , N write ( fname , '(\"lhcd/\", A,\"/\", f9.7,\".dat\")' ) array_name , time print * , fname open ( iu , file = fname , position = \"append\" ) do i = 1 , N gv = glue_v_axis ( v (:, i )) write ( iu , '(2012(ES22.14))' ) gv (:) deallocate ( gv ) ga = glue_arrays ( a (:, i , 1 ), a (:, i , 2 )) write ( iu , '(2012(ES22.14))' ) ga (:) deallocate ( ga ) end do close ( iu ) contains function glue_v_axis ( a ) result ( g ) implicit none real ( wp ), intent ( in ) :: a (:) real ( wp ), allocatable :: g (:) integer i , N N = size ( a ) allocate ( g ( - N : N )) g ( - N : - 1 ) = - a ( N : 1 : - 1 ) g ( 1 : N ) = a (:) g ( 0 ) = 0 end function function glue_arrays ( a , b ) result ( g ) implicit none real ( wp ), intent ( in ) :: a (:), b (:) real ( wp ), allocatable :: g (:) integer i , N N = size ( a ) allocate ( g ( - N : N )) g ( - N : - 1 ) = a ( N : 1 : - 1 ) g ( 1 : N ) = b (:) g ( 0 ) = ( a ( 1 ) + b ( 1 )) / 2 d0 end function end subroutine subroutine write_x_array ( x , arr , time , array_name ) implicit none real ( wp ), intent ( in ) :: x (:,:) real ( wp ), intent ( in ) :: arr (:,:) real ( wp ), intent ( in ) :: time character ( len =* ), intent ( in ) :: array_name integer i , N , nshape ( 2 ) character ( 120 ) fname integer , parameter :: iu = 21 nshape = shape ( arr ) print * , 'write arr:' , array_name , nshape N = nshape ( 2 ) print * , N write ( fname , '(\"lhcd/\", A,\"/xar\", f9.7,\".dat\")' ) array_name , time print * , fname open ( iu , file = fname , position = \"append\" ) do i = 1 , N write ( iu , '(2012(ES22.14))' ) x (: , i ) write ( iu , '(2012(ES22.14))' ) arr (:, i ) end do close ( iu ) end subroutine subroutine write_matrix ( arr , time , array_name ) implicit none real ( wp ), intent ( in ) :: arr (:,:) real ( wp ), intent ( in ) :: time character ( len =* ), intent ( in ) :: array_name integer i , N , nshape ( 2 ) character ( 120 ) fname integer , parameter :: iu = 21 nshape = shape ( arr ) print * , 'write_matrix:' , array_name , nshape N = nshape ( 1 ) print * , N write ( fname , '(\"lhcd/\", A,\"/\", f9.7,\".dat\")' ) array_name , time print * , fname open ( iu , file = fname , position = \"append\" ) do i = 1 , N write ( iu , ' ( I4.4, 100(ES21.14))' ) i , arr ( i , :) end do close ( iu ) end subroutine subroutine write_array ( arr , N , array_name ) implicit none real ( wp ), intent ( in ) :: arr ( * ) integer , intent ( in ) :: N character ( len =* ), intent ( in ) :: array_name integer i integer , parameter :: iunit = 21 character ( 80 ) fname print * , 'write_array:' , array_name , N write ( fname , '(\"lhcd/distribution/\", A,\".dat\")' ) array_name print * , fname open ( iunit , file = fname , position = \"append\" ) do i = 1 , n write ( iunit , * ) i , arr ( i ) end do close ( iunit ) end subroutine subroutine write_distribution ( arr , N , time ) implicit none real ( wp ), intent ( in ) :: arr ( * ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: time integer i integer itime integer , parameter :: iunit = 20 character ( 120 ) fname itime = INT ( time * 100000 ) !print *, N, time, itime, MOD(itime, 10) if ( MOD ( itime , 10 ) == 0 ) then write ( fname , '(\"lhcd/distribution/\", f9.7,\".dat\")' ) time !print *, fname open ( iunit , file = fname , position = \"append\" ) do i = 1 , N if ( arr ( i ) > 0 ) then write ( iunit , * ) i , arr ( i ) else exit end if end do close ( iunit ) end if end subroutine end module writer_module","tags":"","loc":"sourcefile\\1_writer_module.f90.html"},{"title":"2_source_new.f90 – FRTС project","text":"Source Code module source_new_mod use kind_module implicit none real ( wp ) :: rsou ( 102 ), sou ( 102 ) integer :: npta !!common /asou/ rsou(102),sou(102),npta !! используется в source_new и ourlhcd2017 contains subroutine source_new ( r , out ) use lock_module implicit real * 8 ( a - h , o - z ) integer klo , khi , ierr !common /asou/ rsou(102),sou(102),npta call lock2 ( rsou , npta , r , klo , khi , ierr ) if ( ierr . ne . 0 ) then write ( * , * ) 'lock2 error in source_new' write ( * , * ) 'ierr=' , ierr , ' rho=' , r stop else call linf ( rsou , sou , r , fout , klo , khi ) out = dabs ( fout ) end if end end module source_new_mod","tags":"","loc":"sourcefile\\2_source_new.f90.html"},{"title":"2_iterator_module.f90 – FRTС project","text":"Source Code module iterator_mod use kind_module implicit none real ( wp ) :: vmid ( 100 ), vz1 ( 100 ), vz2 ( 100 ) integer :: ibeg ( 100 ), iend ( 100 ) real ( wp ) :: vrj ( 101 ), dj ( 101 ), djnew ( 1001 ) real ( wp ) :: dj2 ( 101 ), d2j ( 101 ) real ( wp ) :: vgrid ( 101 , 100 ), dfundv ( 101 , 100 ) !!common/gridv/vgrid(101,100),dfundv(101,100) integer :: nvpt !!common/gridv/nvpt integer :: ipt1 , ipt2 , ipt integer :: iterat real ( wp ) :: psum4 !!common /vvv2/ psum4 real ( wp ) :: plost , pnab !!common /a0a4/ plost,pnab real ( wp ) :: vlf , vrt , dflf , dfrt !common /a0ghp/ vlf,vrt,dflf,dfrt contains subroutine distr ( vz , j , ifound , fder ) !use iterator_mod use lock_module implicit none integer , intent ( in ) :: j integer , intent ( inout ) :: ifound real * 8 vz , fder integer i , klo , khi , ierr , nvp real * 8 , dimension (:), allocatable :: vzj , dfdvj real ( wp ) :: dfout !real*8 vlf,vrt,dflf,dfrt !common /a0ghp/ vlf,vrt,dflf,dfrt !common/gridv/vgrid(101,100),dfundv(101,100),nvpt nvp = nvpt allocate ( vzj ( nvp ), dfdvj ( nvp )) do i = 1 , nvp vzj ( i ) = vgrid ( i , j ) dfdvj ( i ) = dfundv ( i , j ) end do call lock2 ( vzj , nvp , vz , klo , khi , ierr ) if ( ierr . eq . 0 ) then !vgrid(1,j) <= vz <= vgrid(nvpt,j) call linf ( vzj , dfdvj , vz , dfout , klo , khi ) ifound = klo vlf = vzj ( klo ) vrt = vzj ( khi ) fder = dfout dflf = dfdvj ( klo ) dfrt = dfdvj ( khi ) else if ( ierr . eq . 1 ) then !vz < vgrid(1,j) write ( * , * ) 'exception: ierr=1 in distr()' pause 'next key = stop' stop else if ( ierr . eq . 2 ) then !vz > vgrid(nvpt,j) write ( * , * ) 'exception: ierr=2 in distr()' pause 'next key = stop' stop else if ( ierr . eq . 3 ) then write ( * , * ) 'exception in distr, klo=khi=' , klo , ' j=' , j , ' nvp=' , nvp write ( * , * ) 'vz=' , vz , ' v1=' , vzj ( 1 ), ' v2=' , vzj ( nvp ) pause 'next key = stop' stop end if deallocate ( vzj , dfdvj ) end end module iterator_mod","tags":"","loc":"sourcefile\\2_iterator_module.f90.html"},{"title":"5_lhcd_module.f90 – FRTС project","text":"Source Code module lhcd_module !! LHCD модуль use kind_module use spectrum_mod implicit none type ( Spectrum ) :: full_spectrum type ( Spectrum ) :: pos_spectr , neg_spectr real ( wp ), dimension (:), allocatable :: vvj , vdfj integer , parameter :: kpt1 = 20 , kpt3 = 20 contains subroutine ourlhcd2017 ( spectr , outpe , pe_out ) use constants use approximation use spline_module use chebyshev use plasma use rt_parameters use maxwell use trajectory_module , only : view , init_trajectory use spectrum_mod use manager_mod use dispersion_module use current use iteration_result_mod use iterator_mod use lock_module use math_module !use driver_module, only : lfree use driven_current_module , only : zv1 , zv2 use decrements , only : kzero use source_new_mod implicit real * 8 ( a - h , o - z ) type ( Spectrum ) spectr real * 8 outpe , pe_out dimension outpe ( * ) dimension galfa ( 50 , 100 ), vpmin ( 100 ), vcva ( 100 ), & pd2 ( 100 ), pd2a ( 100 ), pd2b ( 100 ), pdprev1 ( 100 ), pdprev2 ( 100 ), & source ( 100 ), sour ( 100 ), & rxx ( 102 ), pwe ( 102 ), wrk ( 102 ) !dimension vmid(100),vz1(100),vz2(100),ibeg(100),iend(100) !common /a0a4/ plost,pnab !common /bcef/ ynz,ynpopq !common /a0ghp/ vlf,vrt,dflf,dfrt !common/plosh/ zv1(100,2),zv2(100,2)!,sk(100) !common /asou/ rsou(102),sou(102),npta !common/gridv/vgrid(101,100),dfundv(101,100),nvpt !common /vvv2/ psum4 !common /arr/ dgdu(50,100),kzero(100) !common /ag/ inak,lenstor,lfree real ( wp ) :: rmx_n , rmx_t , rmx_z , rmx_ti ! встречает только один раз common /maxrho/ rmx_n,rmx_t,rmx_z,rmx_ti type ( IterationResult ) :: iteration_result real * 8 kofpar , timecof !real*8,dimension(:),allocatable:: vvj,vdfj !double precision vrj(101),dj(101),djnew(1001) !double precision dj2(101),d2j(101) integer :: iptnew real ( wp ) :: plaun real ( wp ) :: dijk ( 101 , 100 , 2 ), vrjnew ( 101 , 100 , 2 ) !встречает только один раз common/t01/dijk(101,100,2), vrjnew(101,100,2), iptnew integer ispectr integer :: nrr , i , j , k integer :: klo , khi , ierr integer :: jrad , iww , iw0 , izz plaun = spectr % input_power ispectr = spectr % direction !lfree=1 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! hr = 1.d0 / dble ( nr + 1 ) iw0 = iw nrr = nr + 2 rxx ( 1 ) = zero rxx ( nrr ) = one do j = 1 , nr rxx ( j + 1 ) = hr * dble ( j ) end do call find_volums_and_surfaces ppv1 = zero ppv2 = zero pnab = zero plost = zero psum4 = zero anb = zero fuspow = zero o_da = zero !c------------------------------------------- !c find velocity limits and initial dfdv !c-------------------------------------------- ipt1 = kpt1 + 1 ipt2 = ni1 + ni2 ipt = ipt1 + ni1 + ni2 + kpt3 if ( ipt . gt . 101 ) then write ( * , * ) 'ipt >101' pause 'stop program' stop end if nvpt = ipt do j = 1 , nr ! begin 'rho' cycle r = hr * dble ( j ) !!!!sav2008       pn=fn(r) !!       pn=fn1(r,fnr) !!       pn=fn2(r,fnr,fnrr) !sav2008 if ( inew . eq . 0 ) then !vardens pn = fn1 ( r , fnr ) else pn = fn2 ( r , fnr , fnrr ) end if dens ( j ) = pn vt = fvt ( r ) vto = vt / vt0 wpq = c0 ** 2 * pn whe = dabs ( b_tor ) * c1 v = wpq / ww ** 2 u1 = whe / ww u = u1 ** 2 e1 = 1 d0 - v * ( 1 d0 / xmi - 1 d0 / u ) e2 = v / u1 e3 = v tmp = ft ( r ) / 0.16d-8 !Te, keV cn1 = dsqrt ( 50 d0 / tmp ) !sav2008 if ( itend0 . gt . 0 ) then eta ( j ) = 1 d0 - v vcva ( j ) = cnstvc * vt * dsqrt ( 2 d0 ) / valfa vpmin ( j ) = 2.0d0 * dsqrt ( tmp / ( - eta ( j ))) 222 continue dvperp = ( vpmax - vpmin ( j )) / dble ( kv - 1 ) if ( dvperp . le . zero ) then vpmax = 1.3d0 * vpmax go to 222 end if do k = 1 , kv vperp ( k , j ) = vpmin ( j ) + dble ( k - 1 ) * dvperp end do fcoll ( j ) = . 5 d - 13 * dens ( j ) * zalfa ** 2 * xlog / xmalfa / tmp ** 1.5d0 ddens = dn1 * dens ( j ) tdens = dn2 * dens ( j ) tt = fti ( r ) ** one_third ! (ti, keV)&#94;1/3 source ( j ) = 4 d - 12 * factor * ddens * tdens * dexp ( - 20 d0 / tt ) / tt ** 2 anb = anb + source ( j ) * vk ( j ) end if cn2 = dsqrt ( dabs ( e1 )) + e2 / dsqrt ( e3 ) !sav2008 !vz1(j)=cleft*cltn/cn1  !Vpar/Vt0 !vz2(j)=cright*cltn/cn2  !Vpar/Vt0 !if(vz2(j).gt.0.9d0*cltn) vz2(j)=0.9d0*cltn !v1=vz1(j)/vto !Vpar/Vt(rho) !v2=vz2(j)/vto !Vpar/Vt(rho) vmax = cltn / vto v1 = 4.d0 !Vpar/Vt(rho) v2 = 1 0.d0 !cright*cltn/cn2 !10.d0 !Vpar/Vt(rho) if ( v2 . ge . vmax ) v2 = 0.5d0 * vmax if ( v1 . ge . v2 ) v1 = v2 - 2.d0 call gridvel ( v1 , v2 , vmax , 0.5d0 , ni1 , ni2 , ipt1 , kpt3 , vrj ) vz1 ( j ) = v1 * vto !Vpar/Vt0 vz2 ( j ) = v2 * vto !Vpar/Vt0 if ( vz2 ( j ). gt . 0.9d0 * cltn ) vz2 ( j ) = 0.9d0 * cltn do i = 1 , ipt vgrid ( i , j ) = vrj ( i ) * vto end do end do ! end 'rho' cycle !!!!!!!!!read data !!!!!!!!!!!! allocate ( vvj ( i0 ), vdfj ( i0 )) k = ( 3 - ispectr ) / 2 do j = 1 , nr r = hr * dble ( j ) vt = fvt ( r ) vto = vt / vt0 do i = 1 , i0 vvj ( i ) = vij ( i , j ) vdfj ( i ) = dfij ( i , j , k ) !=dfundv(i,j)*vto**2 end do do i = 1 , ipt vrj ( i ) = vgrid ( i , j ) / vto !Vpar/Vt call lock ( vvj , i0 , vrj ( i ), klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error in read distribution function' write ( * , * ) 'j=' , j , 'i0=' , i0 write ( * , * ) 'vvj(1)=' , vvj ( 1 ), ' vvj(i0)=' , vvj ( i0 ) write ( * , * ) 'i=' , i , ' vrj(i)=' , vrj ( i ), ' vmax=' , cltn / vto write ( * , * ) pause 'next key = stop' stop end if call linf ( vvj , vdfj , vrj ( i ), dfout , klo , khi ) dfundv ( i , j ) = dfout / vto ** 2 if ( dfundv ( i , j ). gt . zero ) dfundv ( i , j ) = zero end do end do !!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( itend0 . gt . 0 ) then ! begin alpha-source renormalisation fuspow = anb * talfa * 1.6022d-19 anb0 = anb anb = zero do j = 1 , nr r = hr * dble ( j ) if ( r . le . dra ) then tt = fti ( zero ) ** one_third else tt = fti ( r - dra ) ** one_third ! (shifted ti, kev)&#94;1/3 end if ddens = dn1 * dens ( j ) tdens = dn2 * dens ( j ) sour ( j ) = 4 d - 12 * factor * ddens * tdens * dexp ( - 20 d0 / tt ) / tt ** 2 anb = anb + sour ( j ) * vk ( j ) end do aratio = anb0 / anb rsou ( 1 ) = zero sou ( 1 ) = aratio * sour ( 1 ) do j = 1 , nr r = hr * dble ( j ) rsou ( j + 1 ) = r sou ( j + 1 ) = aratio * sour ( j ) if ( j . eq . nr ) sssour = source ( j ) source ( j ) = sou ( j + 1 ) end do npta = nr + 2 rsou ( npta ) = 1.d0 sou ( npta ) = aratio * sour ( nr ) end if !c------------------------------------ !c set initial values of arrays !c------------------------------------ dland = zero dcoll = zero perpn = zero dalf = zero vel = zero jrad = 0 iww = 0 tatai = zero xnpar = zero izz = zero ! pdl = zero pdc = zero pda = zero pdfast = zero pdprev1 = zero pdprev2 = zero tok = zero cur = zero pd2 = zero pd2a = zero pd2b = zero dql = zero dq1 = zero dq2 = zero dncount = zero vzmin = cltn vzmax =- cltn kzero = kv call init_trajectory if ( itend0 . gt . 0 ) then do j = 1 , nr ! begin 'rho' cycle do i = 1 , 50 dqi0 ( i , j ) = zero end do call alphas ( dqi0 , vperp , j , kv , galfa ) end do ! end 'rho' cycle end if !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!sign of driven current in right coordinate system {dro,dteta,dfi}: !!!!!curdir=+1.0 for current drive in positive direction \"dfi\" !!!!!curdir=-1.0 for current drive in negative direction \"dfi\" !!!!!spectrum Nz>0 is along dfi>0 and Nz<0 is along dfi<0 !!!!!it is also OK if Npar is used instead of Nz, but for Btor>0, that is along dfi>0 !!      curdir=-dble(ispectr) !!!!!!!!!!!!!!! begin iterations !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! q_rest = plaun iterat = 0 80 continue call manager ( iterat , iw0 , ntet , spectr ) call find_achieved_radial_points ( nvpt ) do j = 1 , nr pdl ( j ) = pdl ( j ) * xwtt pdc ( j ) = pdc ( j ) * xwtt pda ( j ) = pda ( j ) * xwtt pdfast ( j ) = pdfast ( j ) * xwtt pwe ( j + 1 ) = ( pdl ( j ) + pdc ( j )) / vk ( j ) end do pwe ( 1 ) = pwe ( 2 ) pwe ( nr + 2 ) = zero !!   find nevyazka !!---------------------------- psum1 = zero psum2 = zero pchg = zero pchg1 = zero pchg2 = zero do j = 1 , nr dpw1 = pdl ( j ) + pdc ( j ) dpw2 = pda ( j ) psum1 = psum1 + dpw1 ** 2 psum2 = psum2 + dpw2 ** 2 pchg1 = pchg1 + ( dpw1 - pdprev1 ( j )) ** 2 pchg2 = pchg2 + ( dpw2 - pdprev2 ( j )) ** 2 pdprev1 ( j ) = dpw1 pdprev2 ( j ) = dpw2 end do if ( psum1 . ne . zero ) pchg = pchg1 / psum1 !sav2008 if ( psum2 . ne . zero ) pchg = pchg + pchg2 / psum2 !c---------------------------------------- !c     calculate total current and power !c---------------------------------------- cppl = zero cppc = zero cppa = zero cppf = zero do j = 1 , nr cppl = cppl + pdl ( j ) cppc = cppc + pdc ( j ) cppa = cppa + pda ( j ) cppf = cppf + pdfast ( j ) end do ol = cppl * 1 d - 6 oc = cppc * 1 d - 6 oa = cppa * 1 d - 6 of = cppf * 1 d - 6 !!!!!!!!! prepare to the next iteration !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! iterat = iterat + 1 q_abs = ol + oc + oa q_rest = pnab / xsgs q_cond = zero if ( q_abs . ne . zero ) q_cond = 0.5d0 * q_rest / q_abs !!!      if(q_cond.le.pabs0.and.pchg.lt.pgiter) call integral ( 1 , nspl , rh , con , avedens ) iteration_result = IterationResult ( number = iterat , & spectr_direction = ispectr , P_launched = plaun , & P_landau = ol , P_coll = oc , P_alph = oa , & alphas_power = fuspow , P_fast = of , & P_lost = plost / xsgs , P_not_accounted = pnab / xsgs , & P_landau_strong_absorption = ppv1 / xsgs , & P_landau_weak_absorption = ppv2 / xsgs , & P_turns = psum4 / xsgs , efficiency = oi / plaun , & avedens = avedens * 1.d19 , r0 = r0 * 1.d-2 , & eta_eff = 1.d17 * avedens * r0 * oi / plaun , & residual = pchg ) if ( iterat . gt . 5. and . q_cond . le . pabs0 . and . pchg . lt . pgiter ) goto 110 if ( ipri . gt . 1 ) then call iteration_result % print call iteration_result % save ( tcur ) !pause end if if ( iterat . le . niterat ) then call recalculate_f_for_a_new_mesh ( ispectr ) call init_iteration goto 80 end if !c------------------------------------------ !c save results !c------------------------------------------ 110 continue if ( ipri . gt . 0 ) then write ( * , * ) write ( * , * ) 'RAY-TRACING RESULTS:' call iteration_result % print call iteration_result % save ( tcur ) write ( * , * ) '-------------------------------------------' end if !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! k = ( 3 - ispectr ) / 2 do j = 1 , nr r = hr * dble ( j ) vt = fvt ( r ) vto = vt / vt0 vmax = cltn / vto zff = ( 5 d0 + zefff ( r )) / 5 d0 cnyfoc = zff * c0 ** 4 * cnye if ( inew . eq . 0 ) then !vardens pn = fn1 ( r , fnr ) else pn = fn2 ( r , fnr , fnrr ) end if dconst = vt0 / ( 1.d-10 * cnyfoc * pme * pn ** 2 ) !divided by 10&#94;-10 here !!!!!!!!                         and multiplied by 10&#94;-10 in dfind() !!!old       dconst=vt0/(cnyfoc*pme*pn**2) !!!        dj(i)=dql(i,j)*dconst*vto !D_normir do i = 1 , ipt vrj ( i ) = vgrid ( i , j ) / vto !Vpar/Vt dj ( i ) = dql ( i , j ) * dconst * vto !D_normir vrjnew ( i , j , k ) = vrj ( i ) dijk ( i , j , k ) = dj ( i ) end do do i = 1 , i0 if ( vij ( i , j ). ge . vmax ) then ddout = zero else call lock ( vrj , ipt , vij ( i , j ), klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error in output dql' write ( * , * ) 'j=' , j , 'ipt=' , ipt write ( * , * ) 'vrj(1)=' , vrj ( 1 ), ' vrj(ipt)=' , vrj ( ipt ) write ( * , * ) 'i=' , i , ' v=' , vij ( i , j ), ' vmax=' , vmax write ( * , * ) pause 'next key = stop' stop end if !!!         call linf(vrj,dj,vij(i,j),ddout,klo,khi) !!         if(ddout.le.1.d0) ddout=zero ddout = dj ( klo ) end if dij ( i , j , k ) = ddout end do zv1 ( j , k ) = vrj ( ipt1 ) zv2 ( j , k ) = vrj ( ni1 + ni2 + ipt1 ) end do call view ( tcur , ispectr , spectr % size , ntet ) !writing trajectories into a file if ( ismthout . ne . 0 ) then do i = 1 , nrr wrk ( i ) = pwe ( i ) end do call fsmoth4 ( rxx , wrk , nrr , pwe ) end if ! rh ( 1 ) = rh1 if ( rh ( nspl ). gt . 1.d0 ) rh ( nspl ) = 1.d0 do j = 1 , nspl call lock2 ( rxx , nrr , rh ( j ), klo , khi , ierr ) if ( ierr . ne . 0 ) then write ( * , * ) 'lock2 error in profiles for ASTRA' write ( * , * ) 'ierr=' , ierr , ' j=' , j , ' rh(j)=' , rh ( j ) write ( * , * ) 'rxx(1)=' , rxx ( 1 ), ' rxx(nrr)=' , rxx ( nrr ) pause end if call linf ( rxx , pwe , rh ( j ), fout , klo , khi ) outpe ( j ) = fout end do pe_out = ol + oc rh ( 1 ) = zero ! deallocate ( vvj , vdfj ) end subroutine init_iteration use constants , only : zero use rt_parameters , only : itend0 use current use iterator_mod use plasma , only : cltn implicit none ppv1 = zero ppv2 = zero psum4 = zero pnab = zero plost = zero dql = zero dq1 = zero dq2 = zero dncount = zero vzmin = cltn vzmax =- cltn pdl = zero pdc = zero pda = zero pdfast = zero if ( itend0 . gt . 0 ) then dqi0 = zero end if end subroutine gridvel ( v1 , v2 , vmax , cdel , ni1 , ni2 , ipt1 , kpt3 , vrj ) implicit none integer ni1 , ni2 , ipt1 , kpt1 , kpt2 , kpt3 , k double precision vrj ( * ), v1 , v2 , v12 , vmax , cdel kpt1 = ipt1 - 1 kpt2 = ni1 + ni2 + 1 do k = 1 , kpt1 !0<=v<v1 vrj ( k ) = dble ( k - 1 ) * v1 / dble ( kpt1 ) end do v12 = v1 + ( v2 - v1 ) * cdel do k = 1 , ni1 + 1 !v1<=v<=v12 vrj ( k + kpt1 ) = v1 + dble ( k - 1 ) * ( v12 - v1 ) / dble ( ni1 ) end do do k = 2 , ni2 + 1 !!v12<v<=v2 vrj ( k + kpt1 + ni1 ) = v12 + dble ( k - 1 ) * ( v2 - v12 ) / dble ( ni2 ) end do do k = 1 , kpt3 !v2<v<=vmax vrj ( k + kpt1 + kpt2 ) = v2 + dble ( k ) * ( vmax - v2 ) / dble ( kpt3 ) end do end subroutine recalculate_f_for_a_new_mesh ( ispectr ) !!   recalculate f' for a new mesh use constants , only : zero use rt_parameters , only : nr , ni1 , ni2 use plasma , only : vt0 , fvt , cltn use current , only : vzmin , vzmax use maxwell , only : i0 , vij , dfij use lock_module use iterator_mod implicit none integer , intent ( in ) :: ispectr integer i , j , k real ( wp ) :: cdel , dfout integer :: klo , khi , ierr real ( wp ) :: r , hr , vt , vto , vmax real ( wp ) :: v1 , v2 , vp1 , vp2 hr = 1.d0 / dble ( nr + 1 ) k = ( 3 - ispectr ) / 2 do j = 1 , nr r = hr * dble ( j ) vt = fvt ( r ) vto = vt / vt0 if ( iterat . gt . 0 ) then v1 = dmin1 ( vzmin ( j ), vz1 ( j )) v2 = dmax1 ( vzmax ( j ), vz2 ( j )) else v1 = vzmin ( j ) v2 = vzmax ( j ) end if vmax = cltn / vto vp1 = v1 / vto vp2 = v2 / vto call gridvel ( vp1 , vp2 , vmax , cdel , ni1 , ni2 , ipt1 , kpt3 , vrj ) do i = 1 , i0 vvj ( i ) = vij ( i , j ) vdfj ( i ) = dfij ( i , j , k ) !=dfundv(i,j)*vto**2 end do do i = 1 , ipt call lock ( vvj , i0 , vrj ( i ), klo , khi , ierr ) if ( ierr . eq . 1 ) then !!!         if(vrj(i).gt.vvj(i0)) exit write ( * , * ) 'lock error in new v-mesh' write ( * , * ) 'j=' , j , ' i0=' , i0 write ( * , * ) 'vvj(1)=' , vvj ( 1 ), ' vvj(i0)=' , vvj ( i0 ) write ( * , * ) 'i=' , i , ' vrj(i)=' , vrj ( i ) write ( * , * ) pause 'next key = stop' stop end if call linf ( vvj , vdfj , vrj ( i ), dfout , klo , khi ) vgrid ( i , j ) = vrj ( i ) * vto dfundv ( i , j ) = dfout / vto ** 2 if ( dfundv ( i , j ). gt . zero ) dfundv ( i , j ) = zero end do vz1 ( j ) = v1 vz2 ( j ) = v2 end do end subroutine subroutine alphas ( d , u , j , kmax , g ) use decrements , only : dgdu , kzero use constants , only : zero , one implicit real * 8 ( a - h , o - z ) integer , intent ( in ) :: j , kmax dimension d ( 50 , 100 ), u ( 50 , 100 ), g ( 50 , 100 ) !common /arr/ dgdu(50,100),kzero(100) real ( wp ), parameter :: tiny = 1.d-30 integer :: k , km km = kzero ( j ) um = u ( km , j ) if ( um . ge . one ) then do k = 1 , kmax if ( u ( k , j ). lt . one ) then uk = u ( k , j ) uk2 = uk ** 2 w = dsqrt ( one - uk2 ) g ( k , j ) = w / uk2 dgdu ( k , j ) =- one / ( w * uk ) - 2.d0 * w / ( uk * uk2 ) else g ( k , j ) = zero dgdu ( k , j ) = zero end if end do return end if do k = 1 , km uk = u ( k , j ) uk2 = uk ** 2 w = dsqrt ( one - uk2 ) g ( k , j ) = w / uk2 dgdu ( k , j ) =- one / ( w * uk ) - 2.d0 * w / ( uk * uk2 ) end do do k = km + 1 , kmax du = u ( k , j ) - u ( k - 1 , j ) if ( u ( k , j ). lt . one ) then beta = u ( k , j ) * dsqrt ( one - u ( k , j ) ** 2 ) else beta = zero end if alfa = u ( k , j ) ** 3 g ( k , j ) = ( d ( k , j ) * g ( k - 1 , j ) + beta * du ) / ( d ( k , j ) + alfa * du ) if ( d ( k , j ). ne . zero ) then dgdu ( k , j ) = ( beta - alfa * g ( k , j )) / d ( k , j ) else dgdu ( k , j ) = ( g ( k , j ) - g ( k - 1 , j )) / du end if end do do k = 1 , kmax if ( g ( k , j ). lt . tiny ) g ( k , j ) = zero if ( dabs ( dgdu ( k , j )). lt . tiny ) dgdu ( k , j ) = zero end do return end end module lhcd_module","tags":"","loc":"sourcefile\\5_lhcd_module.f90.html"},{"title":"drivencurrent95.f90 – FRTС project","text":"Source Code subroutine drivencurrent95 ( outj , sigmaj , UPL , NRD , NA1 , TIME , TAU , ROC , RTOR , GP2 ) !! ****************************************************************** !!   outj(i)  = LH driven current density, MA/m&#94;2 !!   dndt(i)  = d&#94;2Jr1/dt&#94;2/E, MA/m&#94;2/sec&#94;2/(V/m), ~runaway d(el.density)/dt/E !!   djdt(i)  = dJr2/dt, time drivative of runaway current Jr2, MA/m&#94;2/sec !!   outjrun(i)  = LH driven runaway current density, MA/m&#94;2 !!   outnerun(i) = runaway electron density/10&#94;19 m&#94;-3 !! ****************************************************************** use FokkerPlanck_module use driven_current_module implicit none ! variables imported from ASTRA integer NRD ! NRD     501 - Maximum size of the radial grid integer NA1 ! NA1     Edge grid point number: ROC=RHO(NA1) double precision TIME , TAU , RTOR , ROC , GP2 double precision UPL ( NRD ) real * 8 outj ( NRD ), sigmaj ( NRD ), afld ( NRD ), dtau integer i , inpt , ispectr real * 8 dt , cup , cup0 , cum , cum0 , cp , cm , cp0 , cm0 , aiint real * 8 , parameter :: zero = 0.d0 , eps = 1.d-2 type ( DrivenCurrentResult ) :: rc_result type ( DrivenCurrent ) :: positive_dc type ( DrivenCurrent ) :: negative_dc interface subroutine lhcurrent ( driven_current , ispectr ) use driven_current_module implicit none type ( DrivenCurrent ), intent ( inout ) :: driven_current integer , intent ( in ) :: ispectr end subroutine lhcurrent end interface inpt = NA1 do i = 1 , inpt afld ( i ) = UPL ( i ) / RTOR / GP2 !!variant end do ! ---- starting LH current calculation positive_dc = DrivenCurrent ( NA1 ) negative_dc = DrivenCurrent ( NA1 ) ! ---- positive spectrum: call lhcurrent ( positive_dc , ispectr = 1 ) call positive_dc % evaluate ( ROC ) ! ---- negative spectrum: call lhcurrent ( negative_dc , ispectr = - 1 ) call negative_dc % evaluate ( ROC ) do i = 1 , inpt outj ( i ) = positive_dc % outj ( i ) + negative_dc % outj ( i ) sigmaj ( i ) = zero if ( abs ( afld ( i )). gt . eps ) then sigmaj ( i ) = ( positive_dc % ohj ( i ) + negative_dc % ohj ( i )) / afld ( i ) end if !!!!       write(*,*) i,outj(i) end do rc_result = DrivenCurrentResult ( positive_dc , negative_dc ) call rc_result % print ( time ) call rc_result % save ( time ) call fokkerplanck_compute ( time , TAU ) end subroutine lhcurrent ( driven_current , ispectr ) !subroutine lhcurrent(outj,ohj,cuj,cujoh,inpt,ispectr) !!      implicit real*8 (a-h,o-z) use plasma , only : rh , rh1 , fn1 , fn2 , fvt , sk use lock_module use maxwell use rt_parameters , only : nr , inew use driven_current_module use math_module implicit none type ( DrivenCurrent ), intent ( inout ) :: driven_current integer , intent ( in ) :: ispectr !real*8 outj(*),ohj(*), real * 8 cuj , cujoh , curs , curs0 , curdir real * 8 currn , vt0 , ccur , cfull , cfull0 real * 8 r , pn , fnr , fnrr , vt , vto !,rh1 integer klo , khi , ierr , nrr , i , j , inpt , ismthout !common /a0ab/ nr !real*8 y2dn,y2tm,y2tmi !common /a0l3/ y2dn(501),y2tm(501),y2tmi(501) !integer inew !common /cnew/ inew !est !sav2008 real ( wp ) :: fout !real*8 zv1,zv2 !common/plosh/ zv1(100,2),zv2(100,2)!,sk(100) integer k !parameter(i0=1002) !real*8 vij,fij0,fij,dfij,dij,enorm,fst !common/lh/ vij(i0,100), fij0(i0,100,2), fij(i0,100,2), dfij(i0,100,2), dij(i0,100,2), enorm(100), fst(100) real * 8 , dimension (:), allocatable :: vj , fj , fj0 , cur , cur0 , currnt , rxx , wrk parameter ( ismthout = 1 ) inpt = driven_current % grid_size allocate ( vj ( i0 ), fj ( i0 ), fj0 ( i0 ), cur ( nr ), cur0 ( nr ), currnt ( nr + 2 ), rxx ( nr + 2 ), wrk ( nr + 2 )) !--------------------------------------------------- ! initial constants !--------------------------------------------------- !pqe=4.803e-10 vt0 = fvt ( zero ) ccur = pqe * vt0 * 0.333d-9 curdir =- dble ( ispectr ) cfull = zero cfull0 = zero k = ( 3 - ispectr ) / 2 do j = 1 , nr do i = 1 , i0 vj ( i ) = vij ( i , j ) !Vpar/Vt fj0 ( i ) = fij0 ( i , j , k ) fj ( i ) = fij ( i , j , k ) - fij0 ( i , j , k ) end do r = dble ( j ) / dble ( nr + 1 ) if ( inew . eq . 0 ) then !vardens pn = fn1 ( r , fnr ) else pn = fn2 ( r , fnr , fnrr ) end if vt = fvt ( r ) vto = vt / vt0 curs = currlhcd ( vj , fj ) cur ( j ) = curs * pn * ccur * curdir * vto !Ampere/cm2 cfull = cfull + cur ( j ) * sk ( j ) curs0 = currlhcd ( vj , fj0 ) cur0 ( j ) = curs0 * pn * ccur * curdir * vto !Ampere/cm2 cfull0 = cfull0 + cur0 ( j ) * sk ( j ) end do !cuj=cfull*1d-6   !driven current, MA driven_current % cu = cfull * 1 d - 6 !cujoh=cfull0*1d-6   !driven current, MA driven_current % cu0 = cfull0 * 1 d - 6 !!      write(*,*) !!      write(*,*)'ccur',ccur,' curdir=',curdir,' nr=',nr !!      write(*,*)'cu_out, MA=',cu_out,' cfull, A=',cfull !!           close(111) !      pause currn = cur ( 1 ) ! Jstoped, A/cm&#94;2 currnt ( 1 ) = currn * 1.d-2 ! Jstoped, MA/m&#94;2 rxx ( 1 ) = zero do j = 1 , nr rxx ( j + 1 ) = dble ( j ) / dble ( nr + 1 ) currn = cur ( j ) ! Jstopped, A/cm&#94;2 currnt ( j + 1 ) = currn * 1.d-2 ! Jstoped, MA/m&#94;2 end do nrr = nr + 2 rxx ( nrr ) = 1.d0 currnt ( nr + 2 ) = zero if ( ismthout . ne . 0 ) then do i = 1 , nrr wrk ( i ) = currnt ( i ) end do call fsmoth4 ( rxx , wrk , nrr , currnt ) end if rh ( 1 ) = rh1 if ( rh ( inpt ). gt . 1 d0 ) rh ( inpt ) = 1.d0 do j = 1 , inpt call lock2 ( rxx , nrr , rh ( j ), klo , khi , ierr ) if ( ierr . ne . 0 ) then write ( * , * ) 'lock2 error in current profile for ASTRA' write ( * , * ) 'ierr=' , ierr , ' j=' , j , ' rh(j)=' , rh ( j ) write ( * , * ) 'rxx(1)=' , rxx ( 1 ), ' rxx(nrr)=' , rxx ( nrr ) pause end if call linf ( rxx , currnt , rh ( j ), fout , klo , khi ) driven_current % outj ( j ) = fout end do rh ( 1 ) = zero !------------------------------------------------------ currn = cur0 ( 1 ) ! Jstoped, A/cm&#94;2 currnt ( 1 ) = currn * 1.d-2 ! Jstoped, MA/m&#94;2 rxx ( 1 ) = zero do j = 1 , nr rxx ( j + 1 ) = dble ( j ) / dble ( nr + 1 ) currn = cur0 ( j ) ! Jstopped, A/cm&#94;2 currnt ( j + 1 ) = currn * 1.d-2 ! Jstoped, MA/m&#94;2 end do nrr = nr + 2 rxx ( nrr ) = 1.d0 currnt ( nr + 2 ) = zero if ( ismthout . ne . 0 ) then do i = 1 , nrr wrk ( i ) = currnt ( i ) end do call fsmoth4 ( rxx , wrk , nrr , currnt ) end if rh ( 1 ) = rh1 if ( rh ( inpt ). gt . 1 d0 ) rh ( inpt ) = 1.d0 do j = 1 , inpt call lock2 ( rxx , nrr , rh ( j ), klo , khi , ierr ) if ( ierr . ne . 0 ) then write ( * , * ) '#2 lock2 error in current profile for ASTRA' write ( * , * ) 'ierr=' , ierr , ' j=' , j , ' rh(j)=' , rh ( j ) write ( * , * ) 'rxx(1)=' , rxx ( 1 ), ' rxx(nrr)=' , rxx ( nrr ) pause end if call linf ( rxx , currnt , rh ( j ), fout , klo , khi ) driven_current % ohj ( j ) = fout end do rh ( 1 ) = zero deallocate ( vj , fj , fj0 , cur , cur0 , currnt , rxx , wrk ) end","tags":"","loc":"sourcefile\\drivencurrent95.f90.html"},{"title":"1_runge_kutta.f90 – FRTС project","text":"Source Code module runge_kutta_module use kind_module implicit none abstract interface !    subroutine extd4(x,y,dydx) !    dimension y(*),dydx(*) subroutine Iderivs_func ( x , y , dydx ) import :: wp implicit none real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y (:) real ( wp ), intent ( inout ) :: dydx (:) end subroutine end  interface contains !---------------------------------------------------------------- subroutine rkqc ( y , dydx , n , x , htry , eps , yscal , hdid , hnext , derivs ) use constants , only : one real ( wp ), intent ( inout ) :: y ( n ) real ( wp ), intent ( inout ) :: dydx ( n ) integer , intent ( in ) :: n real ( wp ), intent ( inout ) :: x real ( wp ), intent ( in ) :: htry , eps real ( wp ), intent ( in ) :: yscal ( n ) real ( wp ), intent ( inout ) :: hdid , hnext procedure ( Iderivs_func ) :: derivs !external derivs integer , parameter :: nmax = 10 real ( wp ), parameter :: fcor = . 0666666667 d0 , safety = 0.9d0 , errcon = 6.d-4 integer :: i real ( wp ) :: ytemp ( nmax ), ysav ( nmax ), dysav ( nmax ) real ( wp ) :: pgrow , pshrnk , xsav real ( wp ) :: h , hh , errmax , v print * , 'start rkqc' pgrow =- 0.20d0 pshrnk =- 0.25d0 xsav = x do i = 1 , n ysav ( i ) = y ( i ) dysav ( i ) = dydx ( i ) enddo h = htry 1 hh = 0.5d0 * h call rk4 ( ysav , dysav , n , xsav , hh , ytemp , derivs ) x = xsav + hh call derivs ( x , ytemp , dydx ) call rk4 ( ytemp , dydx , n , x , hh , y , derivs ) x = xsav + h if ( x . eq . xsav ) then write ( * , * ) ' stepsize not significant in rkqc' write ( * , * ) 'xsav=' , xsav , ' h=' , h , ' htry=' , htry write ( * , 88 ) y , dydx pause end if 88 format ( 1 x , 10 ( e14 . 7 , 1 x )) call rk4 ( ysav , dysav , n , xsav , h , ytemp , derivs ) errmax = 0.d0 do i = 1 , n v = ytemp ( i ) ytemp ( i ) = y ( i ) - ytemp ( i ) errmax = dmax1 ( errmax , dabs ( ytemp ( i ) / yscal ( i ))) enddo errmax = errmax / eps if ( errmax . gt . one ) then h = safety * h * ( errmax ** pshrnk ) goto 1 else hdid = h if ( errmax . gt . errcon ) then hnext = safety * h * ( errmax ** pgrow ) else hnext = 4.d0 * h endif endif do i = 1 , n y ( i ) = y ( i ) + ytemp ( i ) * fcor enddo return end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine rk4 ( y , dydx , n , x , h , yout , derivs ) implicit real * 8 ( a - h , o - z ) integer , intent ( in ) :: n procedure ( Iderivs_func ) :: derivs integer nmax , i parameter ( nmax = 10 ) dimension y ( n ), dydx ( n ), yout ( n ), yt ( nmax ), dyt ( nmax ), dym ( nmax ) hh = h * 0.5d0 h6 = h / 6.d0 xh = x + hh do i = 1 , n yt ( i ) = y ( i ) + hh * dydx ( i ) enddo call derivs ( xh , yt , dyt ) dv1 = dyt ( 3 ) do i = 1 , n yt ( i ) = y ( i ) + hh * dyt ( i ) enddo call derivs ( xh , yt , dym ) do i = 1 , n yt ( i ) = y ( i ) + h * dym ( i ) dym ( i ) = dyt ( i ) + dym ( i ) enddo call derivs ( x + h , yt , dyt ) do i = 1 , n yout ( i ) = y ( i ) + h6 * ( dydx ( i ) + dyt ( i ) + 2.d0 * dym ( i )) enddo end !sav2008: below this line there are new subroutins and functions ! пришлось переименовать из rkqs - почему-то криво линковался subroutine runge_kutta_qs ( y , dydx , n , x , htry , eps , yscal , hdid , hnext , derivs ) !! метод рунге-кутта implicit none real ( wp ), intent ( inout ) :: y ( n ) real ( wp ), intent ( inout ) :: dydx ( n ) integer , intent ( in ) :: n real ( wp ), intent ( inout ) :: x real ( wp ), intent ( in ) :: htry , eps real ( wp ), intent ( in ) :: yscal ( n ) real ( wp ), intent ( inout ) :: hdid , hnext procedure ( Iderivs_func ) :: derivs !external derivs !integer,  parameter :: nmax = 50 real ( wp ), parameter :: safety = 0.9d0 , pgrow =- . 2 d0 , pshrnk =- . 25 d0 , errcon = 1.89d-4 integer :: i real ( wp ) :: ytemp ( n ), ysav ( n ), dysav ( n ), yerr ( n ) real ( wp ) :: xsav real ( wp ) :: h , htemp , errmax , xnew h = htry 1 call rkck ( y , dydx , n , x , h , ytemp , yerr , derivs ) errmax = 0.d0 do i = 1 , n errmax = max ( errmax , abs ( yerr ( i ) / yscal ( i ))) enddo errmax = errmax / eps if ( errmax . gt . 1.d0 ) then htemp = safety * h * ( errmax ** pshrnk ) h = sign ( max ( abs ( htemp ), 0.1d0 * abs ( h )), h ) xnew = x + h if ( xnew . eq . x ) pause 'stepsize underflow in rkqs' goto 1 else if ( errmax . gt . errcon ) then hnext = safety * h * ( errmax ** pgrow ) else hnext = 5.d0 * h endif hdid = h x = x + h do i = 1 , n y ( i ) = ytemp ( i ) enddo return endif end subroutine rkck ( y , dydx , n , x , h , yout , yerr , derivs ) !!  метод рунге-кутта, нужны подробности implicit none real ( wp ), intent ( in ) :: y ( n ) real ( wp ), intent ( in ) :: dydx ( n ) integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: h real ( wp ), intent ( out ) :: yerr ( n ) real ( wp ), intent ( out ) :: yout ( n ) procedure ( Iderivs_func ) :: derivs !external derivs !parameter (nmax=50) !cu    uses derivs integer i real ( wp ) ak2 ( n ), ak3 ( n ), ak4 ( n ), ak5 ( n ), ak6 ( n ), ytemp ( n ) real ( wp ) a2 , a3 , a4 , a5 , a6 , b21 , b31 , b32 , b41 , b42 , b43 , b51 , b52 , b53 , & b54 , b61 , b62 , b63 , b64 , b65 , c1 , c3 , c4 , c6 , dc1 , dc3 , dc4 , dc5 , dc6 parameter ( a2 = . 2 d0 , a3 = . 3 d0 , a4 = . 6 d0 , a5 = 1.d0 , a6 = . 875 d0 , b21 = . 2 d0 , b31 = 3.d0 / 4 0.d0 , & b32 = 9.d0 / 4 0.d0 , b41 = . 3 d0 , b42 =- . 9 d0 , b43 = 1.2d0 , b51 =- 1 1.d0 / 5 4.d0 , b52 = 2.5d0 , & b53 =- 7 0.d0 / 2 7.d0 , b54 = 3 5.d0 / 2 7.d0 , b61 = 163 1.d0 / 5529 6.d0 , b62 = 17 5.d0 / 51 2.d0 , & b63 = 57 5.d0 / 1382 4.d0 , b64 = 4427 5.d0 / 11059 2.d0 , b65 = 25 3.d0 / 409 6.d0 , c1 = 3 7.d0 / 37 8.d0 , & c3 = 25 0.d0 / 62 1.d0 , c4 = 12 5.d0 / 59 4.d0 , c6 = 51 2.d0 / 177 1.d0 , dc1 = c1 - 282 5.d0 / 2764 8.d0 , & dc3 = c3 - 1857 5.d0 / 4838 4.d0 , dc4 = c4 - 1352 5.d0 / 5529 6.d0 , dc5 =- 27 7.d0 / 1433 6.d0 , dc6 = c6 - . 25 d0 ) do i = 1 , n ytemp ( i ) = y ( i ) + b21 * h * dydx ( i ) enddo call derivs ( x + a2 * h , ytemp , ak2 ) do i = 1 , n ytemp ( i ) = y ( i ) + h * ( b31 * dydx ( i ) + b32 * ak2 ( i )) enddo call derivs ( x + a3 * h , ytemp , ak3 ) do i = 1 , n ytemp ( i ) = y ( i ) + h * ( b41 * dydx ( i ) + b42 * ak2 ( i ) + b43 * ak3 ( i )) enddo call derivs ( x + a4 * h , ytemp , ak4 ) do i = 1 , n ytemp ( i ) = y ( i ) + h * ( b51 * dydx ( i ) + b52 * ak2 ( i ) + b53 * ak3 ( i ) + b54 * ak4 ( i )) enddo call derivs ( x + a5 * h , ytemp , ak5 ) do i = 1 , n ytemp ( i ) = y ( i ) + h * ( b61 * dydx ( i ) + b62 * ak2 ( i ) + b63 * ak3 ( i ) + b64 * ak4 ( i ) + b65 * ak5 ( i )) enddo call derivs ( x + a6 * h , ytemp , ak6 ) do i = 1 , n yout ( i ) = y ( i ) + h * ( c1 * dydx ( i ) + c3 * ak3 ( i ) + c4 * ak4 ( i ) + c6 * ak6 ( i )) enddo do i = 1 , n yerr ( i ) = h * ( dc1 * dydx ( i ) + dc3 * ak3 ( i ) + dc4 * ak4 ( i ) + dc5 * ak5 ( i ) + dc6 * ak6 ( i )) enddo return end end module runge_kutta_module","tags":"","loc":"sourcefile\\1_runge_kutta.f90.html"},{"title":"3_current_and_power.f90 – FRTС project","text":"Source Code module current use kind_module implicit none real ( wp ) :: dql ( 101 , 100 ) !! real ( wp ) :: pdl ( 100 ) !! real ( wp ) :: vzmin ( 100 ) !! real ( wp ) :: vzmax ( 100 ) !common /a0i3/ dql(101,100),pdl(100),vzmin(100),vzmax(100) real ( wp ) :: fcoll ( 100 ) real ( wp ) :: dens ( 100 ) real ( wp ) :: eta ( 100 ) !common /a0i4/ fcoll(100),dens(100),eta(100) real ( wp ) :: dq1 ( 101 , 100 ) real ( wp ) :: dq2 ( 101 , 100 ) real ( wp ) :: pdc ( 100 ) real ( wp ) :: pda ( 100 ) real ( wp ) :: ppv1 , ppv2 !common/vvv1/dq1(101,100),dq2(101,100),pdc(100),pda(100),ppv1,ppv2 real ( wp ) :: pdfast ( 100 ) !common /vvv3/ pdfast(100) real ( wp ) :: dqi0 ( 50 , 100 ) !common /alph/ dqi0(50,100) real ( wp ) :: dncount ( 101 , 100 ) !common/findsigma/dncount(101,100) contains subroutine find_achieved_radial_points ( nvpt ) !!  find achieved radial points jbeg-jend use rt_parameters , only : nr implicit none integer , intent ( in ) :: nvpt integer i , j , jbeg , jend , nvmin , nvach nvmin = 1 !minimum counted events at a given radius rho jbeg = 1 jend = 0 do j = 1 , nr nvach = 0 do i = 1 , nvpt nvach = nvach + dncount ( i , j ) end do if ( nvach . lt . nvmin ) then if ( jend . eq . 0 ) jbeg = jbeg + 1 else jend = j end if end do if ( jend . eq . 0. or . jbeg . ge . jend ) then write ( * , * ) 'failure: jbeg=' , jbeg , ' jend=' , jend pause stop end if end subroutine subroutine dfind ( j , i , v , powpr , pil , pic , pia , df , decv , refr , vlf , vrt , ifast ) use constants use plasma use rt_parameters implicit none integer , intent ( in ) :: i , j , ifast real ( wp ), intent ( in ) :: v , powpr , pil , pic , pia , df , decv , refr , vlf , vrt integer k real ( wp ) :: pchgl , pchgc , pchga , denom , powlandau , powdamped real ( wp ) :: fff , dd , domin , parn , dvz , dnpar , weight , addd real ( wp ) :: arg , hevis , adda !common /a0i3/ dql(101,100),pdl(100),vzmin(100),vzmax(100) !common /a0i4/ fcoll(100),dens(100),eta(100) !common/vvv1/dq1(101,100),dq2(101,100),pdc(100),pda(100),ppv1,ppv2 !common /vvv3/ pdfast(100) !common /alph/ dqi0(50,100) !common/findsigma/dncount(101,100) real ( wp ), parameter :: absorption_tiny = 1.d-20 if ( v . gt . cltn ) return if ( pil . gt . zero ) then if ( v . lt . vzmin ( j )) vzmin ( j ) = v if ( v . gt . vzmax ( j )) vzmax ( j ) = v end if pchgl = zero pchgc = zero pchga = zero denom = pil + pic + pia powlandau = 1.d0 - dexp ( - 2.d0 * pil ) powdamped = 1.d0 - dexp ( - 2.d0 * denom ) domin = powpr * powdamped if ( denom . ne . zero ) then !!       pchgl=powpr*(1.d0-dexp(-2d0*pil)) !!       pchgc=powpr*dexp(-2d0*pil)*dabs(-2d0*pic) !!       pchga=powpr*dexp(-2d0*pil)*dabs(-2d0*pia) fff = domin / denom pchgl = dabs ( pil * fff ) pchgc = dabs ( pic * fff ) pchga = dabs ( pia * fff ) end if dd = zero if ( pil . eq . zero ) go to 1 !no Landau absorption if ( powlandau . gt . pchm ) then !strong absorption ppv1 = ppv1 + pchgl if ( dabs ( df ). gt . absorption_tiny ) then dd = dabs ( - pchgl / vk ( j ) / ( df * 1.d10 )) dncount ( i , j ) = dncount ( i , j ) + 1.d0 else dd = zero end if dq1 ( i , j ) = dq1 ( i , j ) + dd else ! weak absorption ppv2 = ppv2 + pchgl dd = dabs ( 2.d0 * decv * powpr * 1.d-10 / vk ( j )) dncount ( i , j ) = dncount ( i , j ) + 1.d0 dq2 ( i , j ) = dq2 ( i , j ) + dd end if 1 continue dql ( i , j ) = dql ( i , j ) + dd pdl ( j ) = pdl ( j ) + pchgl pdc ( j ) = pdc ( j ) + pchgc pda ( j ) = pda ( j ) + pchga if ( ifast . eq . - 1 ) pdfast ( j ) = pdfast ( j ) + pchgl + pchgc + pchga if ( itend0 . gt . 0 ) then parn = cltn / v dvz = vrt - vlf dnpar = cltn * dvz / v ** 2 weight = ( refr ** 2 - eta ( j )) ** 2 / ( refr ** 2 * parn ** 3 ) !!!        adde=zze*(dd/dens(j))*weight !!!        e2perp(i,j)=e2perp(i,j)+adde addd = zza * ( dd / dens ( j )) * weight / fcoll ( j ) / refr ** 3 arg = clt / ( refr * valfa ) do k = 1 , kv if ( vperp ( k , j ). gt . arg ) then hevis = dsqrt (( vperp ( k , j ) - arg ) * ( vperp ( k , j ) + arg )) adda = addd * hevis dqi0 ( k , j ) = dqi0 ( k , j ) + adda * dnpar end if end do end if return end end module current module power implicit none contains end module power","tags":"","loc":"sourcefile\\3_current_and_power.f90.html"},{"title":"1_lock_module.f90 – FRTС project","text":"Source Code module lock_module use kind_module implicit none contains !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine linf ( x , y , t , fout , klo , khi ) !! линейная аппроксимация !! TODO будет удобнее если переделать в функцию implicit none real ( wp ), intent ( in ) :: x ( * ), y ( * ), t real ( wp ), intent ( out ) :: fout integer , intent ( in ) :: klo , khi real ( wp ) :: dout dout = ( y ( khi ) - y ( klo )) / ( x ( khi ) - x ( klo )) fout = y ( klo ) + dout * ( t - x ( klo )) end subroutine lock ( xa , n , x , klo , khi , ierr ) !! что делает? implicit none real ( wp ), intent ( in ) :: xa ( * ), x integer , intent ( in ) :: n integer , intent ( inout ) :: klo , khi , ierr real ( wp ), parameter :: tiny = 1.d-14 integer :: k real ( wp ) :: dx1 , dx2 klo = 0 khi = 0 dx1 = x - xa ( 1 ) dx2 = x - xa ( n ) if ( dx1 * dx2 . ge . tiny ) then ierr = 1 return end if ierr = 0 klo = 1 khi = n do while ( khi - klo . gt . 1 ) k = ( khi + klo ) / 2 if ( xa ( k ). gt . x ) then khi = k else klo = k endif end do if ( khi . eq . klo ) ierr = 1 end subroutine lock2 ( xa , n , x , klo , khi , ierr ) !! что делает use constants , only : zero implicit none real ( wp ), intent ( in ) :: xa ( * ), x integer , intent ( in ) :: n integer , intent ( inout ) :: klo , khi , ierr real ( wp ), parameter :: tiny = 1.d-7 integer :: k real ( wp ) :: dx1 , dx2 ierr = 0 klo = 0 khi = 0 dx1 = x - xa ( 1 ) if ( abs ( dx1 ). lt . tiny ) then klo = 1 khi = 2 return else if ( dx1 . lt . zero ) then ierr = 1 return end if dx2 = x - xa ( n ) if ( abs ( dx2 ). lt . tiny ) then klo = n - 1 khi = n return else if ( dx2 . gt . zero ) then ierr = 2 return end if klo = 1 khi = n do while ( khi - klo . gt . 1 ) k = ( khi + klo ) / 2 if ( xa ( k ). gt . x ) then khi = k else klo = k endif end do if ( khi . eq . klo ) ierr = 3 end end module lock_module","tags":"","loc":"sourcefile\\1_lock_module.f90.html"},{"title":"1_constants.f90 – FRTС project","text":"Source Code module constants !! модуль с математическими и физическими константами !! nt_001 тестовый комментарий use kind_module implicit none real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: two = 2.0_wp real ( wp ), parameter :: one_third = 1.0_wp / 3.0_wp real ( wp ), parameter :: tiny = 1.e-100_wp real ( wp ), parameter :: tiny1 = 1e-7_wp real ( wp ), parameter :: pi = acos ( - one ) !! число Пи = 3.1415.... real ( wp ), parameter :: pi2 = 2.0_wp * pi real ( wp ), parameter :: pi4 = 4.0_wp * pi real ( wp ), parameter :: piq = sqrt ( pi ) real ( wp ), parameter :: pisqrt = sqrt ( pi ) real ( wp ), parameter :: pi2sqrt = sqrt ( pi2 ) !pi2sqrt=2.506628274631d0,pisqrt=1.77245385090552d0) real ( wp ), parameter :: talfa = 3.5_wp !! alpha particles' birth energy, MeV real ( wp ), parameter :: zalfa = 2.0_wp !! alpha particles' electrical charge real ( wp ), parameter :: xmalfa = 4.0_wp !! alpha particles' atomic mass real ( wp ), parameter :: clt = 3.0e+10_wp !! скорость света real ( wp ), parameter :: pme = 9.11e-28_wp real ( wp ), parameter :: pme_e = 9.11e-28 real ( wp ), parameter :: pqe = 4.803e-10_wp real ( wp ), parameter :: xlog = 1 6.0_wp + dlog ( 1 6.0_wp ) real ( wp ), parameter :: c0 = sqrt ( pi4 * pqe ** 2 / pme ) real ( wp ), parameter :: c1 = pqe / pme / clt real ( wp ), parameter :: xsgs = 1e+13_wp !! 1MW = 1e13 erg/s real ( wp ), parameter :: xwtt = 1e-7_wp real ( wp ), parameter :: cnst1 = 0.2965924106e-6_wp !! cnst1=(m_e/m_p)**2, CGS real ( wp ), parameter :: cnst2 = 0.359680922e-35_wp !! cnst2=(m_e/e)**2,  CGS contains subroutine show_constants () print * , '---------------------------------------' print * , \"zero       = \" , zero print * , \"one        = \" , one print * , \"two        = \" , two print * , \"one_third  = \" , one_third print * , \"tiny       = \" , tiny print * , \"tiny1      = \" , tiny1 print * print * , \"4*ATAN     = \" , 4.d0 * datan ( 1.d0 ) print * , \"pi         = \" , pi print * , \"pi2        = \" , pi2 print * , \"pi4        = \" , pi4 print * , \"piq        = \" , piq print * print * , \"talfa      = \" , talfa print * , \"zalfa      = \" , zalfa print * , \"xmalfa     = \" , xmalfa print * , \"clt        = \" , clt print * print * , \"pme_e      = \" , pme_e print * , \"pme        = \" , pme print * , \"9.11d-28   = \" , 9.11d-28 print * , \"pqe        = \" , pqe print * , \"xlog       = \" , xlog print * , \"c0         = \" , c0 print * , \"c1         = \" , c1 print * , \"xsgs       = \" , xsgs print * , \"xwtt       = \" , xwtt print * print * , \"cnst1  = \" , cnst1 print * , \"cnst2  = \" , cnst2 print * , '---------------------------------------' end subroutine show_constants end module constants","tags":"","loc":"sourcefile\\1_constants.f90.html"},{"title":"1_rt_parameters.f90 – FRTС project","text":"Source Code module rt_parameters use kind_module implicit none !   physical parameters real ( wp ) :: freq !! Freq,     RF frequency, GHz real ( wp ) :: xmi1 !!  Mi1/Mp,  relative mass of ions 1 real ( wp ) :: zi1 !! charge of ions 1 real ( wp ) :: xmi2 !! Mi2/Mp,  relative mass of ions 2 real ( wp ) :: zi2 !! charge of ions 2 real ( wp ) :: dni2 !!  0.03   Ni2/Ni1, relative density of ions 2 real ( wp ) :: xmi3 !!  Mi3/Mp,  relative mass of ions 3 real ( wp ) :: zi3 !!  charge of ions 3 real ( wp ) :: dni3 !!  Ni3/Ni1, relative density of ions 3 !!!!!!!!!!!!!  parameters for alphas calculations !!! integer :: itend0 !! itend0,   if = 0, no alphas real ( wp ) :: energy !! energy,   max. perp. energy of alphas (MeV) real ( wp ) :: factor !! factor,   factor in alpha source real ( wp ) :: dra !! dra,      relative alpha source broadening (dr/a) integer :: kv !! kv,       V_perp  greed number !!!!!!!!!!!!! numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! integer :: nr !! nr,  radial grid number  <= 505 real ( wp ) :: hmin1 !! hmin1, rel.(hr) min. step in the Fast comp. mode, <1.d0 real ( wp ) :: rrange !! rrange,   rel.(hr) size of a 'turning' point region, <1.d0 real ( wp ) :: eps , eps_const !! eps,      accuracy real ( wp ) :: hdrob !! hdrob,    h4 correction, real ( wp ) :: cleft !! cleft,    left Vz plato border shift (<1) real ( wp ) :: cright !! cright,   right Vz plato border shift (>1) real ( wp ) :: cdel !! cdel,     (left part)/(Vz plato size) real ( wp ) :: rbord !! rbord,    relative radius of reflection, <1. real ( wp ) :: pchm !! pchm,     threshold between 'strong' and weak' absorption, <1. real ( wp ) :: pabs0 !! pabs,     part of remaining power interp. as absorption real ( wp ) :: pgiter !! pgiter,   relative accuracy to stop iterations integer :: ni1 !! ni1,      grid number in the left part of Vz plato integer :: ni2 !! ni2,      grid number in the right part of Vz plato integer :: niterat !! niterat,  maximal number of iterations integer :: nmaxm ( 4 ) !! nmaxm(1), permitted reflections at 0 iteration !! nmaxm(2), permitted reflections at 1 iteration !! nmaxm(3), permitted reflections at 2 iteration !! nmaxm(4), permitted reflections at 3 iteration integer :: maxstep2 !! maxstep2, maximal steps' number in Fast comp. mode integer :: maxstep4 !! maxstep4, maximal steps' number in Slow comp. mode !!!!!!!!!!!!!  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! integer :: ipri !! ipri, printing output monitoring: 0,1,2,3,4 integer :: iw !! iw, initial mode (slow=1, fast=-1) integer :: ismth !! ismth, if=0, no smoothing in Ne(rho),Te(rho),Ti(rho) integer :: ismthalf !! ismthalf,  if=0, no smoothing in D_alpha(vperp) integer :: ismthout !! ismthout,  if=0, no smoothing in output profiles integer :: inew !! inew=0 for usual tokamak&Ntor_grill; 1 or 2 for g' in ST&Npol_grill integer :: itor !! itor,      +-1, Btor direction in right coord{drho,dteta,dfi} integer :: i_pol !! ipol,      +-1, Bpol direction in right coord{drho,dteta,dfi} !!!!!!!!!!!!!  grill parameters and input LH spectrum !!!!!!!!!!!! real ( wp ) :: zplus !! Zplus,    upper grill corner in centimeters real ( wp ) :: zminus !! Zminus,   lower grill corner in centimeters integer :: ntet !! ntet,     theta grid number integer :: nnz !! nnz,      N_phi grid number integer :: spectrum_type !! spectrum type 1 - 1D, 2 = 2D, 3, scatter contains subroutine show_parameters () print * , \"Freq = \" , freq print * , \"xmi1 = \" , xmi1 print * , \"zi1 = \" , zi1 print * , \"xmi2 = \" , xmi2 print * , \"zi2 = \" , zi2 print * , \"dni2 = \" , dni2 print * , \"---------- grill parameters and input LH spectrum \" print * , \"zplus = \" , zplus print * , \"zminus = \" , zminus print * , \"ntet = \" , ntet print * , \"nnz = \" , nnz end subroutine show_parameters subroutine read_parameters ( file_name ) implicit none integer , parameter :: iunit = 20 character ( * ) file_name print * , file_name open ( iunit , file = file_name ) !!!!!!!!!!!!!  read  physical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) freq read ( iunit , * ) xmi1 read ( iunit , * ) zi1 read ( iunit , * ) xmi2 read ( iunit , * ) zi2 read ( iunit , * ) dni2 read ( iunit , * ) xmi3 read ( iunit , * ) zi3 read ( iunit , * ) dni3 !!!!!!!!!!!!!  read parameters for alphas calculation !!!!!!!!!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) itend0 read ( iunit , * ) energy read ( iunit , * ) factor read ( iunit , * ) dra read ( iunit , * ) kv !!!!!!!!!!!!!  read  numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) nr read ( iunit , * ) hmin1 read ( iunit , * ) rrange read ( iunit , * ) eps eps_const = eps read ( iunit , * ) hdrob read ( iunit , * ) cleft read ( iunit , * ) cright read ( iunit , * ) cdel read ( iunit , * ) rbord read ( iunit , * ) pchm read ( iunit , * ) pabs0 read ( iunit , * ) pgiter read ( iunit , * ) ni1 read ( iunit , * ) ni2 read ( iunit , * ) niterat read ( iunit , * ) nmaxm ( 1 ) read ( iunit , * ) nmaxm ( 2 ) read ( iunit , * ) nmaxm ( 3 ) read ( iunit , * ) nmaxm ( 4 ) read ( iunit , * ) maxstep2 read ( iunit , * ) maxstep4 !!!!!!!!!!!!!  read  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) ipri read ( iunit , * ) iw read ( iunit , * ) ismth read ( iunit , * ) ismthalf read ( iunit , * ) ismthout read ( iunit , * ) inew read ( iunit , * ) itor !Btor direction in right-hand {drho,dteta,dfi} read ( iunit , * ) i_pol !Bpol direction in right-hand {drho,dteta,dfi} !!!!!!!!!!!!!  read grill parameters and input LH spectrum !!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) zplus read ( iunit , * ) zminus read ( iunit , * ) ntet read ( iunit , * ) nnz read ( iunit , * ) spectrum_type close ( iunit ) print * , 'checking initial parameters' !!!!!!!!!!!!! checking initial parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( kv . gt . 50 ) kv = 50 if ( nr . gt . 100 ) nr = 100 if ( ni1 . eq . 0 ) ni1 = 20 if ( ni2 . eq . 0 ) ni2 = 20 if ( ni1 + ni2 . gt . 100 ) then ni1 = 60 ni2 = 40 end if if ( nnz * ntet . gt . 10000 ) then nnz = 250 ntet = 40 pause 'nnz and ntet changed, because nnz*ntet>10000' end if call show_parameters end subroutine read_parameters end module rt_parameters","tags":"","loc":"sourcefile\\1_rt_parameters.f90.html"},{"title":"3_driver_module.f90 – FRTС project","text":"Source Code module driver_module use kind_module implicit none integer , parameter :: length = 5000000 !real(wp) dland(length),dcoll(length),perpn(length),dalf(length) !real(wp) vel(length),tetai(length) !real(wp) xnpar(length) !real(wp) :: rho(length) !integer izz(length),iww(length),jrad(length) !!common/agh/xnpar,vel,dland,dcoll,dalf,perpn,tetai,jrad,iww,izz integer :: irs !common /abcd/ irs integer :: iabsorp !common /abcdg/ iabsorp real ( wp ) :: rzz , tetzz , xmzz !!common /abc/ rzz,tetzz,xmzz integer :: iznzz , iwzz , irszz !!common /abc/ iznzz,iwzz,irszz real ( wp ) :: hrad !common /bcg/ hrad integer :: ind !common /cmn/ ind integer :: im4 !common /bg/ im4 real ( wp ) :: pow !!common /acg/ pow !integer     :: inak, lenstor, lfree !common /ag/ inak,lenstor,lfree real ( wp ) :: pintld4 , pintcl4 , pintal4 !common /dg/ pintld4,pintcl4,pintal4 !real(wp)    ::  vthc(length),poloidn(length) !common /vth/ vthc(length),poloidn(length) contains subroutine memorize_trajectory_point4 ( ro , theta ) use decrements , only : vfound use decrements , only : cf2 use rt_parameters , only : nr implicit none real ( wp ), intent ( in ) :: ro , theta integer jf jf = idnint ( ro / hrad ) cf2 = theta if ( jf . le . 0 ) jf = 1 if ( jf . gt . nr ) jf = nr call memorize_trajectory_point ( vfound , jf , ro , 1 d0 , 4 ) end subroutine subroutine memorize_trajectory_point ( vz , j , ro , powccc , driver ) !!  memorize trajectory point use plasma , only : fvt use decrements , only : cf1 , cf2 , cf3 , cf6 use decrements , only : icf1 , icf2 use dispersion_module , only : ipow use decrements , only : pdecv , pdecal use trajectory_data implicit none type ( TrajectoryPoint ) :: tp real ( wp ), intent ( in ) :: vz , ro , powccc integer , intent ( in ) :: j , driver real ( wp ) :: radth !inak=inak+1 !if(inak.eq.lenstor) then !write(*,*)'storage capacity exceeded !' !iabsorp=-1 !inak=lenstor-1 !return !end if tp % vel = vz tp % rho = ro tp % perpn = cf1 !refr tp % poloidn = cf6 !npoloid tp % tetai = cf2 ! tet_i radth = dble ( j ) / dble ( 31 ) tp % vthc = 3.d10 / fvt ( radth ) tp % iww = icf1 ! было ifast tp % izz = icf2 ! было idir tp % xnpar = cf3 !было xparn tp % driver = driver if ( im4 . eq . 1 ) then tp % jrad = - j tp % dland = pintld4 tp % dcoll = pintcl4 tp % dalf = pintal4 im4 = 0 call current_trajectory % add_point ( tp ) return end if tp % jrad = j tp % dland = pdecv tp % dalf = pdecal if ( ipow . ne . 1 ) tp % dcoll = powccc if ( ipow . eq . 1 ) tp % dcoll = 1 d0 call current_trajectory % add_point ( tp ) end subroutine subroutine driver2 ( ystart , x1 , x2 , xsav , hmin , h1 , pabs ) !sav2008 !! solve eqs. starting from xbeg !! ystart(1) = tet !! ystart(2) = xm !! x1 = xbeg rini !! x2 = xend use constants , only : zero , tiny1 use rt_parameters , only : nr , ipri , rbord , maxstep2 , hmin1 , iw , eps use decrements , only : ifound , vfound use dispersion_module , only : ipow , jfoundr , iconv , irefl , izn use dispersion_equation , only : ynz implicit none real ( wp ), intent ( inout ) :: ystart ( 2 ) real ( wp ), intent ( in ) :: x1 real ( wp ), intent ( inout ) :: x2 , xsav real ( wp ), intent ( in ) :: hmin , h1 real ( wp ), intent ( in ) :: pabs !common /abc/ rzz,tetzz,xmzz,iznzz,iwzz,irszz !common /abcd/ irs !common /abcdg/ iabsorp !common /bcef/ ynz,ynpopq !common /bcg/ hrad !integer :: ind !common /cmn/ ind integer , parameter :: nvar = 2 real ( wp ) :: yscal ( nvar ), y ( nvar ), dydx ( nvar ), yold ( nvar ), dyold ( nvar ) real ( wp ) :: x , xold real ( wp ) :: h , hsav , hdid , hnext real ( wp ) :: dstsav , dyd , dst3 , dst2 , dst1 real ( wp ) :: ynz0 !!!!!! проверить значение real ( wp ) :: powccc integer :: i , ii , irep , nstp x = x1 h = dsign ( h1 , x2 - x1 ) ind = 0 ipow = 1 xold = x hsav = hrad * irs hdid = zero do i = 1 , nvar y ( i ) = ystart ( i ) yold ( i ) = y ( i ) end do !-------------- start moving ------------- do nstp = 1 , maxstep2 !--------- netpoint control ----------- dstsav = 0 !dabs(x-xsav) if ( dstsav . lt . tiny1 ) then ipow = ipow + 2 jfoundr = idnint ( x / hrad ) if ( jfoundr . le . 0 ) jfoundr = 1 if ( jfoundr . gt . nr ) jfoundr = nr end if call extd2 ( x , y , dydx ) irep = 0 if ( iconv + irefl . ne . 0 ) then ! if(iconv+irefl.ne.0.or.ynz.lt.0.d0) then !--------------------------------------------- ! made step to nontransparent zone-return back !---------------------------------------------- x = xold do ii = 1 , nvar y ( ii ) = yold ( ii ) dydx ( ii ) = dyold ( ii ) end do irep = 1 h = hdid / 2 hdid = h ipow = 0 if ( dabs ( h ). lt . hmin1 ) then ind = 3 go to 20 end if ynz = ynz0 go to 10 end if !c-------------------------------------- !c memorize step data !c-------------------------------------- xold = x do i = 1 , nvar dyd = dabs ( dydx ( i )) yscal ( i ) = dabs ( y ( i )) + dabs ( h * dyd ) + 1.d-30 / ( 1.d0 + dyd ) yold ( i ) = y ( i ) dyold ( i ) = dydx ( i ) end do ynz0 = ynz if ( ipow . gt . 0 ) then !integrate power equation powccc = dql1 ( ifound , jfoundr , pabs ) ! ----------------------------------- !      memorize trajectory ! ---------------------------------- call memorize_trajectory_point ( vfound , jfoundr , x , powccc , 2 ) if ( iabsorp . eq . 1 ) then !absorption rzz = x tetzz = y ( 1 ) xmzz = y ( 2 ) iznzz = izn iwzz = iw irszz = irs return end if if ( iabsorp . eq . - 1 ) return !problem ipow = 0 xsav = xsav - hsav end if !c-------------------------------------- !c choose step size !c-------------------------------------- dst3 = ( x - xsav ) * ( x + h - xsav ) if ( dst3 . lt . zero . and . irep . eq . 0 ) h = xsav - x if ( x . gt . rbord . and . h . gt . zero ) then ind = 2 go to 20 end if 10 dst1 = ( x - rbord ) * ( x + h - rbord ) dst2 = x * ( x + h ) if (( dst1 . lt . zero . and . irs . eq . - 1 ). or . dst2 . lt . zero ) then h = h / 2.d0 if ( dabs ( h ). lt . hmin1 ) then ind = 4 go to 20 end if go to 10 end if !c-------------------------------------- !c find solution at x=x+hdid !c--------------------------------------- ynz0 = ynz call difeq ( y , dydx , nvar , x , h , eps , yscal , hdid , hnext , extd2 ) 20 continue if ( ind . ne . 0 ) then !exit xsav = xsav + hsav x2 = x do i = 1 , nvar ystart ( i ) = y ( i ) end do ynz = ynz0 return end if !c--------------------------------------- if ( dabs ( hnext ). lt . hmin ) then if ( ipri . gt . 1 ) write ( * , * ) 'exit driver2: step is too small' go to 40 end if h = hnext end do !c--------------------------------------- if ( ipri . gt . 1 ) write ( * , * ) 'error in driver2: too many steps' 40 iabsorp =- 1 return 1001 format ( 10 ( e14 . 7 , 1 x )) end subroutine extd2 ( x , y , dydx ) use dispersion_module , only : disp2 implicit none real ( wp ), intent ( in ) :: x ! ro real ( wp ), intent ( in ) :: y (:) ! theta, yn2 real ( wp ), intent ( inout ) :: dydx (:) real ( wp ) :: tt , xm real ( wp ) :: xnr , prt , prm tt = y ( 1 ) xm = y ( 2 ) !print *,'extd2' call disp2 ( x , xm , tt , xnr , prt , prm ) !print *,'extd2 after' !pause dydx ( 1 ) =- prm dydx ( 2 ) = prt end function dql1 ( ifound , jfoundr , pabs ) result ( powccc ) use constants , only : clt , zero use rt_parameters , only : itend0 , kv use plasma , only : fvt , vperp use current , only : dfind use dispersion_module , only : ipow use decrements , only : vfound use decrements , only : cf1 , cf2 , cf3 , cf4 , cf5 , cf6 use decrements , only : icf1 , icf2 use iterator_mod , only : vlf , vrt , dflf , dfrt use decrements , only : zatukh ! function zatukh(psy,j,u,n) use decrements , only : pdec1 , pdec2 , pdec3 , pdecv , pdecal , dfdv implicit none integer , intent ( in ) :: ifound , jfoundr real ( wp ), intent ( in ) :: pabs real ( wp ) :: radth integer :: i , j , ifast , idir real ( wp ) :: powpr , hdis , vz , refr real ( wp ) :: dek3 , dfsr real ( wp ) :: vsr , pintld , pintcl , argum , valfa real ( wp ) :: pintal , dcv , powd , powccc , powcol , powal real ( wp ) :: pil , pic , pia powpr = pow iabsorp = 0 hdis = hrad vz = vfound i = ifound if ( i . eq . 0 ) i = 1 j = jfoundr refr = cf1 !tet_i=cf2 !npoloid=cf6 !xparn=cf3 ifast = icf1 idir = icf2 dek3 = zero dfsr = ( vlf * dflf + vrt * dfrt ) / 2 d0 * ( vrt - vlf ) vsr = ( vrt + vlf ) * ( vrt - vlf ) / 2 d0 !c-------------------------------------- !c   find power !c-------------------------------------- if ( im4 . eq . 1 ) then !!       pintld=-pintld4*dfdv pintld = dabs ( pintld4 * dfdv ) pintcl = dabs ( pintcl4 ) if ( itend0 . gt . 0 ) then argum = clt / ( refr * valfa ) dek3 = zatukh ( argum , j , vperp , kv ) end if pintal = dabs ( pintal4 * dek3 ) dcv = pintld4 / vsr else pintld = dabs ( pdec1 * hdis ) pintcl = dabs ( pdec2 * hdis ) pintal = dabs ( pdec3 * hdis ) dcv = pdecv * hdis / vsr end if if ( pabs . ne . zero ) then powd = pow * dexp ( - 2 d0 * pintld ) powccc = dexp ( - 2 d0 * pintcl ) powcol = powd * powccc powal = powcol * dexp ( - 2 d0 * pintal ) pow = powal end if if ( pow . le . pabs ) iabsorp = 1 pil = pintld pic = pintcl pia = pintal call dfind ( j , i , vz , powpr , pil , pic , pia , dfsr , dcv & , refr , vlf , vrt , ifast ) end function subroutine difeq ( y , dydx , nv , x , htry , eps , yscal , hdid , hnext , derivs ) use rt_parameters , only : hmin1 use runge_kutta_module , only : Iderivs_func implicit none real ( wp ), intent ( inout ) :: y ( nv ) real ( wp ), intent ( in ) :: dydx ( nv ) integer , intent ( in ) :: nv real ( wp ), intent ( inout ) :: x real ( wp ), intent ( in ) :: htry real ( wp ), intent ( in ) :: eps real ( wp ), intent ( inout ) :: yscal ( nv ) real ( wp ), intent ( inout ) :: hdid real ( wp ), intent ( inout ) :: hnext !external derivs procedure ( Iderivs_func ) :: derivs real ( wp ) :: dysav ( nv ) !sav# integer , parameter :: nmax = 50 , kmaxx = 8 , imax = kmaxx + 1 real ( wp ), parameter :: safe1 = . 25 d0 , safe2 = . 7 d0 real ( wp ), parameter :: redmax = 1.d-5 , redmin = . 7 d0 real ( wp ), parameter :: tiny = 1.d-30 , scalmx = . 1 d0 !cu    uses derivs,mmid,pzextr integer :: i , iq , k , kk , km , kmax , kopt , nseq ( imax ) real ( wp ) :: eps1 , epsold , errmax , fact , h , red , scale , work , wrkmin real ( wp ) :: xest , xnew real ( wp ) :: a ( imax ), alf ( kmaxx , kmaxx ), err ( kmaxx ) real ( wp ) :: yerr ( nmax ), ysav ( nmax ), yseq ( nmax ) logical :: first , reduct save a , alf , epsold , first , kmax , kopt , nseq , xnew !!! зачем save ????? real ( wp ) :: dyd integer :: ii !common /cmn/ ind data first / . true . / , epsold /- 1.d0 / data nseq / 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 18 / if ( eps . ne . epsold ) then hnext =- 1.d29 xnew =- 1.d29 eps1 = safe1 * eps a ( 1 ) = nseq ( 1 ) + 1 do k = 1 , kmaxx a ( k + 1 ) = a ( k ) + nseq ( k + 1 ) enddo do iq = 2 , kmaxx do k = 1 , iq - 1 alf ( k , iq ) = eps1 ** (( a ( k + 1 ) - a ( iq + 1 )) / (( a ( iq + 1 ) - a ( 1 ) + 1.d0 ) * ( 2 * k + 1 ))) enddo enddo epsold = eps do kopt = 2 , kmaxx - 1 if ( a ( kopt + 1 ). gt . a ( kopt ) * alf ( kopt - 1 , kopt )) goto 1 enddo 1 continue kmax = kopt endif h = htry do i = 1 , nv ysav ( i ) = y ( i ) dysav ( i ) = dydx ( i ) enddo if ( h . ne . hnext . or . x . ne . xnew ) then first = . true . kopt = kmax endif reduct = . false . 2 do k = 1 , kmax xnew = x + h if ( xnew . eq . x ) then write ( * , * ) 'step size underflow in difeq' pause end if call mmid ( ysav , dydx , nv , x , h , nseq ( k ), yseq , derivs ) !sav# if ( ind . eq . 1 ) then h = h / 2 d0 if ( dabs ( h ). lt . hmin1 ) then do ii = 1 , nv y ( ii ) = ysav ( ii ) end do hnext = h return end if do ii = 1 , nv dyd = dabs ( dysav ( ii )) yscal ( ii ) = dabs ( ysav ( ii )) + dabs ( h * dyd ) + 1.d-30 / ( 1 d0 + dyd ) y ( ii ) = ysav ( ii ) end do goto 2 end if !sav# xest = ( h / nseq ( k )) ** 2 !var        call pzextr(k,xest,yseq,y,yerr,nv)  !polynomial extrapolation call rzextr ( k , xest , yseq , y , yerr , nv ) !rational extrapolation if ( k . ne . 1 ) then errmax = tiny do i = 1 , nv errmax = max ( errmax , abs ( yerr ( i ) / yscal ( i ))) enddo errmax = errmax / eps km = k - 1 err ( km ) = ( errmax / safe1 ) ** ( 1.d0 / ( 2 * km + 1 )) endif if ( k . ne . 1. and .( k . ge . kopt - 1. or . first )) then if ( errmax . lt . 1.d0 ) goto 4 if ( k . eq . kmax . or . k . eq . kopt + 1 ) then red = safe2 / err ( km ) goto 3 else if ( k . eq . kopt ) then if ( alf ( kopt - 1 , kopt ). lt . err ( km )) then red = 1.d0 / err ( km ) goto 3 endif else if ( kopt . eq . kmax ) then if ( alf ( km , kmax - 1 ). lt . err ( km )) then red = alf ( km , kmax - 1 ) * safe2 / err ( km ) goto 3 endif else if ( alf ( km , kopt ). lt . err ( km )) then red = alf ( km , kopt - 1 ) / err ( km ) goto 3 endif endif enddo 3 red = min ( red , redmin ) red = max ( red , redmax ) h = h * red reduct = . true . goto 2 4 x = xnew hdid = h first = . false . wrkmin = 1.d35 do kk = 1 , km fact = max ( err ( kk ), scalmx ) work = fact * a ( kk + 1 ) if ( work . lt . wrkmin ) then scale = fact wrkmin = work kopt = kk + 1 endif enddo hnext = h / scale if ( kopt . ge . k . and . kopt . ne . kmax . and .. not . reduct ) then fact = max ( scale / alf ( kopt - 1 , kopt ), scalmx ) if ( a ( kopt + 1 ) * fact . le . wrkmin ) then hnext = h / fact kopt = kopt + 1 endif endif return end subroutine mmid ( y , dydx , nvar , xs , htot , nstep , yout , derivs ) use dispersion_module , only : iconv , irefl use runge_kutta_module , only : Iderivs_func implicit none real ( wp ), intent ( in ) :: y ( nvar ) real ( wp ), intent ( in ) :: dydx ( nvar ) integer , intent ( in ) :: nvar real ( wp ), intent ( in ) :: xs real ( wp ), intent ( in ) :: htot integer , intent ( in ) :: nstep real ( wp ), intent ( inout ) :: yout ( nvar ) !external derivs procedure ( Iderivs_func ) :: derivs integer , parameter :: nmax = 50 integer :: i , n real ( wp ) :: h , h2 , swap , x , ym ( nmax ), yn ( nmax ) real ( wp ) :: yz1 , yz2 !integer iconv,irefl !common /cefn/ iconv,irefl !integer ind !common /cmn/ ind h = htot / nstep yz1 = y ( 1 ) !sav# yz2 = y ( 2 ) !sav# do i = 1 , nvar ym ( i ) = y ( i ) yn ( i ) = y ( i ) + h * dydx ( i ) enddo x = xs + h call derivs ( x , yn , yout ) if ( iconv + irefl . ne . 0 ) goto 10 !sav# h2 = 2.d0 * h do n = 2 , nstep do i = 1 , nvar swap = ym ( i ) + h2 * yout ( i ) ym ( i ) = yn ( i ) yn ( i ) = swap enddo x = x + h call derivs ( x , yn , yout ) if ( iconv + irefl . ne . 0 ) goto 10 !sav# enddo do i = 1 , nvar yout ( i ) = 0.5d0 * ( ym ( i ) + yn ( i ) + h * yout ( i )) enddo ind = 0 !sav# return 10 ind = 1 !sav# yout ( 1 ) = yz1 !sav# yout ( 2 ) = yz2 !sav# return !sav# end subroutine rzextr ( iest , xest , yest , yz , dy , nv ) !! rational extrapolation integer , intent ( in ) :: iest , nv real ( wp ), intent ( in ) :: xest real ( wp ), intent ( in ) :: yest ( nv ) real ( wp ), intent ( inout ) :: yz ( nv ) real ( wp ), intent ( inout ) :: dy ( nv ) integer , parameter :: imax = 13 , nmax = 50 integer :: j , k real ( wp ) :: b , b1 , c , ddy , v , yy real ( wp ) :: d ( nmax , imax ), fx ( imax ), x ( imax ) save d , x !! зачем save ???? x ( iest ) = xest if ( iest . eq . 1 ) then do j = 1 , nv yz ( j ) = yest ( j ) d ( j , 1 ) = yest ( j ) dy ( j ) = yest ( j ) enddo else do k = 1 , iest - 1 fx ( k + 1 ) = x ( iest - k ) / xest enddo do j = 1 , nv yy = yest ( j ) v = d ( j , 1 ) c = yy d ( j , 1 ) = yy do k = 2 , iest b1 = fx ( k ) * v b = b1 - c if ( b . ne . 0.d0 ) then b = ( c - v ) / b ddy = c * b c = b1 * b else ddy = v endif if ( k . ne . iest ) v = d ( j , k ) d ( j , k ) = ddy yy = yy + ddy enddo dy ( j ) = ddy yz ( j ) = yy enddo endif return end subroutine pzextr ( iest , xest , yest , yz , dy , nv ) !! polynomial extrapolation integer iest , nv , imax , nmax double precision xest , dy ( nv ), yest ( nv ), yz ( nv ) parameter ( imax = 13 , nmax = 50 ) integer j , k1 double precision delta , f1 , f2 , q , d ( nmax ), qcol ( nmax , imax ), x ( imax ) save qcol , x x ( iest ) = xest do j = 1 , nv dy ( j ) = yest ( j ) yz ( j ) = yest ( j ) enddo if ( iest . eq . 1 ) then do j = 1 , nv qcol ( j , 1 ) = yest ( j ) enddo else do j = 1 , nv d ( j ) = yest ( j ) enddo do k1 = 1 , iest - 1 delta = 1.d0 / ( x ( iest - k1 ) - xest ) f1 = xest * delta f2 = x ( iest - k1 ) * delta do j = 1 , nv q = qcol ( j , k1 ) qcol ( j , k1 ) = dy ( j ) delta = d ( j ) - q dy ( j ) = f1 * delta d ( j ) = f2 * delta yz ( j ) = yz ( j ) + dy ( j ) enddo enddo do j = 1 , nv qcol ( j , iest ) = dy ( j ) enddo endif return end !------------------------------------------------------------------------------------------------ subroutine driver4 ( ystart , x1 , x2 , rexi , hmin , derivs ) use constants , only : zero use runge_kutta_module use rt_parameters , only : ipri , eps , hdrob , rbord , maxstep4 , rrange use dispersion_module , only : idec , ivar , izn use dispersion_module , only : pdec14 , pdec24 , pdec34 use dispersion_module , only : disp2 implicit none real ( wp ), intent ( inout ) :: ystart (:) real ( wp ), intent ( inout ) :: x1 , x2 real ( wp ), intent ( in ) :: rexi , hmin procedure ( Iderivs_func ) :: derivs !external derivs !common /abcd/ irs !common /abcde/ izn!,iw !common /abcdg/ iabsorp !common /bdeo/ ivar !common /bcef/ ynz,ynpopq !common /df/ pdec14,pdec24,pdec34,idec !real(wp) pintld4,pintcl4,pintal4 !common /dg/ pintld4,pintcl4,pintal4 integer , parameter :: iturns = 1 , maxat = 3 , nvar = 4 real ( wp ), parameter :: hbeg = 1.d-4 !sav2008 real ( wp ) :: x , xnr , prt , prm , dyd , hnext real ( wp ) :: yscal ( nvar ), y ( nvar ), dydx ( nvar ), yold ( nvar ) real ( wp ) :: eps1 , rbord1 , hdid , xold , h , rmm real ( wp ) :: hdrob1 , pdec14zz , pdec24zz , pdec34zz integer :: ipr1 , iat , i , ii , nstp ipr1 = 0 iat = 0 x = zero eps1 = eps hdrob1 = hdrob rbord1 = rbord hdid = zero pintld4 = zero pintcl4 = zero pintal4 = zero pdec14zz = zero pdec24zz = zero pdec34zz = zero xold = x do i = 1 , nvar y ( i ) = ystart ( i ) yold ( i ) = y ( i ) end do rmm = 1 d + 10 * irs !sav2008 !old      rexi1=rexi+rrange !old      rexi2=rexi-rrange !old      if(rexi1.gt.0.95d0) rexi1=1.d10 !old      if(rexi2.lt.0.05d0) rexi2=-1.d10 !est      if(rexi1.gt.0.9d0) rexi1=1.1d0 10 continue !c-------------------------------------- !c start integration !c-------------------------------------- do nstp = 1 , maxstep4 idec = iturns call derivs ( x , y , dydx ) idec = 0 pintld4 = pintld4 + abs (( pdec14 + pdec14zz ) / 2 d0 * hdid ) pintcl4 = pintcl4 + abs (( pdec24 + pdec24zz ) / 2 d0 * hdid ) pintal4 = pintal4 + abs (( pdec34 + pdec34zz ) / 2 d0 * hdid ) pdec14zz = pdec14 pdec24zz = pdec24 pdec34zz = pdec34 if ( nstp . eq . 1 ) then h = hbeg !!var        if(dabs(dydx(3)).ne.zero) h=dabs(hmin1/dydx(3))/hdrob1 if ( dabs ( dydx ( 3 )). ne . zero ) h = 0.5d0 * dabs ( rrange / dydx ( 3 )) / hdrob1 end if 20 continue if ( y ( 3 ). ge . rbord1 . and . dydx ( 3 ). gt . zero ) then !c-------------------------------------- !c forced reflection from periphery !c-------------------------------------- ivar = 3 izn =- izn call disp2 ( y ( 3 ), y ( 2 ), y ( 1 ), xnr , prt , prm ) if ( ivar . eq . - 1 ) then !out of dispersion curve - restart print * , 'out of dispersion curve - restart' do i = 1 , nvar y ( i ) = ystart ( i ) end do x = zero iat = iat + 1 if ( iat . gt . maxat ) then if ( ipri . gt . 1 ) write ( * , * ) 'turn in driver4 failed' goto 40 end if eps1 = eps1 / 2.d0 hdrob1 = hdrob1 * 2.d0 ivar = 0 goto 10 end if irs =- irs y ( 4 ) = xnr call derivs ( x , y , dydx ) if ( dydx ( 3 ). gt . zero . and . ipri . gt . 1 ) then write ( * , * ) 'Unsuccesful turn: r, drds=' , y ( 3 ), dydx ( 3 ) end if ivar = 0 iat = 0 end if !sav2008       if((y(3).gt.rexi1.or.y(3).lt.rexi2)) then  ! exit !!    if(dabs(y(3)-rexi).gt.rrange.or.nstp.eq.maxstep4) then  ! exit !sav2008 call memorize_trajectory_point4 ( y ( 3 ), y ( 1 )) if ( dabs ( y ( 3 ) - rexi ). gt . rrange ) then ! exit !sav2008 if ( dydx ( 3 ). gt . zero ) irs =- 1 if ( dydx ( 3 ). lt . zero ) irs = 1 if ( dydx ( 3 ). eq . zero ) then !sav2008 write ( * , * ) 'exception dr/ds=0 in driver4' pause 'zmi na pedal' go to 1 end if x2 = x x1 = rmm do i = 1 , nvar ystart ( i ) = y ( i ) end do return end if 1 continue !c--------------------------------------- !c remember old values !c--------------------------------------- xold = x do i = 1 , nvar dyd = dabs ( dydx ( i )) yscal ( i ) = dabs ( y ( i )) + dabs ( h * dyd ) + 1.d-30 / ( 1.d0 + dyd ) + 1.d-30 yold ( i ) = y ( i ) end do if ( y ( 3 ) * irs . lt . rmm * irs ) rmm = y ( 3 ) 30 continue call runge_kutta_qs ( y , dydx , nvar , x , h , eps1 , yscal , hdid , hnext , derivs ) if ( y ( 3 ). ge . 1.d0 ) then ! crossed plasma boundary do ii = 1 , nvar y ( ii ) = yold ( ii ) end do x = xold ipr1 = ipr1 + 1 if ( ipr1 . lt . maxat ) then h = h / 3.d0 goto 30 end if rbord1 = y ( 3 ) - 1.d-4 goto 20 end if ipr1 = 0 if ( dabs ( hnext ). lt . hmin ) then if ( ipri . gt . 1 ) write ( * , * ) 'error in dr4: step is too small' goto 40 end if h = hnext end do if ( ipri . gt . 1 ) write ( * , * ) 'error in dr4: too many steps.' if ( ipri . gt . 1 ) write ( * , * ) 'tet=' , y ( 1 ), 'xm=' , y ( 2 ), 'xend=' , y ( 3 ) 40 iabsorp =- 1 end end module driver_module","tags":"","loc":"sourcefile\\3_driver_module.f90.html"},{"title":"2_trajectory_data.f90 – FRTС project","text":"Source Code module trajectory_data use kind_module implicit none type TrajectoryPoint !! тип для хранения точки тректории real ( wp ) :: dland , dcoll , perpn , dalf real ( wp ) :: vel , tetai real ( wp ) :: xnpar real ( wp ) :: rho real ( wp ) :: vthc , poloidn integer :: izz , iww , jrad integer :: driver !! value = 2 or 4, где была создана точка в driver2 или driver4 end type TrajectoryPoint integer , parameter :: max_size = 10000 type Trajectory integer size !! size of Trajectory real ( wp ) :: tetin ! tetzap(itr) real ( wp ) :: xmin ! xmzap(itr) real ( wp ) :: rin ! rzap(itr) real ( wp ) :: yn3 ! yn3zap(itr) real ( wp ) :: pow ! powexit integer :: irs ! irszap(itr) integer :: iw ! iwzap(itr) integer :: izn ! iznzap(itr) integer :: spectrum_point_index integer :: mbad integer :: nrefj real ( wp ) :: tetzap ! tetzap(itr) real ( wp ) :: xmzap ! xmzap(itr) real ( wp ) :: rzap ! rzap(itr) real ( wp ) :: yn3zap ! yn3zap(itr) real ( wp ) :: powexit ! powexit integer :: irszap ! irszap(itr) integer :: iwzap ! iwzap(itr) integer :: iznzap ! iznzap(itr) type ( TrajectoryPoint ), allocatable :: points (:) !! contains procedure :: init => init_method procedure :: reset => reset_method procedure :: add_point => add_point_method procedure :: write_info => write_info_method end type Trajectory type ( Trajectory ), pointer :: current_trajectory contains subroutine init_method ( this , theta , index ) !! инициализация траетории implicit none class ( Trajectory ), intent ( inout ) :: this real ( wp ), intent ( in ) :: theta integer , intent ( in ) :: index !print *,'инит массива точек:', size(this%points) if ( allocated ( this % points )) deallocate ( this % points ) this % tetin = theta this % spectrum_point_index = index this % size = 0 this % nrefj = 0 this % mbad = 0 allocate ( this % points ( max_size )) end subroutine subroutine reset_method ( this , index ) !! сброс счетчика implicit none class ( Trajectory ), intent ( inout ) :: this integer , intent ( in ) :: index this % size = index end subroutine subroutine add_point_method ( this , tpoint ) !! добавляение новой точнки траектории implicit none class ( Trajectory ), intent ( inout ) :: this class ( TrajectoryPoint ), intent ( in ) :: tpoint this % size = this % size + 1 if ( this % size > max_size ) then print * , 'слишком много точек' stop end if this % points ( this % size ) = tpoint end subroutine subroutine write_info_method ( this , iu ) !! сохранение в файл информации о траектории implicit none class ( Trajectory ), intent ( inout ) :: this integer , intent ( in ) :: iu write ( iu , '(3(A,10x))' ) 'theta' , 'index' , 'mbad' write ( iu , '(f8.5,1x,i5,2x,i5,2x)' ) this % tetin , this % spectrum_point_index , this % mbad write ( iu , * ) end subroutine end module trajectory_data","tags":"","loc":"sourcefile\\2_trajectory_data.f90.html"},{"title":"1_chang_cooper_solver.f90 – FRTС project","text":"Source Code module chang_cooper_module use kind_module implicit none contains subroutine chang_cooper_solver ( alfa2 , nt , h , dt , n , ybeg , yend , d1 , d2 , d3 , y ) ! схема Ченга-Купера для уравнения Фоккера-Планка implicit none real ( wp ), intent ( in ) :: alfa2 integer , intent ( in ) :: nt , n real ( wp ), intent ( in ) :: h , dt real ( wp ), intent ( in ) :: ybeg , yend real ( wp ), intent ( in ) :: d1 ( n + 1 ), d2 ( n + 1 ), d3 ( n + 1 ) real ( wp ), intent ( inout ) :: y ( n + 2 ) integer i , it , iz real ( wp ) xx ( n + 1 ), a ( n ), b ( n ), c ( n ), f ( n ) real ( wp ) y1 ( n ) !print *, 'TK abc n = ', n do i = 1 , n + 1 xx ( i ) = h / 2.d0 + h * dble ( i - 1 ) !+shift end do do i = 1 , n y1 ( i ) = y ( i + 1 ) end do do it = 1 , nt !call ABCcoef(a,b,c,f,y1,dt,n,ybeg,yend,x,xx,h,D1) call chang_cooper_abcoef ( alfa2 , a , b , c , f , y1 , dt , n , ybeg , yend , xx , h , d1 ) call tridag ( a , b , c , f , y1 , n ) !do i=1,n !    if (y1(i).lt.0.d0) then !        if (y1(i) > epsilon(y1(i))) then !            y1(i)=0.d0 !        else !            write(*,*) n, i, 'y(i)=',y1(i),' lt negative epsilon=',epsilon(y1(i)) !            !pause !            !stop !        endif !    endif !enddo iz = n do i = 1 , n if ( y1 ( i ). lt . epsilon ( yend )) then iz = i !print *, epsilon(yend) !print *, iz, n, yend, y1(i) exit endif enddo do i = iz , n y1 ( i ) = yend enddo end do do i = 1 , n y ( i + 1 ) = y1 ( i ) end do end subroutine ! -- subroutine chang_cooper_abcoef ( alfa2 , A , B , C , f , Y , dt , n , ybeg , yend , xx , h , df ) implicit none real ( wp ), intent ( in ) :: alfa2 real ( wp ), intent ( inout ) :: a ( n ), b ( n ), c ( n ), f ( n ), y ( n + 2 ) integer , intent ( in ) :: n real ( wp ), intent ( in ) :: dt , ybeg , yend , h real ( wp ), intent ( in ) :: xx ( n + 1 ) real ( wp ), intent ( in ) :: df ( n + 1 ) integer i real ( wp ) z , r , tmp1 , tmp2 , tmp3 r = dt / h do i = 1 , n tmp1 = dlt ( xx ( i ), h , df ( i ), alfa2 ) * B1 ( xx ( i ), alfa2 ) A ( i ) =- r * ( C1 ( xx ( i ), df ( i )) / h - tmp1 ) tmp2 = C1 ( xx ( i + 1 ), df ( i + 1 )) / h - dlt ( xx ( i + 1 ), h , df ( i + 1 ), alfa2 ) * B1 ( xx ( i + 1 ), alfa2 ) tmp3 = ( 1.d0 - dlt ( xx ( i ), h , df ( i ), alfa2 )) * B1 ( xx ( i ), alfa2 ) B ( i ) = r * ( tmp2 + tmp3 + C1 ( xx ( i ), df ( i )) / h ) + 1.d0 tmp1 = ( 1.d0 - dlt ( xx ( i + 1 ), h , df ( i + 1 ), alfa2 )) * B1 ( xx ( i + 1 ), alfa2 ) C ( i ) =- r * ( tmp1 + C1 ( xx ( i + 1 ), df ( i + 1 )) / h ) f ( i ) = Y ( i ) enddo f ( 1 ) = f ( 1 ) - A ( 1 ) * ybeg f ( n ) = f ( n ) - C ( n ) * yend !yend in either way=0 all the time contains function B1 ( xx , alfa2 ) result ( res ) implicit none real ( wp ) xx , alfa2 , beta , res res = - alfa2 + 1.d0 / ( xx * xx ) end function function C1 ( xx , dif ) result ( res ) implicit none real ( wp ) xx , dif , res res = dif + 1.d0 / ( xx * xx * xx ) end function function dlt ( xx , h , dif , alfa2 ) result ( res ) implicit none real ( wp ) res real ( wp ) xx , h , dif , alfa2 real ( wp ) w w = h * B1 ( xx , alfa2 ) / C1 ( xx , dif ) res = 1.d0 / w - 1.d0 / ( dexp ( w ) - 1.d0 ) end function end !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc end module Chang_Cooper_module","tags":"","loc":"sourcefile\\1_chang_cooper_solver.f90.html"},{"title":"4_manager.f90 – FRTС project","text":"Source Code module manager_mod !! модуль определяет начальные значения лучей и запускает трассировку use kind_module implicit none contains subroutine manager ( iterat , iw0 , ntet , spectr ) use constants use plasma use rt_parameters , only : nr , ipri , iw , nmaxm , pabs0 , eps , eps_const use trajectory_module use spectrum_mod use iterator_mod , only : plost , pnab use dispersion_module , only : icall1 , icall2 , yn3 , ivar , izn use driver_module !, only: irs, iabsorp use trajectory_data implicit none type ( Spectrum ) spectr type ( SpectrumPoint ) point real ( wp ) pabs integer ntet , iout , itr , nnj , n_it integer maxref , iterat , nmax0 , ibad , itet , nref integer nbad1 , nbad2 , inz integer iw0 , ifail , iabsirp , inak0 , ib , ie integer nmax , i , nb1 , nb2 real ( wp ) htet , hr , rin , xmin !, rstart real ( wp ) powexit , dltpow , pow1 , pgamma !, xm real ( wp ) tetin0 , tetin !, tet pabs = spectr % max_power * pabs0 / 1.d2 print * , 'pabs =' , pabs , spectr % max_power , pabs0 htet = zero hr = 1.d0 / dble ( nr + 1 ) !sav2008 if ( ntet . ne . 1 ) htet = ( tet2 - tet1 ) / ( ntet - 1 ) irs = 1 iout = 0 itr = 0 nnj = 0 do n_it = 0 , 3 nnj = nnj + nmaxm ( n_it + 1 ) end do maxref = nnj if ( iterat . lt . 3 ) nmax0 = nmaxm ( iterat + 1 ) if ( iterat . ge . 3 ) nmax0 = nmaxm ( 4 ) if ( ipri . gt . 1 ) then write ( * , 1001 ) iterat + 1 write ( * , 1002 ) end if if ( iterat . eq . 0 ) then !----------------------------------------- !    find initial radius for a trajectory !    on the 1th iteration !----------------------------------------- do itet = 1 , ntet tetin = tet1 + htet * ( itet - 1 ) do inz = 1 , spectr % size itr = itr + 1 current_trajectory => trajectories ( itr ) point = spectr % data ( inz ) call current_trajectory % init ( tetin , inz ) call rini ( current_trajectory , point , iw0 ) enddo enddo endif ibad = 0 itr = 0 !-------------------------------------- ! begin outer loop on teta !-------------------------------------- do itet = 1 , ntet nref = 0 nbad1 = 0 nbad2 = 0 icall1 = 0 icall2 = 0 tetin = tet1 + htet * ( itet - 1 ) !-------------------------------------- ! begin inner loop on nz !-------------------------------------- do inz = 1 , spectr % size itr = itr + 1 current_trajectory => trajectories ( itr ) point = spectr % data ( inz ) if ( current_trajectory % mbad . ne . 0 ) then plost = plost + point % power go to 31 end if powexit = point % power dltpow = pabs call dqliter ( dltpow , current_trajectory , hr , powexit , iout ) if ( nmax0 . eq . 0 ) then pow1 = powexit pgamma = 1.d0 - pow1 / point % power powexit = pow1 / pgamma dltpow = powexit - pow1 + pabs call dqliter ( dltpow , current_trajectory , hr , powexit , iout ) powexit = powexit - dltpow + pabs if ( powexit . lt . zero ) powexit = zero go to 30 end if if ( iout . eq . 0 ) then go to 30 end if pow = powexit ! продолжение траектории ! initial parameters for a trajectory nmax = nmax0 iabsorp = 0 !------------------------------------- ! call ray tracing !------------------------------------- call tracing ( current_trajectory , nmax , nb1 , nb2 , pabs ) eps = eps_const nbad1 = nbad1 + nb1 nbad2 = nbad2 + nb2 current_trajectory % nrefj = current_trajectory % nrefj + nmax powexit = pow nref = nref + nmax if ( iabsorp . lt . 0 ) then !------------------------------------- !    encounted problems !------------------------------------- if ( current_trajectory % size . eq . max_size - 1 ) then write ( * , * ) 'fix maximal length' nmax0 = 0 do i = 1 , 4 nmaxm ( i ) = 0 end do iout = 1 goto 20 end if if ( ipri . gt . 1 ) then tetin0 = tet1 + htet * ( itet - 1 ) write ( * , 111 ) tetin0 , point % Ntor 111 format ( 1 x , 'traj. with tet0=' , f10 . 5 , 1 x , ', Ninput=' , f10 . 5 , 1 x , 'failed' ) end if current_trajectory % mbad = 1 ! плохоая траектория plost = plost + pow goto 30 end if 20 continue if ( current_trajectory % nrefj . gt . maxref . and . pow . gt . pabs ) then !forced absorp if ( pow . ge . point % power ) go to 30 !sav2008 pow1 = pow pgamma = 1.d0 - pow1 / point % power powexit = pow1 / pgamma dltpow = powexit - pow1 + pabs call dqliter ( dltpow , current_trajectory , hr , powexit , iout ) powexit = powexit - dltpow + pabs if ( powexit . lt . zero ) powexit = zero end if 30 continue pnab = pnab + powexit 31 continue end do if ( ipri . gt . 1 ) write ( * , 1003 ) itet , icall1 , icall2 , nref , nbad1 , nbad2 end do 1001 format ( 30 x , i4 , ' iteration' ) 1002 format ( 6 x , 'n' , 5 x , 'call2' , 6 x , 'call4' , 6 x , 'nrefl' , 4 x , 'last' , 5 x , 'bad2' , 5 x , 'bad4' ) 1003 format ( 3 x , i4 , 2 ( 1 x , i10 ), 2 x , i7 , 2 x , i8 , 2 ( 1 x , i7 ), 2 ( 2 x , i7 )) 1004 format ( 1 x , i8 ) 1005 format ( 1 x , i5 ) 1006 format ( e14 . 7 ) end !real(wp) function rini(xm, tet, point, ifail) !sav2009 subroutine rini ( traj , point , iw0 ) use constants , only : zero use rt_parameters , only : inew , nr , iw use spectrum_mod , only : SpectrumPoint use dispersion_module , only : ivar , yn3 , izn use dispersion_module , only : disp2_iroot2 use metrics , only : g22 , g33 , co , si use metrics , only : calculate_metrics use driver_module , only : irs use trajectory_data implicit none class ( Trajectory ), intent ( inout ) :: traj type ( SpectrumPoint ), intent ( in ) :: point integer , intent ( in ) :: iw0 real ( wp ) :: xm real ( wp ) :: tet integer :: ntry real ( wp ) :: pa , prt , prm , hr real ( wp ) :: f1 , f2 real ( wp ), parameter :: rhostart = 1.d0 integer , parameter :: ntry_max = 5 irs = 1 iw = iw0 hr = 1.d0 / dble ( nr + 1 ) tet = traj % tetin ntry = 0 pa = rhostart do while ( ntry . lt . ntry_max . and . pa . ge . 2 d0 * hr ) pa = rhostart - hr * dble ( ntry ) - 1.d-4 ntry = ntry + 1 ! вычисление g22 и g33 call calculate_metrics ( pa , tet ) yn3 = point % Ntor * dsqrt ( g33 ) / co xm = point % Npol * dsqrt ( g22 ) / si call disp2_iroot2 ( pa , xm , tet , f1 , f2 ) if ( f1 . ge . zero . and . f2 . ge . zero ) then !rini = pa traj % rin = pa traj % tetzap = tet traj % xmzap = xm traj % rzap = pa traj % yn3zap = yn3 traj % irszap = irs traj % iwzap = iw traj % iznzap = izn return end if end do print * , 'error: no roots' traj % mbad = 1 ! плохоая траектория end subroutine dqliter ( dltpow , traj , h , powexit , iout ) !sav2008 use constants , only : clt , zero use rt_parameters , only : itend0 , kv use iterator_mod , only : vlf , vrt , dflf , dfrt use iterator_mod , only : distr use decrements , only : pdec1 , pdec2 , pdec3 , pdecv use decrements , only : zatukh use current , only : dfind use plasma , only : vperp use iterator_mod , only : psum4 use driver_module , only : pow use trajectory_data implicit none type ( Trajectory ), pointer , intent ( in ) :: traj real ( wp ), intent ( in ) :: dltpow real ( wp ), intent ( in ) :: h real ( wp ), intent ( out ) :: powexit integer , intent ( inout ) :: iout type ( TrajectoryPoint ) :: tp integer :: i , iv , jr , ifast , jchek real ( wp ) :: pdec1z , pdec3z , pintld , pintal real ( wp ) :: v , refr , dek3 , argum , valfa real ( wp ) :: df , dfsr , vsr , pcurr , dcv real ( wp ) :: powpr , powd , powcol , powal real ( wp ) :: pil , pic , pia pow = powexit pdec1 = zero pdec1z = zero pdec3 = zero pdec3z = zero pdecv = zero pintld = zero pintal = zero iout = 0 do i = 1 , traj % size !----------------------------------- ! restore memorized decrements and ! integrate power equation !------------------------------------ tp = traj % points ( i ) v = tp % vel jr = tp % jrad refr = tp % perpn ifast = tp % iww dek3 = zero if ( itend0 . gt . 0 ) then argum = clt / ( refr * valfa ) dek3 = zatukh ( argum , abs ( jr ), vperp , kv ) end if !!!old variant !!!       call raspr(v,abs(jr),iv,df) !!!       if(iv.eq.0) iv=1 !!!!!!!!!!!!!!!!!!!!!!!!!! call distr ( v , abs ( jr ), iv , df ) !!       dfsr=v*df*(vrt-vlf) !!       vsr=v*(vrt-vlf) dfsr = ( vlf * dflf + vrt * dfrt ) / 2 d0 * ( vrt - vlf ) !sav2008 vsr = ( vrt + vlf ) * ( vrt - vlf ) / 2 d0 !sav2008 if ( jr . lt . 0 ) then !case of turn jr =- jr !variant        pintld=-dland(i)*df !!        pintld=-dland(i)*(dflf+dfrt)/2d0 pintld = dabs ( tp % dland * ( dflf + dfrt ) / 2 d0 ) pdec2 = dexp ( - 2 d0 * tp % dcoll ) pintal = dabs ( tp % dalf * dek3 ) pcurr = pdec2 * dexp ( - 2 d0 * pintld - 2 d0 * pintal ) psum4 = psum4 + pow * ( 1 d0 - pcurr ) dcv = tp % dland / vsr else pdec2 = tp % dcoll pdecv = tp % dland !!        pdec1=-pdecv*df pdec1 = dabs ( pdecv * df ) pdec3 = dabs ( tp % dalf * dek3 ) pintld = ( pdec1 + pdec1z ) / 2 d0 * h pintal = ( pdec3 + pdec3z ) / 2 d0 * h pdec1z = pdec1 pdec3z = pdec3 dcv = pdecv * h / vsr end if powpr = pow if ( dltpow . ne . zero ) then powd = pow * dexp ( - 2 d0 * pintld ) powcol = powd * pdec2 powal = powcol * dexp ( - 2 d0 * pintal ) pow = powal end if pil = pintld pic = . 5 d0 * dabs ( dlog ( pdec2 )) pia = pintal call dfind ( jr , iv , v , powpr , pil , pic , pia , dfsr , dcv , & refr , vlf , vrt , ifast ) if ( pow . lt . dltpow ) then powexit = pow return end if end do iout = 1 powexit = pow end end module manager_mod","tags":"","loc":"sourcefile\\4_manager.f90.html"},{"title":"0_kind_module.f90 – FRTС project","text":"Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Define the numeric kinds. module kind_module use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none private !integer,parameter,public :: wp = real32     !! single precision reals integer , parameter , public :: wp = real64 !! double precision reals !integer,parameter,public :: wp = real128    !! quad precision reals end module kind_module !*****************************************************************************************","tags":"","loc":"sourcefile\\0_kind_module.f90.html"},{"title":"2_driven_current_module.f90 – FRTС project","text":"Source Code module driven_current_module !! Driven Current Module use kind_module implicit none real ( wp ) :: zv1 ( 100 , 2 ), zv2 ( 100 , 2 ) !common/plosh/ zv1(100,2),zv2(100,2)!,sk(100) type DrivenCurrent real ( wp ) :: cu !! ??  может лучше cuj real ( wp ) :: cu0 !! ??              cujoh real ( wp ) :: c !! ?? real ( wp ) :: c0 !! ?? real ( wp ), dimension (:), allocatable :: outj !! outj(i)  = LH driven current density, MA/m&#94;2 real ( wp ), dimension (:), allocatable :: ohj !! integer :: grid_size contains procedure :: evaluate => DrivenCurrent_evaluate end type interface DrivenCurrent module procedure :: DrivenCurrent_constructor end interface DrivenCurrent type DrivenCurrentResult real ( wp ) :: cup , cp !! real ( wp ) :: cum , cm !! real ( wp ) :: cup0 , cp0 !! real ( wp ) :: cum0 , cm0 !! contains procedure :: print => driven_current_result_print procedure :: save => driven_current_result_save end type DrivenCurrentResult interface DrivenCurrentResult module procedure :: DrivenCurrentResult_constructor end interface DrivenCurrentResult contains function DrivenCurrent_constructor ( size ) result ( this ) !- конструктор для DrivenCurrent implicit none type ( DrivenCurrent ) :: this integer , value :: size this % cu = 0 this % cu0 = 0 this % c = 0 this % c0 = 0 this % grid_size = size allocate ( this % outj ( size ), this % ohj ( size )) end function DrivenCurrent_constructor subroutine DrivenCurrent_evaluate ( this , ROC ) !- заключительное вычисление DrivenCurrent use constants , only : zero implicit none class ( DrivenCurrent ), intent ( inout ) :: this real ( wp ), intent ( in ) :: ROC external aiint real ( wp ) aiint integer :: i if ( this % cu0 . ne . zero ) then this % c0 = aiint ( this % ohj , ROC ) if ( this % c0 . ne . zero ) then do i = 1 , this % grid_size this % ohj ( i ) = this % cu0 * this % ohj ( i ) / this % c0 end do end if end if if ( this % cu . ne . zero ) then this % c = aiint ( this % outj , ROC ) if ( this % c . ne . zero ) then do i = 1 , this % grid_size this % outj ( i ) = this % cu * this % outj ( i ) / this % c end do end if end if end subroutine DrivenCurrent_evaluate function DrivenCurrentResult_constructor ( positive_dc , negative_dc ) result ( this ) !- конструктор для DrivenCurrentResult implicit none type ( DrivenCurrent ), intent ( in ) :: positive_dc type ( DrivenCurrent ), intent ( in ) :: negative_dc type ( DrivenCurrentResult ) :: this this % cup = positive_dc % cu this % cum = negative_dc % cu this % cp = positive_dc % c this % cm = negative_dc % c this % cup0 = positive_dc % cu0 this % cum0 = negative_dc % cu0 this % cp0 = positive_dc % c0 this % cm0 = negative_dc % c0 end function DrivenCurrentResult_constructor subroutine driven_current_result_print ( this , time ) class ( DrivenCurrentResult ), intent ( in ) :: this real ( wp ), intent ( in ) :: time print * , '------- driven current ---------' print * , 'time=' , time print * , 'cup=' , this % cup , ' cp=' , this % cp print * , 'cum=' , this % cum , ' cm=' , this % cm print * , 'cup0=' , this % cup0 , ' cp0=' , this % cp0 print * , 'cum0=' , this % cum0 , ' cm0=' , this % cm0 print * , 'sigma driven current, MA=' , this % cp0 + this % cm0 print * , 'driven current, MA=' , this % cup + this % cum print * , '--------------------------------' end subroutine driven_current_result_print subroutine driven_current_result_save ( this , time ) class ( DrivenCurrentResult ), intent ( in ) :: this real ( wp ), intent ( in ) :: time logical , save :: first_time = . TRUE . character ( 132 ) FNAME integer :: io FNAME = \"lhcd/dc_result.dat\" if ( first_time ) then open ( newunit = io , file = FNAME , status = \"replace\" , action = \"write\" ) write ( io , '(100A22)' ), \"Time\" , 'cup' , 'cp' , 'cum' , 'cm' , 'cup0' , 'cp0' , 'cum0' , 'cm0' close ( io ) first_time = . FALSE . else open ( newunit = io , file = FNAME , position = \"append\" ) write ( io , '(100f22.14)' ) time , this % cup , this % cp , this % cum , this % cm , this % cup0 , this % cp0 , this % cum0 , this % cm0 close ( io ) end if end subroutine driven_current_result_save end module driven_current_module","tags":"","loc":"sourcefile\\2_driven_current_module.f90.html"},{"title":"3_iteration_result.f90 – FRTС project","text":"Source Code module iteration_result_mod use kind_module implicit none type IterationResult integer :: number !! iteration number 'iteration=',iterat integer :: spectr_direction !! 'ispectr=',ispectr real ( wp ) :: P_launched !!P_launched, MW=',plaun real ( wp ) :: P_landau !!'P_landau, MW=',ol real ( wp ) :: P_coll !! 'P_coll, MW=',oc real ( wp ) :: P_alph !!'P_alph, MW=',oa real ( wp ) :: alphas_power !!'Alphas power, MW=',fuspow real ( wp ) :: P_fast !write(*,*) 'P_fast (landau+coll), MW=',of real ( wp ) :: P_lost !write(*,*) 'P_lost, MW=',plost/xsgs real ( wp ) :: P_not_accounted !write(*,*) 'P_not accounted, MW=',pnab/xsgs real ( wp ) :: P_landau_strong_absorption !write(*,*) 'P_landau (strong absorption), MW=',ppv1/xsgs real ( wp ) :: P_landau_weak_absorption !write(*,*) 'P_landau (weak absorption), MW=',ppv2/xsgs real ( wp ) :: P_turns !write(*,*) 'P_turns, MW=', psum4/xsgs real ( wp ) :: efficiency !write(*,*) 'efficiency, I(MA)/P(MW)=',oi/plaun !sav2008 !call integral(1,nspl,rh,con,avedens) !sav2010 real ( wp ) :: avedens real ( wp ) :: r0 !write (*,*) '<Ne>, m&#94;-3=',avedens*1.d19,' R, m=',r0*1.d-2 real ( wp ) :: eta_eff !eta_eff=1.d17*avedens*r0*oi/plaun !write (*,*) 'eta_eff=<Ne>*R*I/P, A/(W*m&#94;2)=',eta_eff !sav2010 real ( wp ) :: residual !! невязка 'nevyazka=', pchg contains procedure :: print => iteration_result_print procedure :: save => iteration_result_save end type IterationResult contains subroutine iteration_result_print ( this ) class ( IterationResult ), intent ( in ) :: this print * , ' ---------' print * , 'ITERATION:' print * , 'iteration=' , this % number print * , 'ispectr=' , this % spectr_direction print * , 'P_launched, MW=' , this % P_launched print * , 'P_landau, MW=' , this % P_landau print * , 'P_coll, MW=' , this % P_coll print * , 'P_alph, MW=' , this % P_alph print * , 'Alphas power, MW=' , this % alphas_power print * , 'P_fast (landau+coll), MW=' , this % P_fast print * , 'P_lost, MW=' , this % P_lost print * , 'P_not accounted, MW=' , this % P_not_accounted print * , 'P_landau (strong absorption), MW=' , this % P_landau_strong_absorption print * , 'P_landau (weak absorption), MW=' , this % P_landau_weak_absorption print * , 'P_turns, MW=' , this % P_turns print * , 'efficiency, I(MA)/P(MW)=' , this % efficiency !call integral(1,nspl,rh,con,avedens) !sav2010 print * , '<Ne>, m&#94;-3=' , this % avedens , ' R, m=' , this % r0 !eta_eff=1.d17*avedens*r0*oi/plaun print * , 'eta_eff=<Ne>*R*I/P, A/(W*m&#94;2)=' , this % eta_eff print * , 'nevyazka=' , this % residual end subroutine iteration_result_print subroutine iteration_result_save ( this , time_stamp ) !! save Iteration Result to file class ( IterationResult ), intent ( in ) :: this real ( wp ), intent ( in ) :: time_stamp character ( 120 ) fname integer , parameter :: iu = 20 write ( fname , '(\"lhcd/rt-result/\", f9.7,\".dat\")' ) time_stamp print * , fname open ( iu , file = fname , position = \"append\" ) if ( this % number == 1 ) then write ( 20 , '(18A21)' ) 'iteration' , 'direction' , 'P_launched' , & 'P_landau' , 'P_coll' , 'P_alph' , 'alphas_power' , 'P_fast' , 'P_lost' , & 'P_not_accounted' , 'P_landau_strong_abs' , 'P_landau_weak_abs' , & 'P_turns' , 'efficiency' , 'avedens' , 'r0' , 'eta_eff' , 'residual' endif write ( 20 , '(2(I21), 16(ES21.14))' ) this % number , this % spectr_direction , & this % P_launched , this % P_landau , this % P_coll , this % P_alph , & this % alphas_power , this % P_fast , this % P_lost , this % P_not_accounted , & this % P_landau_strong_absorption , this % P_landau_weak_absorption , & this % P_turns , this % efficiency , this % avedens , this % r0 , & this % eta_eff , this % residual close ( iu ) end subroutine end module iteration_result_mod","tags":"","loc":"sourcefile\\3_iteration_result.f90.html"},{"title":"2_spectrum.f90 – FRTС project","text":"Source Code module spectrum_mod use kind_module implicit none type SpectrumPoint !real(wp) nz и ny не нужны ! !real(wp) ny ! real ( wp ) Ntor !! Ntau=-Ntor real ( wp ) Npol !! Ntet=Npol real ( wp ) power !! power contains end type SpectrumPoint type Spectrum integer size !! size of spectrum real ( wp ) input_power !! power of spectrum real ( wp ) power_ratio !! доля входной мощности real ( wp ) max_power !! real ( wp ) sum_power !! суммарная power integer direction !! направление спектра   +1 или -1 или 0 - полный type ( SpectrumPoint ), allocatable :: data (:) !! contains procedure :: get_positive_part => get_positive_part_method procedure :: get_negative_part => get_negative_part_method procedure :: calc_max_power => calc_max_power_method procedure :: normalization => normalization_method procedure :: integral_trapez => integral_trapez_method procedure :: write => write_spectrum end type Spectrum interface Spectrum module procedure :: spectrum_constructor !module procedure :: read_spectrum end interface Spectrum contains function spectrum_constructor ( size ) result ( this ) !- конструктор для spectrum implicit none type ( Spectrum ) :: this integer , value :: size this % size = size this % input_power = 0 this % sum_power = 0 allocate ( this % data ( size )) end function spectrum_constructor subroutine calc_max_power_method ( this ) use constants , only : xsgs use rt_parameters , only : ntet implicit none class ( Spectrum ), intent ( inout ) :: this type ( SpectrumPoint ) :: p real ( wp ) max_power , pnorm integer i max_power = 0 pnorm = this % input_power * xsgs / ntet print * , 'pnorm =' , pnorm do i = 1 , this % size p = this % data ( i ) p % power = p % power * pnorm p % Ntor = this % direction * p % Ntor this % data ( i ) = p if ( p % power > max_power ) max_power = p % power end do this % max_power = max_power print * , 'this%max_power = ' , this % max_power end subroutine function integral_trapez_method ( this ) result ( sum ) !! вычисление полной мощности спектра !! интегрирование методом трапеций implicit none class ( Spectrum ), intent ( in ) :: this real ( wp ) :: sum integer :: i type ( SpectrumPoint ) :: p1 , p2 p1 = this % data ( 1 ) sum = 0 do i = 2 , this % size p2 = this % data ( i ) sum = sum + 0.5d0 * ( p2 % power + p1 % power ) * ( p2 % Ntor - p1 % Ntor ) p1 = p2 end do end function subroutine normalization_method ( this ) use constants , only : xsgs use rt_parameters , only : ntet implicit none class ( Spectrum ), intent ( inout ) :: this type ( SpectrumPoint ) :: p real ( wp ) max_power , pnorm , p_sum integer i !p_sum = this%integral_trapez() p_sum = 0 do i = 1 , this % size p_sum = p_sum + this % data ( i )% power end do max_power = 0 pnorm = this % input_power * xsgs / ntet / p_sum print * , 'pnorm =' , pnorm do i = 1 , this % size p = this % data ( i ) p % power = p % power * pnorm p % Ntor = this % direction * p % Ntor !p%Ntor = p%Ntor this % data ( i ) = p if ( p % power > max_power ) max_power = p % power end do this % max_power = max_power print * , 'this%max_power = ' , this % max_power end subroutine function get_positive_part_method ( this ) result ( spectr ) !! implicit none class ( Spectrum ), intent ( in ) :: this type ( Spectrum ) :: spectr , tmp_spectr type ( SpectrumPoint ) :: p integer i , n print * , 'read positive' tmp_spectr = Spectrum ( this % size ) n = 0 do i = 1 , this % size p = this % data ( i ) if ( p % Ntor > 0 ) then n = n + 1 tmp_spectr % data ( n ) = p tmp_spectr % sum_power = tmp_spectr % sum_power + p % power end if end do tmp_spectr % size = n spectr = Spectrum ( n ) spectr % sum_power = tmp_spectr % sum_power do i = 1 , n spectr % data ( i ) = tmp_spectr % data ( i ) end do spectr % size = n spectr % direction = + 1 spectr % power_ratio = spectr % sum_power / this % sum_power spectr % input_power = spectr % power_ratio * this % input_power print * , this % size , n print * , 'sum_power ' , this % sum_power , spectr % sum_power print * , 'power_ratio ' , this % power_ratio , spectr % power_ratio print * , 'input_power ' , this % input_power , spectr % input_power end function get_positive_part_method function get_negative_part_method ( this ) result ( spectr ) !! implicit none class ( Spectrum ), intent ( in ) :: this type ( Spectrum ) :: spectr , tmp_spectr type ( SpectrumPoint ) :: p integer i , n print * , 'negative positive' tmp_spectr = Spectrum ( this % size ) n = 0 do i = 1 , this % size p = this % data ( i ) if ( p % Ntor < 0 ) then n = n + 1 p % Ntor = - p % Ntor tmp_spectr % data ( n ) = p tmp_spectr % sum_power = tmp_spectr % sum_power + p % power end if end do tmp_spectr % size = n spectr = Spectrum ( n ) spectr % sum_power = tmp_spectr % sum_power do i = 1 , n spectr % data ( i ) = tmp_spectr % data ( n + 1 - i ) end do spectr % size = n spectr % direction = - 1 spectr % power_ratio = spectr % sum_power / this % sum_power spectr % input_power = spectr % power_ratio * this % input_power print * , this % size , n print * , 'sum_power ' , this % sum_power , spectr % sum_power print * , 'power_ratio ' , this % power_ratio , spectr % power_ratio print * , 'input_power ' , this % input_power , spectr % input_power end function get_negative_part_method function read_spectrum ( file_name ) result ( spectr ) !- чтение spectrum из файла implicit none type ( Spectrum ) :: spectr character ( len = * ), value :: file_name logical :: res integer i , n , stat real ( wp ) sum_power !integer, value :: size print * , file_name ! Check if the file exists inquire ( file = trim ( file_name ), exist = res ) if (. not . res ) then print * , 'spectrum file not exists' stop end if open ( 20 , file = file_name ) n =- 1 stat = 0 do while ( stat == 0 ) n = n + 1 read ( 20 , * , iostat = stat ) enddo spectr % size = n spectr % input_power = 0 spectr % sum_power = 0 spectr % direction = 1 spectr % power_ratio = 1 sum_power = 0 allocate ( spectr % data ( n )) print * , 'Spectrum size = ' , n rewind ( 20 ) do i = 1 , n read ( 20 , * ) spectr % data ( i )% Ntor , spectr % data ( i )% Npol , spectr % data ( i )% power sum_power = sum_power + spectr % data ( i )% power enddo !sum_power !do i=1,n !    spectr%data(i)%power = spectr%data(i)%power/sum_power !enddo spectr % sum_power = sum_power close ( 20 ) end function read_spectrum subroutine write_spectrum ( this , spectrum_name ) !! write spectrum to file implicit none class ( Spectrum ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: spectrum_name character ( len = 256 ) :: fname integer i , n integer , parameter :: iu = 21 write ( fname , '(\"lhcd/\", A, \".dat\")' ) spectrum_name print * , 'write to:' , fname open ( iu , file = fname ) do i = 1 , this % size write ( iu , '(3(ES22.14))' ) this % data ( i )% Ntor , this % data ( i )% Npol , this % data ( i )% power enddo end subroutine write_spectrum subroutine divide_spectrum ( spectr , pos_spectr , neg_spectr ) !! деление спектра на две части implicit none type ( Spectrum ), intent ( in ) :: spectr type ( Spectrum ), intent ( out ) :: pos_spectr , neg_spectr type ( Spectrum ) :: tmp_spectr type ( SpectrumPoint ) :: p integer i , pos_n , neg_n pos_spectr = Spectrum ( spectr % size ) tmp_spectr = Spectrum ( spectr % size ) pos_n = 0 neg_n = 0 do i = 1 , spectr % size p = spectr % data ( i ) if ( p % Ntor > 0 ) then pos_n = pos_n + 1 pos_spectr % data ( pos_n ) = p pos_spectr % sum_power = pos_spectr % sum_power + p % power end if if ( p % Ntor < 0 ) then neg_n = neg_n + 1 p % Ntor = - p % Ntor tmp_spectr % data ( neg_n ) = p tmp_spectr % sum_power = tmp_spectr % sum_power + p % power endif end do pos_spectr % size = pos_n neg_spectr = Spectrum ( neg_n ) neg_spectr % sum_power = tmp_spectr % sum_power do i = 1 , neg_n neg_spectr % data ( i ) = tmp_spectr % data ( neg_n + 1 - i ) end do neg_spectr % size = neg_n pos_spectr % direction = + 1 neg_spectr % direction = - 1 pos_spectr % power_ratio = pos_spectr % sum_power / spectr % sum_power neg_spectr % power_ratio = neg_spectr % sum_power / spectr % sum_power pos_spectr % input_power = pos_spectr % power_ratio * spectr % input_power neg_spectr % input_power = neg_spectr % power_ratio * spectr % input_power print * , pos_n , neg_n print * , 'sum_power ' , spectr % sum_power , pos_spectr % sum_power , neg_spectr % sum_power print * , 'power_ratio ' , pos_spectr % power_ratio , neg_spectr % power_ratio print * , 'input_power ' , spectr % input_power , pos_spectr % input_power , neg_spectr % input_power end subroutine function make_spline_approximation ( spectr ) result ( appx_spectr ) !! approximation of input LH spectrum use constants , only : zero , xsgs use spline_module use rt_parameters , only : nnz , ntet , pabs0 implicit none type ( Spectrum ), intent ( in ) :: spectr type ( Spectrum ) :: appx_spectr integer :: ispectr , ispl real ( wp ), allocatable :: ynzm0 (:), pm0 (:) real ( wp ), allocatable :: ynzm (:), pm (:) real ( wp ), allocatable :: yn2z (:), powinp (:) integer innz , i real ( wp ) dxx , xx0 , xx1 , xx2 , yy1 , yy2 , pinp real ( wp ) dpw , dpower , pwcurr , ptot , dynn real ( wp ) pmax , pnorm , plaun ispectr = spectr % direction plaun = spectr % input_power ispl = spectr % size allocate ( ynzm ( nnz ), pm ( nnz )) allocate ( ynzm0 ( ispl ), pm0 ( ispl )) allocate ( yn2z ( ispl ), powinp ( ispl )) do i = 1 , spectr % size ynzm0 ( i ) = spectr % data ( i )% Ntor pm0 ( i ) = spectr % data ( i )% power end do call splne ( ynzm0 , pm0 , ispl , yn2z ) innz = 100 * ispl dxx = ( ynzm0 ( ispl ) - ynzm0 ( 1 )) / innz xx2 = ynzm0 ( 1 ) yy2 = pm0 ( 1 ) pinp = 0 d0 do i = 1 , innz xx1 = xx2 yy1 = yy2 xx2 = xx1 + dxx call splnt ( ynzm0 , pm0 , yn2z , ispl , xx2 , yy2 , dynn ) dpw = . 5 d0 * ( yy2 + yy1 ) * ( xx2 - xx1 ) pinp = pinp + dpw end do dpower = pinp / dble ( nnz ) xx2 = ynzm0 ( 1 ) yy2 = pm0 ( 1 ) pwcurr = 0 ptot = zero do i = 1 , nnz - 1 xx0 = xx2 11 continue xx1 = xx2 yy1 = yy2 xx2 = xx1 + dxx call splnt ( ynzm0 , pm0 , yn2z , ispl , xx2 , yy2 , dynn ) dpw = . 5 d0 * ( yy2 + yy1 ) * ( xx2 - xx1 ) if ( pwcurr + dpw . gt . dpower ) then xx2 = xx1 + dxx * ( dpower - pwcurr ) / dpw call splnt ( ynzm0 , pm0 , yn2z , ispl , xx2 , yy2 , dynn ) dpw = . 5 d0 * ( yy2 + yy1 ) * ( xx2 - xx1 ) pwcurr = pwcurr + dpw else pwcurr = pwcurr + dpw go to 11 end if ynzm ( i ) = . 5 d0 * ( xx2 + xx0 ) pm ( i ) = pwcurr ptot = ptot + pwcurr pwcurr = zero end do ynzm ( nnz ) = . 5 d0 * ( ynzm0 ( ispl ) + xx2 ) pm ( nnz ) = pinp - ptot pnorm = plaun * xsgs / ( pinp * ntet ) pmax =- 1 d + 10 do i = 1 , nnz call splnt ( ynzm0 , pm0 , yn2z , ispl , ynzm ( i ), powinp ( i ), dynn ) pm ( i ) = pm ( i ) * pnorm if ( pm ( i ). gt . pmax ) pmax = pm ( i ) ynzm ( i ) = dble ( ispectr ) * ynzm ( i ) !sav2009 end do !pabs=pabs0*pmax/1.d2 appx_spectr = Spectrum ( nnz ) do i = 1 , nnz appx_spectr % data ( i ) = SpectrumPoint ( power = pm ( i ), Ntor = ynzm ( i ), Npol = 0 ) end do appx_spectr % input_power = plaun appx_spectr % max_power = pmax appx_spectr % direction = ispectr appx_spectr % power_ratio = spectr % power_ratio end function end module spectrum_mod","tags":"","loc":"sourcefile\\2_spectrum.f90.html"},{"title":"1_chebyshev.f90 – FRTС project","text":"Source Code module chebyshev !! Chebyshev fit use kind_module implicit none contains SUBROUTINE chebft1 ( a , b , c , n , func ) !! Chebyshev fit: Given a function func, lower and upper limits !! of the interval [a,b], and a maximum degree n, this routine !! computes the n coefficients c(k) such that func(x) approximately = !! SUMM_(k=1)&#94;(k=n)[c(k)*T(k-1)(y)]-c(1)/2, where y and x are related by !! (5.8.10). This routine is to be used with moderately large n !! (e.g., 30 or 50), the array of cs subsequently to be truncated !! at the smaller value m such that c(m+1) and subsequent elements !! are negligible. Parameters: Maximum expected value of n, and ð. implicit none INTEGER n , NMAX real ( wp ) a , b , c ( n ), func , PI EXTERNAL func PARAMETER ( NMAX = 50 , PI = 3.141592653589793d0 ) INTEGER j , k real ( wp ) bma , bpa , fac , y , f ( NMAX ) real ( wp ) sum bma = 0.5d0 * ( b - a ) bpa = 0.5d0 * ( b + a ) do k = 1 , n y = cos ( PI * ( k - 0.5d0 ) / n ) f ( k ) = func ( y * bma + bpa ) end do fac = 2.d0 / n do j = 1 , n sum = 0.d0 do k = 1 , n sum = sum + f ( k ) * cos (( PI * ( j - 1 )) * (( k - 0.5d0 ) / n )) end do c ( j ) = fac * sum end do return END FUNCTION chebev ( a , b , c , m , x ) !! Chebyshev evaluation: All arguments are input. !! c(1:m) is an array of Chebyshev coefficients, the first m elements !! of c output from chebft (which must have been called with !! the same a and b). The Chebyshev polynomial evaluated !! and the result is returned as the function value. implicit none INTEGER m real ( wp ) chebev , a , b , x , c ( m ) INTEGER j real ( wp ) d , dd , sv , y , y2 if (( x - a ) * ( x - b ). gt . 0.d0 ) pause 'x not in range in chebev' d = 0.d0 dd = 0.d0 y = ( 2.d0 * x - a - b ) / ( b - a ) y2 = 2.d0 * y do j = m , 2 , - 1 sv = d d = y2 * d - dd + c ( j ) dd = sv end do chebev = y * d - dd + 0.5d0 * c ( 1 ) return END SUBROUTINE chder ( a , b , c , cder , n ) !! Given a,b,c(1:n), as output from routine chebft(), and given n, !! the desired degree of approximation (length of c to be used), !! this routine returns the array cder(1:n), the Chebyshev !! coefficients of the derivative of the function whose coefficients !! are c(1:n). implicit none INTEGER n real ( wp ) a , b , c ( n ), cder ( n ) INTEGER j real ( wp ) con cder ( n ) = 0.d0 cder ( n - 1 ) = 2 * ( n - 1 ) * c ( n ) do j = n - 2 , 1 , - 1 cder ( j ) = cder ( j + 2 ) + 2 * j * c ( j + 1 ) end do con = 2.d0 / ( b - a ) do j = 1 , n cder ( j ) = cder ( j ) * con end do return END end module chebyshev","tags":"","loc":"sourcefile\\1_chebyshev.f90.html"},{"title":"1_maxwell.f90 – FRTС project","text":"Source Code module maxwell !! Все что относится к распределению Максвелла use kind_module use constants , only : zero , pisqrt , pi2sqrt , pqe implicit none integer , parameter :: i0 = 1002 real ( wp ) v_grid ( i0 , 100 ) !! сетка обычных скоростей real ( wp ) vij ( i0 , 100 ), fij0 ( i0 , 100 , 2 ), fij ( i0 , 100 , 2 ) real ( wp ) dfij ( i0 , 100 , 2 ), dij ( i0 , 100 , 2 ) logical flag_d0 !! бывший d0 integer jindex , kindex !!common/dddql/ d0,jindex,kindex contains function currlhcd ( v , f ) result ( curs ) implicit none real ( wp ), intent ( in ) :: v (:), f (:) real ( wp ) curs integer i0 , k real ( wp ) vl , vr , fl , fr curs = 0.d0 i0 = size ( v ) do k = 1 , i0 - 1 vl = v ( k ) vr = v ( k + 1 ) fl = f ( k ) fr = f ( k + 1 ) curs = curs + ( fl * vl + fr * vr ) / 2 d0 * ( vr - vl ) end do end function create_vt_grid ( vclt ) result ( vt_grid ) !! создание сетки тепловых скоростей implicit none real ( wp ), intent ( in ) :: vclt real ( wp ) :: vt_grid ( i0 ) real ( wp ) vmax integer i !r=dble(j)/dble(nr+1) !vclt=3.d10/fvt(r) vmax = 2.d0 * vclt do i = 1 , i0 vt_grid ( i ) = dble ( i - 1 ) * vmax / dble ( i0 - 1 ) end do end function subroutine init_vi ( vclt , vi ) real ( wp ), intent ( in ) :: vclt real ( wp ), intent ( out ) :: vi ( i0 ) real ( wp ) vmax integer i vmax = 2.d0 * vclt do i = 1 , i0 vi ( i ) = dble ( i - 1 ) * vmax / dble ( i0 - 1 ) end do end subroutine subroutine init_fmaxw_classic ( vclt , enorm , fi , dfi ) real ( wp ), intent ( in ) :: vclt , enorm real ( wp ), intent ( out ) :: fi ( i0 ), dfi ( i0 ) real ( wp ) vi , vmax integer i vmax = 2.d0 * vclt do i = 1 , i0 vi = dble ( i - 1 ) * vmax / dble ( i0 - 1 ) if ( vi < vclt ) then fi ( i ) = fmaxw_classic ( vi , enorm , dfi ( i )) else fi ( i ) = zero dfi ( i ) = zero end if end do end subroutine subroutine init_fmaxw_ext ( vclt , enorm , fi , dfi ) real ( wp ), intent ( in ) :: vclt , enorm real ( wp ), intent ( out ) :: fi ( i0 ), dfi ( i0 ) real ( wp ) vi , vmax integer i vmax = 2.d0 * vclt do i = 1 , i0 vi = dble ( i - 1 ) * vmax / dble ( i0 - 1 ) if ( vi < vclt ) then fi ( i ) = fmaxw_ext ( vi , enorm , dfi ( i )) else fi ( i ) = zero dfi ( i ) = zero end if end do end subroutine real ( wp ) function funmaxwell ( v , dfunmaxwell ) !! распределение Максвелла !!  f(v) = \\frac{1}{\\sqrt{2\\pi}} \\exp(-\\frac{1}{2} v&#94;2 )) !! и его производная !!  dfmaxw = - v \\cdot f(v)  implicit none real ( wp ) v , dfunmaxwell , arg arg = - 0.5d0 * v ** 2 funmaxwell = exp ( arg ) / pi2sqrt dfunmaxwell = - v * funmaxwell end real ( wp ) function fmaxw_classic ( v , alfa2 , dfmaxw ) !! распределение Максвелла с альфа-частицами !!  f(v) = \\frac{1}{\\sqrt{2\\pi}} \\exp(-\\frac{1}{2} v&#94;2 (1.0 + \\frac{1}{2} \\cdot alfa_2 \\cdot v&#94;2)) !! и его производная !!  dfmaxw = - v \\cdot (1.0 + alfa_2 \\cdot v&#94;2) \\cdot f(v)  implicit none real ( wp ) v , alfa2 , dfmaxw real ( wp ) arg , alfa , api , b , psiq , f , df arg =- 0.5d0 * v ** 2 * ( 1.d0 + 0.5d0 * alfa2 * v ** 2 ) fmaxw_classic = dexp ( arg ) / pi2sqrt dfmaxw =- v * ( 1.d0 + alfa2 * v ** 2 ) * fmaxw_classic end real ( wp ) function fmaxw_ext ( v , alfa2 , dfmaxw ) !!  alfa = \\sqrt{alfa_2}  !!  api = 2 \\cdot alfa \\cdot \\exp({-\\frac{1}{4 alfa_2}})  !!  b = 2 - erf(0.5/alfa) + api  !!  f = psiq(v, alfa_2)  !!  fmaxw = \\frac{f+api}{b \\sqrt{2\\pi}}  implicit none real ( wp ) v , alfa2 , dfmaxw real ( wp ) arg , alfa , api , b , f , df alfa = dsqrt ( alfa2 ) api = 2.d0 * alfa * dexp ( - 0.25d0 / alfa2 ) / pisqrt b = 2.d0 - erfcc ( 0.5d0 / alfa ) + api f = psiq ( v , alfa2 ) fmaxw_ext = ( f + api ) / b / pi2sqrt df =- v * (( 1.d0 - alfa2 * v ** 2 ) * f + api ) dfmaxw = df / b / pi2sqrt end real ( wp ) function fmaxw ( v , alfa2 , dfmaxw ) implicit none real ( wp ) v , alfa2 , dfmaxw real ( wp ) arg , alfa , api , b , f , df if ( alfa2 . le . zero ) then arg =- 0.5d0 * v ** 2 * ( 1.d0 - 0.5d0 * alfa2 * v ** 2 ) fmaxw = dexp ( arg ) / pi2sqrt dfmaxw =- v * ( 1.d0 - alfa2 * v ** 2 ) * fmaxw else alfa = dsqrt ( alfa2 ) api = 2.d0 * alfa * dexp ( - 0.25d0 / alfa2 ) / pisqrt b = 2.d0 - erfcc ( 0.5d0 / alfa ) + api f = psiq ( v , alfa2 ) fmaxw = ( f + api ) / b / pi2sqrt df =- v * (( 1.d0 - alfa2 * v ** 2 ) * f + api ) dfmaxw = df / b / pi2sqrt end if end real ( wp ) function psiq ( v , alfa2 ) !!  psiq=exp(ksiV**2)*erfcc(ksiV)*exp(-0.25/alfa2)  implicit none real ( wp ) v , alfa2 , df real ( wp ) x , t , z , f , asymp , alfa , q , u real ( wp ), parameter :: zmax = 1 0.d0 alfa = dsqrt ( alfa2 ) q =- 0.25d0 / alfa2 x = 0.5d0 * ( alfa * v ** 2 - 1.d0 / alfa ) z = abs ( x ) if ( z . gt . zmax ) then !asymptotics f = dexp ( q ) * ( 1.d0 - 0.5d0 / z ** 2 + 0.75d0 / z ** 4 - 1 5.d0 / 8.d0 / z ** 6 ) / z / pisqrt else t = 1.d0 / ( 1.d0 + 0.5d0 * z ) f = t * exp ( q - 1.26551223d0 + t * ( 1.00002368d0 + t * (. 37409196 d0 + t * & &(. 09678418 d0 + t * ( - . 18628806 d0 + t * (. 27886807 d0 + t * ( - 1.13520398d0 + t * & &( 1.48851587d0 + t * ( - . 82215223 d0 + t * . 17087277 d0 ))))))))) end if if ( x . lt . zero ) then u =- 0.5d0 * v ** 2 + 0.25d0 * alfa2 * v ** 4 !u=x**2-0.25d0/alfa2 f = 2.d0 * dexp ( u ) - f end if psiq = f return end function erfcc ( x ) implicit none real ( wp ) erfcc , x real ( wp ) t , z real ( wp ), parameter :: zmax = 1 0.d0 z = abs ( x ) if ( z . gt . zmax ) then !asymptotics erfcc = ( 1.d0 - 0.5d0 / z ** 2 + 0.75d0 / z ** 4 - 1 5.d0 / 8.d0 / z ** 6 ) / z / pisqrt erfcc = exp ( - z * z ) * erfcc else t = 1.d0 / ( 1.d0 + 0.5d0 * z ) erfcc = t * exp ( - z * z - 1.26551223d0 + t * ( 1.00002368d0 + t * (. 37409196 d0 + t * & &(. 09678418 d0 + t * ( - . 18628806 d0 + t * (. 27886807 d0 + t * ( - 1.13520398d0 + t * & &( 1.48851587d0 + t * ( - . 82215223 d0 + t * . 17087277 d0 ))))))))) end if if ( x . lt . zero ) erfcc = 2.d0 - erfcc return end end module maxwell","tags":"","loc":"sourcefile\\1_maxwell.f90.html"},{"title":"1_spline.f90 – FRTС project","text":"Source Code module spline_module !! сплайны use kind_module implicit none contains subroutine splne ( x , y , n , y2 ) integer , parameter :: nn = 3001 real ( wp ), parameter :: zero = 0 d0 integer n real ( wp ) x ( n ), y ( n ), y2 ( n ), u ( nn ) integer i , k real ( wp ) p , qn , un , sig if ( n . gt . nn ) stop 'n>nn in splne!' y2 ( 1 ) = zero u ( 1 ) = zero do i = 2 , n - 1 sig = ( x ( i ) - x ( i - 1 )) / ( x ( i + 1 ) - x ( i - 1 )) p = sig * y2 ( i - 1 ) + 2.d0 y2 ( i ) = ( sig - 1.d0 ) / p u ( i ) = ( 6.d0 * (( y ( i + 1 ) - y ( i )) / ( x ( i + 1 ) - x ( i )) - ( y ( i ) - y ( i - 1 )) / ( x ( i ) - x ( i - 1 ))) / ( x ( i + 1 ) - x ( i - 1 )) - sig * u ( i - 1 )) / p end do qn = zero un = zero y2 ( n ) = ( un - qn * u ( n - 1 )) / ( qn * y2 ( n - 1 ) + 1.d0 ) do k = n - 1 , 1 , - 1 y2 ( k ) = y2 ( k ) * y2 ( k + 1 ) + u ( k ) end do return end subroutine splnt ( xa , ya , y2a , n , x , y , dy ) real ( wp ), parameter :: zero = 0 d0 integer n real ( wp ) xa ( n ), ya ( n ), y2a ( n ) integer k , klo , khi real ( wp ) x , h , a , b , aa , bb , hh , ax , bx , y , dy klo = 1 khi = n do while ( khi - klo . gt . 1 ) k = ( khi + klo ) / 2 if ( xa ( k ). gt . x ) then khi = k else klo = k endif end do h = xa ( khi ) - xa ( klo ) if ( h . eq . zero ) then write ( * , * ) 'bad x input in splnt(), x=' , x write ( * , * ) 'klo=' , klo , ' kho=' , khi stop end if a = ( xa ( khi ) - x ) / h b = ( x - xa ( klo )) / h aa = a ** 2 bb = b ** 2 hh = h ** 2 / 6 d0 ax =- 1 d0 / h bx =- ax y = a * ya ( klo ) + b * ya ( khi ) + ( a * ( aa - 1 d0 ) * y2a ( klo ) + b * ( bb - 1 d0 ) * y2a ( khi )) * hh dy = ax * ya ( klo ) + bx * ya ( khi ) + ax * (( 3.d0 * aa - 1 d0 ) * y2a ( klo ) - ( 3.d0 * bb - 1 d0 ) * y2a ( khi )) * hh end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine dsplnt ( xa , ya , y2a , n , x , y , dy , ddy ) real ( wp ), parameter :: zero = 0 d0 integer n real ( wp ) xa ( n ), ya ( n ), y2a ( n ) integer k , klo , khi real ( wp ) x , h , a , b , aa , bb , hh , ax , bx , y , dy , ddy klo = 1 khi = n do while ( khi - klo . gt . 1 ) k = ( khi + klo ) / 2 if ( xa ( k ). gt . x ) then khi = k else klo = k endif end do h = xa ( khi ) - xa ( klo ) if ( h . eq . zero ) then write ( * , * ) 'bad x input in splnt(), x=' , x write ( * , * ) 'klo=' , klo , ' kho=' , khi stop end if a = ( xa ( khi ) - x ) / h b = ( x - xa ( klo )) / h aa = a ** 2 bb = b ** 2 hh = h ** 2 / 6 d0 ax =- 1 d0 / h bx =- ax y = a * ya ( klo ) + b * ya ( khi ) + ( a * ( aa - 1 d0 ) * y2a ( klo ) + b * ( bb - 1 d0 ) * y2a ( khi )) * hh dy = ax * ya ( klo ) + bx * ya ( khi ) + ax * (( 3.d0 * aa - 1 d0 ) * y2a ( klo ) - ( 3.d0 * bb - 1 d0 ) * y2a ( khi )) * hh ddy = 6.d0 * ax * ax * ( a * y2a ( klo ) + b * y2a ( khi )) * hh end end module spline_module","tags":"","loc":"sourcefile\\1_spline.f90.html"},{"title":"Notes – FRTС project","text":"СОДЕРЖАНИЕ ВВЕДЕНИЕ Глава 1 .\nАНАЛИТИЧЕСКИЙ ПОДХОД К ЗАДАЧЕ О ЛУЧЕВЫХ ТРАЕКТОРИЯХ НИЖНЕГИБРИДНЫХ ВОЛН §1.1 Лучевые траектории нижнегибридных волн §1.2 Применение теории возмущений к уравнениям лучевых траекторий §1.3 Метод построения сохраняющего фазовый объем дискретного отображения и его применение к задаче о распространении нижнегибридных волн Глава 2. ОБЩИЕ СВОЙСТВА НИЖНЕГИБРИДНЫХ ВОЛН В ТОРОИДАЛЬНОЙ ПЛАЗМЕ §2.1    Структура доступного фазового пространства §2.2    Дискретное отображение для нижнегибридных волн... §2.3    Схема функционирования отображения §2.4 Исследование свойств нижнегибридных волн с\nпомощью дискретного отображения §2.5    Предельные случаи движения. §2.6 Общая картина распространения и затухания волн\nв нижнегибридном диапазоне частот Глава 3. ПОЛОИДАЛЬНЫЙ РЕЗОНАНС §3-1 Причины возникновения резонанса §3.2 Анализ волновых уравнений в окрестности особой точки §3.3 Возможность использования полоидального резонанса для нагрева плазмы в токамаках с малым аспект\nным отношением ЗАКЛЮЧЕНИЕ ЛИТЕРАТУРА [1]:","tags":"","loc":"page\\index.html"},{"title":"Введение – FRTС project","text":"Для стационарной работы управляемого термоядерного реактора необходимо поддержание в нем безындукционного тороидального электрического тока. Одним из наиболее эффективных и экспериментально исследованных способов генерации тока является метод, основанный на вводе в плазму нижнегибридных волн, то есть косых ленгмюровских волн с частотами, в несколько раз превышающими центральную нижнегибридную. В основе механизма создания тока этими волнами лежит передача продольного (параллельного магнитному полю) импульса волны надтепловым электронам плазмы за счет бесстолкновительного затухания Ландау. При этом условием резонансного взаимодействия волны с электронами является близость её фазовой скорости (которая равна , где - продольная составляющая показателя преломления волны) к скорости электронов. Анализ кинетического уравнения показывает, что такое взаимодействие должно приводить к образованию плато на функции распределения электронов, границы которого зависят от спектра продольных замедлений присутствующих в плазме нижнегибридных волн [1,2]. Обычно, нижнегибридные волны вводят в плазму с помощью системы сфазированных волноводов - грилла, позволяющего возбуждать волны необходимой поляризации с требуемым спектром [3]. Предположение о постоянстве функции распределения в области плато позволяет легко найти эффективность генерации тока, которую обычно определяют как , где -\nвеличина генерируемого тока в Ма, - вкладываемой мощности в МВт, плотность плазмы в единицах , a - большой радиус токамака в метрах. Простые оценки дают [4] где - соответственно нижняя и верхняя граница спектра продольных замедлений, \nа - кулоновский логарифм.\nСущественно, что эффективность тем больше, чем меньшие присутствуют в спектре нижнегибридных волн в плазме. Нижняя граница допустимых значений связана с критерием Голанта-Стикса [5], \nопределяющем минимальное при котором происходит трансформация волны в быструю моду. Уточнению выражения для эффективности генерации тока было посвящено множество работ. При этом использовались как аналитические оценки, так и численное решение кинетического уравнения. Среди факторов, оказывающих достаточно существенное влияние по сравнению с простой одномерной моделью можно отметить двухмерность интеграла столкновений [6], релятивисткие эффекты [7], уменьшение числа носителей тока из-за захвата достаточно замедлившихся вследствии столкновений электронов на банановые орбиты [8,9], пространственную диффузию быстрых частиц из-за разрушения магнитных поверхностей [10,11], нестационарность условий, то есть наличие остаточного вихревого электрического поля [12-14]. В целом, при учете всех этих факторов, общий вывод остается вполне благоприятным - нижнегибридные волны должны быть весьма эффективным средством поддержания стационарного тока. Большое количество экспериментов на различных токамаках в целом подтверждают описанную грубую теоретическую модель. Первые свидетельства возможности создания тока нижнегибридными волнами были получены на линейной установке в 1979 г.[15]. Эксперименты на токамаках в первое время были посвящены доказательству самой возможности генерации тока, поскольку наличие вихревого электрического поля оставляло неясным, какая часть тока создается нижнегибридными волнами, а какая - вихревым электрическим полем. Здесь можно выделить результаты на Versator[l6], продемонстрировавшие различный вклад в создаваемый ток волнами, распространяющимися по или против индукционного тока, эксперименты на PLT [17], проводившиеся без вихревого поля, в которых ток, превышающий 100 кА создавался исключительно ВЧ волной, эксперименты на ALCATOR-C [18], в которых были достигнуты рекордные плотности плазмы. Сейчас уже нет никаких сомнений в том, что нижнегибридные волны позволяют заместить большую часть индукционного тока. Обзор многих экспериментов имеется в [19]. Ряд новых успехов был достигнут за последние годы. Так в [20] было показано в соответствии с теорией, что возможно увеличение эффективности генерации тока в PLT за счёт уменьшения ширины спектра  по . \nНовый грилл, возбуждающий волны частотой f=2.45 ГГц и узким спектром на ASDEX повысил эффективность генерации тока до значений [21]. \nЭксперименты на JT-60 позволили поднять значения тока до 2 МА и добиться эффективности [ 22]. В этих экспериментах эффективность генерации тока фактически достигла теоретической. Однако более детальное сопоставление экспериментальных результатов и теоретических предсказаний обнаруживает две широко известные проблемы, которые обычно называют предел по плотности и спектральный зазор. Предел по плотности наблюдается практически во всех экспериментах по генерации тока. Вообще говоря, в соответствии с теорией [1,6] эффективность генерации тока n не должна зависеть от плотности плазмы. Однако многочисленные эксперименты показывают, что при превышении плотности плазмы некоторого критического значения, эффективность резко падает, а генерация тока прекращается. Это обстоятельство могло бы быть очень неприятным с точки зрения перспектив использования нижнегибридных волн в токамаке реакторе. Однако позднее выяснилось, что предельная плотность может быть увеличена путем увеличения частоты вводимой волны [23]. Существующее теоретическое объяснение этих фактов [4,24] основано на предположении о том, что существует не абсолютный предел по плотности для эффективности генерации тока, а постепенное прекращение электронного тока из-за того, что при частотах немного превышающих нижнегибридную, мощность волны начинает передаваться ионам , а не электронам. Однако эксперименты при высоких частотах не согласуются с этой моделью. Оказывается, что генерация тока в этом случае прекращается при заметно меньших плотностях, когда взаимодействие волны с ионами еще принебрежимо мало. Среди попыток уточнить или дополнить эту простую схему можно отметить работы [25,26], в которых предполагается, что с ионами взаимодействует волна, образующаяся в результате параметрического распада волны накачки. Однако и сейчас врядли можно утверждать, что наличие предела по плотности имеет исчерпывающее теоретическое объяснение. Проблема спектрального зазора [27] заключается в следующем. Обычно, волны, создаваемые с помощью грилла имеют малые значения и следовательно могут взаимодействовать лишь с очень быстрыми электронами. Количество таких электронов экспоненциально мало и они не могут переносить даже малой доли тока, наблюдаемого в экспериментах. Естественным объяснением является предположение об уширении спектра нижнегибридных волн в процессе их распространения в плазме токамака, однако механизм такого уширения до сих пор остается неясным. В первую очередь нужно отметить, что спектр нижнегибридных волн изменяется в процессе распространения уже в линейном по полю волны приближении вследствии неоднородности плазмы. Наряду с этим классическим процессом, к которому мы вернемся несколько позже, было предложено свыше десяти других механизмов. Так, в [28,29] была рассмотрена роль рассеяния волны на флуктуациях плотности. При прохождении волной турбулентного слоя на периферии плазмы, она может рассеиваться на локальных что приводит к увеличению Другой механизм рассеяния рассмотрен в работах [30,31]. В них обнаружено, что отклонение магнитных поверхностей от тороидальной симметрии, которое может быть связано как с гофрировкой магнитного поля, так и с наличием магнитных островов вызывает рассеяние падающей волны и ведет таким образом к уширению спектра. В работе [32] рассмотрены пондеромоторные эффекты, возникающие на периферии плазмы. Показано, что вследствии этих эффектов могут возникать высокие пространственные гармоники во вводимом спектре Np, которые взаимодействуя с медленными электронами могут заполнять зазор. Механизм требует накопления большой энергии волны и при этом сохранения достаточной пространственной когерентности. Другое объяснение спектрального зазора, включающее нелинейные эффекты, которые могут уширять резонансное условие Ландау было предложено в работе [33]. При этом в качестве механизма, вызывающего диффузию нерезонансных электронов предлагается нарушение приближения случайных фаз и появление корреляции мод. вызванное наличием в плазме узких волновых пучков конечной ширины. В случае, если нижнегибридные волны вызывают сильную анизоторопию функции распределения, плазма может оказаться неустойчивой по отношению к другим волнам, которые будут стремиться уменьшить эту анизотропию. Такая неустойчивость, которую называют \"веерной\" неустойчивостью [34] может приводить к возбуждению волн с малыми продольными фазовыми скоростями, заполняющих спектральный зазор[35]. Уже само по себе количество этих объяснений показывает сложность проблемы, а также отсутствие общепринятого решения. Действительно, каждый из предлагавшихся механизмов имеет свои недостатки и не один из них не может количественно объяснить разнообразные экспериментальные результаты. Вполне вероятно, что в реальном эксперименте одновременно действует несколько факторов, но в любом случае все они должны проявляться на фоне того изменения спектра, которое происходит в соответствии с волновым уравнением. Поэтому естественным выглядит в первую очередь выяснить насколько сильны эффекты, описываемые линейными электродинамическими уравнениями и есть ли необходимость искать другие объяснения. Для решения задачи о распространении нижнегибридных волн в плазме в подавляющем большинстве работ используется метод лучевых траекторий (приближение геометрической оптики) [36,37]. Среди попыток найти более точное решение проблемы можно отметить две работы, в [38] численно решалось упрощенное волновое уравнение. Эта задача является чрезвычайно трудоемкой, однако результат лишь показал соответствие с геометрико-оптическим решением. В [39,40] предложена модификация метода лучевых траекторий на основе комплексного метода ВКБ [41], использующего геометрико- оптическое описание вдоль луча и сохраняющего волновое описание поперек. Хотя, как утверждается в работе, возникающая в первом порядке этого метода дифракция в некоторых случаях может оказаться довольно существенной, логичным представляется вначале детально исследовать решения нулевого порядка, которые соответствуют лучевым траекториям. Первые исследования распространения нижнегибридных волн проводились в цилиндрическом приближении [42,43], \nвариации при этом строго ограничены. В работах [44,45] было показано, что существенное влияние на динамику изменения может оказывать полоидальная неоднородность системы, приводящая к несохранению полоидального волнового числа. В дальнейшим расчеты лучевых траекторий успешно использовались в качестве составной части кодов для моделирования генерации тока, и позволили объяснить многие экспериментальные результаты [46-48]. В то же время, вопрос о возможности заполнения спектрального зазора по этому механизму и условиях, от которых это зависит, до сих пор оставался открытым. Дело в том, что результаты вычислений оказывались сильно зависящими от числа лучей, используемых для описания спектра вводимой мощности, начальных условий и многочисленных параметров задачи [49,50]. Кроме того, численные расчеты большого числа лучевых траекторий требуют заметных затрат компьютерного времени. В результате, несмотря на многочисленные работы, посвященные вычислению лучевых траекторий нижнегибридных волн, общие закономерности их распространения и замедления до сих пор оставались неясными. Выяснению общих свойств лучевых траекторий нижнегибридных волн в плазме токамака и посвящена настоящая диссертация Необходимо отметить, что эта проблема имеет и определений общетеоретический интерес. Дело в том, что динамика лучей в неоднородных средах может быть описана в гамильтоновском приближении [51]. Большой интерес к исследованию динамики гамильтоновских систем, возникший в последнее время, в первую очередь связан с открытием нового явления, называемого динамическим хаосом [52-54]. Впервые, проблема, решение которой привело впоследствии к обнаружению динамического хаоса была сформулирована ещё Пуанкаре и заключалась в следующем: как изменится качественная картина движения если на интегрируемую гамильтоновскую систему наложено слабое возмущение, делающее её неинтегрируемой. Лишь в 60-е годы был получен ответ на этот вопрос, который составил основу фундаментальной теоремы Колмогорова-Арнольда-Мозера (КАМ) [55-57]. В ней, упрощенно говоря, утверждается, что если возмущение мало, то движение качественно остается таким же как и в невозмущенном случае, за исключением принебрежимо малого набора начальных условий. Численные исследования поведения различных систем в случаях, когда возмущение достаточно велико и условие применимости теоремы КАМ нарушены показали, что картина движения при этом драматически изменяется [5S-6O]. Оказалось, что в этих условиях движение принимает стохастический характер; это явление и получило название динамического хаоса [61]. В настоящее время \"хаос\" является быстро развивающейся областью физики, его появление было обнаружено в самых разнообразных физических задачах. Однако отражение новых идей в рамках лучевой динамики находится пока лишь в начальной стадии. По существу дела имеется только один обзор [62], в котором распространение волн в слабонеоднородных средах в приближении геометрической оптики исследуется методами современней нелинейной теории, позволяющими описать явления различных нелинейных резонансов и хаоса. Однако, по сравнению с рассматривавшимися в работах [63-65] случаями распространения световых волн в волноводах и звуковых волн в океане исследуемая нами задача имеет очень существенную особенность. Она заключается в необычном законе дисперсии электростатических волн в плазме - соответствующий гамильтониан оказывается незнакоопределенным. Это означает, что механическая аналогия задачи соответствует движению частиц, одна из которых имеет отрицательную массу. Таким образом, волновая природа гамильтоновских уравнений вносит в рассматриваемом случае существенную специфику, что, как оказывается приводит к появлению ряда необычных свойств, невозможных в механических задачах. В первой главе диссертации описан аналитический подход к задаче. В §1.1 записаны основные уравнения - уравнения лучевых траекторий с учетом реалистичной геометрии магнитных поверхностей, а также упомянута разработанная программа, осуществляющая их численное решение. В дальнейшем, эта программа используется для сопоставления с аналитическими результатами. Первым шагом в аналитическом исследовании задачи является применение к ней теории возмущений. Малыми при этом считаются факторы, определяющие отклонение системы от цилиндрической симметрии - тороидальность и параметры, связанные с геометрическим отличием магнитных поверхностей от вложенных окружностей (шафрановский сдвиг, эллиптичность, треугольность и т.д.). Именно эти факторы могут быть ответственными за накапливающиеся изменения Использование теории возмущений позволяет проинтегрировать уравнения лучевых траекторий и получить явную формулу, описывающую изменение на пути до радиуса наибольшего проникновения волны в плазму. Применимость формулы, естественно, ограничена малыми значениями возмущения и она дает заметную погрешность для токамаков с большой вытянутостью магнитных поверхностей. Однако оказывается, что если скорректировать формулу таким образом, чтобы определяемое ей изменение импульса (роль импульса здесь играет полоидальное волновое число m) удовлетворяло условию сохранения фазового объема, то таким образом можно расширить диапазон допустимых возмущений, сделав её применимой практически для любого токамака. Однако, что ещё более существенно, на основе такой, сохраняющей фазовый объем формулы, может быть построено дискретное рекуррентное отображение, описывающее долговременное поведение траекторий в токамаке. В §1.3 предложен общий способ построения таких отображений для любых гамильтоновских систем и продемонстрирована эффективность его применения на примере задачи о диффузии силовых линий магнитного поля. Вторая глава посвящена исследованию общих свойств нижнегибридных волн в токамаке с помощью дискретного отображения. По существу дела исследуется динамика довольно необычной гамильтоновской системы. В §2.1 очерчены границы фазового пространства задачи, при этом получено обобщение критерия Голанта-Стиикса для случая тороидальной плазмы. Во втором параграфе, на основе рассмотренного ранее подхода построено дискретное отображение, определяющее динамику распространения и замедления волны в токамаке. Отображение учитывает возможность линейной трансформации волны и описывает ее поведение как в медленной, так и в быстрой моде. Связь уравнений отображения с параметрами волны и плазмы задается с помощью двух функций (или, точнее, набора функций двух типов), одна из них определяет нелинейную частоту движения, а другая связана с величиной действующего возмущения. В §2.2 исследуется форма этих функций и их ассимптотическое поведение. Важнейшей особенностью рассматриваемой системы оказывается слабая зависимость частоты невозмущенного движения от импульса (слабый шир) в области m>0 и стремление ее к ассимптотическому пределу при больших значениях m. Это обстоятельство приводит к возникновению системы резонансов, когда замедление волны, в приближении холодной плазмы, стремится к бесконечности, что приводит к ее затуханию независимо от температуры плазмы. Наличие резонансов связано с эффектом синхронизации частот и их проявлением является появление периодических аттракторов для траекторий в малом сечении токамака. Впервые резонансы такого типа были обнаружены в работе [66]. В эллиптической плазме эти резонансы являются доступными для слабозамедленных волн, а при отсутствии эллиптичности изменение , для волн о начальным m=0 в резонансных условиях оказывается конечным, но достаточным для затухания при характерных для современных токамаков температурах плазмы. Движение в области m<=0 является стохастическим, причем порог по возмущению для возникновения динамического хаоса очень низок и зона хаотического движения должна присутствовать практически во всех токамаках. Возможность трансформации волн способствует увеличению хаоса. Соседство областей хаотического и регулярного движения приводит в резонансных условиях к возникновению перемежаемости, когда одна траектория включает в себя как регулярные, так и хаотические фрагменты. Исследование свойств траекторий в хаотическом и перемежаемом режимах приведено в §2.4. Отображение, описывающее распространение нижнегибридных волн имеет ряд особенностей по сравнению с известными в классической механике. Это связано в первую очередь о гиперболической природой исходных волновых уравнений. В пределе т-оо оно сводится к известному отображению окружности [67] и может рассматриваться как обобщение этого отображения. В §2.5 проанализированы некоторые свойства этого отбражения, в частности, рассмотрено движение при больших m и показано, что в этой области оно всегда имеет регулярный характер. Таким образом, достаточное для затухания замедление волны за счет стохастической диффузии в фазовом пространстве оказывается невозможным. Кроме того, в этом параграфе исследуется движение на границе хаотической зоны и области непрозрачности при т<0. Показано, что в случае круглого сечения магнитных поверхностей в этой области имеется узкий слой регулярных инвариантных кривых, : которые, однако, полностью разрушаются при наличии даже очень малой эллиптичности. В §2.6 представлена общая картина распространения волн в нижнегибридном диапазоне частот, показано место в ней периодических резонансов. На основании этой картины предложено I теоретическое объяснение проблем спектрального зазора и предела по плотности, трактующее их с единой точки зрения. Заполнение спектрального зазора предполагается возможным только в области параметров, соответствующей периодическим резонансам и возникающей перемежаемости, а предел по плотности связан с выходом из резонансного режима. В третьей главе рассмотрен новый резонансный механизм замедления волн в плазме, который условно назван \"полоидальный резонанс\". Резонанс возникает при наличии полоидальной неоднородности магнитного поля и связан с особенностью траекторий вблизи параболической .линии волнового уравнения. В этом смысле он аналогичен нижнегибридному резонансу, однако его частота в 5-10 раз выше нижнегибридной. В §3.2 показано, что прлоидальный резонанс связан с особенностями поля в волновом уравнении, степень особенности при этом как раз такова, чтобы обеспечивать конечное поглощение энергии независимо от температуры плазмы. Найден широкий класс соответствующих решений волнового уравнения. Различные аспекты возможного практического применения полоидального резонанса рассмотрены в §3.3. Предложено его использование для дополнительного нагрева плазмы в токамаках с малым аспектным отношением. На примере проектируемого в ФТИ им. Иоффе токамака Глобус обсуждаются различные схемы реализации этого предложения. В заключении сформулированы основные результаты работы. Автор выносит на защиту: Аналитический подход к задаче о лучевых траекториях нижне гибридных волн в тороидальной плазме; явную формулу, описывающую изменение вдоль траектории. Дискретное отображение, позволяющее описать долговременную эволюцию , и выявить общие свойств нижнегибридных волн в тороидальной плазме. Общую картину распространения и замедления нижнегибридных волн в тороидальной плазме, включающую явления динамического хаоса, периодические аттракторы и гамильтоновскую перемежаемость. Возможное объяснение на её основе проблем спектрального зазора и предела по плотности. Новый резонансный механизм замедления волн в плазме токамака- \"полоидальный резонанс\". Исследование возможностей его применения для нагрева плазмы в токамаках с малым аспектным отношением Работа выполнена в Физико-Техническом институте имени А.Ф.Иоффе. \nМатериалы, изложенные в диссертации, докладывались на международном совещании по генерации тока и нагреву плазмы в ИТЭР (Гархинг, 1989), международной конференции по сильным микроволнам в плазме (Суздаль, 1990), \nвсесоюзных конференциях по PQ физике плазмы и управляемого термоядерного синтеза (Звенигород, 1991,1992), \nVII всесоюзной конференции по взаимодействию электромагнитных излучений с плазмой (Душанбе, 1991), \n19 EPS конференции по управляемому синтезу и физике плазмы (Инсбрук, 1992),\nРоссийско-Английских совещаниях GULHAM-IOFFE symposium (Санкт-Петербург, 1991, Абингдон, 1992). \nОсновные результаты диссертации опубликованы в работах [49], [68-73].","tags":"","loc":"page\\introduction.html"},{"title":"Глава 1 – FRTС project","text":"СОДЕРЖАНИЕ ВВЕДЕНИЕ Глава 1 .\nАНАЛИТИЧЕСКИЙ ПОДХОД К ЗАДАЧЕ О ЛУЧЕВЫХ ТРАЕКТОРИЯХ НИЖНЕГИБРИДНЫХ ВОЛН §1.1 Лучевые траектории нижнегибридных волн §1.2 Применение теории возмущений к уравнениям лучевых траекторий §1.3 Метод построения сохраняющего фазовый объем дискретного отображения и его применение к задаче о распространении нижнегибридных волн Глава 2. ОБЩИЕ СВОЙСТВА НИЖНЕГИБРИДНЫХ ВОЛН В ТОРОИДАЛЬНОЙ ПЛАЗМЕ §2.1    Структура доступного фазового пространства §2.2    Дискретное отображение для нижнегибридных волн... §2.3    Схема функционирования отображения §2.4 Исследование свойств нижнегибридных волн с\nпомощью дискретного отображения §2.5    Предельные случаи движения. §2.6 Общая картина распространения и затухания волн\nв нижнегибридном диапазоне частот Глава 3. ПОЛОИДАЛЬНЫЙ РЕЗОНАНС §3-1 Причины возникновения резонанса §3.2 Анализ волновых уравнений в окрестности особой точки §3.3 Возможность использования полоидального резонанса для нагрева плазмы в токамаках с малым аспект\nным отношением ЗАКЛЮЧЕНИЕ ЛИТЕРАТУРА [1]:","tags":"","loc":"page\\chapter_1\\index.html"},{"title":"Лучевые траектории нижнегибридных волн – FRTС project","text":"§1.1 Лучевые траектории нижнегибридных волн Эффективным методом исследования распространения нижнегибридных волн в неоднородной плазме является метод лучевых\nтраекторхтй, основанный на квазиклассическом приближении. Это приближение позволяет находить ассимптотические\nрешения уравнений Максвелла в слабонеоднородной среде. Условие слабой неоднородности подразумевает, что длина волны в плазме должна быть много меньше характерных размеров плазменного образования. Это условие всегда достаточно хорошо удовлетворяется в нижнегибридном диапазоне частот [37]. Формально квази-классическое приближение является естественным обобщением поля по плоским волнам с медленно меняющейся амплитудой и быстро меняющейся фазой: Низший порядок этого приближения дает уравнения геометрико-оптических лучей: где - левая часть дисперсионного уравнения. Уравнения (1.1) определяют форму луча и изменение вдоль него\nволнового вектора .\nПредставляя поле на выходе нижнегибридной антенны - \"грилла”- в виде пучка из N лучей с некоторой координатой и волновым вектором и решая для каждого из них уравнения (1.1) можно для любого момента времени t восстановить фронт волны.\nОдновременно, уравнения (1.1) определяют изменение вдоль траектории продольной составляющей волнового вектора , которая играет ключевую роль в затухании волны по механизму Ландау. \nОднако сам процесс затухания этими уравнения не описывается. Его учет может быть произведен в следующем порядке квазиклассического приближения, дающем уравнение для переноса мощности вдоль траектории. \nОно может быть записано в виде: , где - декремент  затухания волны, и решаться одновременно с  уравнениями (1.1). \nВ дальнейшем мы будем в основном интересоваться системой уравнений (1.1), поскольку для\nдоли поглощенной мощности волны в зависимости от хорошие аналитические оценки [74]. Для того, чтобы записать уравнения (1.1) для проекций входящих в них векторов необходимо задать систему координат. \nМы выберем систему , связанную с магнитными поверхностями. При этом магнитные поверхности задаются уравнением , - здесь полоидальный, а - тороидальный угол. Такая система координат была введена в [75] и позволяет удобно задавать форму магнитных поверхностей через широко используемые характеристики-\nшафрановский сдвиг , эллиптичность . и треугольность . Ее связь с обычней цилиндрической системой координат дается выражениями: где - радиус магнитной оси. Функции определяют широкий класс магнитных поверхностей и с достаточной точностью позволяют отыскать практически любую равновесную конфигурацию в токамаке. Теперь небхедимо выразить функцию Н в (1.1) через координаты и канонически сопряженные им импульсы (мы используем этот термин, учитывая гамильтонсвскую форму лучевых уравнений, которая является следствием известной аналогии между геометрической оптикой и механикой материальных частиц). Дисперсионное уравнение в холодной плазме имеет вид [43]: Здесь , , \nгде - составляющая волнового вектора, перпендикулярная магнитному полю, , , - компоненты тензора диэлектрической\nпроницаемости .\nВ нижнегибридном диапазоне частот эти компоненты можно положить равными: , , , где - электронная и ионная\nплазменные частоты, - электронная циклотронная частота.\nТаким образом, неоднородность плазмы входит в компоненты тензора\nчерез плотность плазмы n и магнитное поле . Мы будем считать\nплотность постоянной вдоль магнитных поверхностей, то есть . Что касается магнитного поля и физических компонент показателя преломления и то для того, чтобы выразить их в выбранной системе координат нужно ввести метрический тензор . \nИспользуя выражения (1.3) имеем для его элементов: и при . \nЗаписывая уравнение в криволинейной системе координат получим \nдля контрвариантных компонент магнитного поля : где , и - соответственно полоидальный и тороидальный магнитный потоки.\nДля того, чтобы установить выражения для импульсов, канонически сопряженных выбранным координатам, \nможно ввести производящую функцию от новых координат и старых импульсов , \nгде - i-oe соотношение (1.2). \nТогда для новых импульсов ,\nчто является определением ковариантных координат вектора в выбранной системе координат . Теперь мы можем записать , что учитывая (1.5) дает где - угол между и полным магнитным полем В. \nТороидальная компонента магнитного поля определяется очевидным выражением ,\nа полоидальная равна . Наконец, к может быть найдено о помощью тождества .\nЗаписывая векторное произведение в римановом пространстве, задаваемом тензором получим где - контрвариантный метрический тензор. \nЕго элементы определяются выражением: . Разделив уравнения (1.1) на групповую скорость и переходя таким образом от физически неинтересного в данной задаче времени к длине траектории s получим окончательно: где должно быть выражено через канонические импульсы с помощью уравнений (1.6),   (1.7). \nСразу можно отметить, что в силу тороидальной симметрии системы Н не зависит от тороидального угла ,\nсоответственно последнее из уравнений (1.8) дает . \nТаким образом сохраняется вдоль траектории, а движение по определяется\nпри известных прямым интегрированием. \nПоэтому естественно рассматривать проекцию трехмерной траектории на малое сечение токамака плоскость . Самым прямым и практически всегда используемым способом нахождения лучевой траектории является \nчисленное интегрирование соответствующей системы уравнений. \nНами также была разработана программа, осуществляющая численное решение системы (1.8). \nОна была объединена с равновесным кодом [75], что позволило рассчитывать лучевые траектории\nв реалистичной магнитной конфигурации токамака. Примеры подобных рассчетов приведены на рис. 1,2. \nЗдесь показаны лучевые траектории для медленной и быстрой волн в проектируемой установке ИТЭР, \nкоторая характеризуется сильно вытянутой формой магнитных поверхностей. \nРасчеты проводились при следующих параметрах: , малый радиус , полный тороидальный ток ,\nцентральная плотность , центральная температура , .\nЧастота волны выбиралась таким образом, чтобы она лежала вблизи нижних границ диапазонов, \nгде мало поглощение ВЧ мощности на -частицах - f < 5ГГц - для медленной волны и f - 1 ГГц для быстрой волны [76]. Рисунки позволяют сделать некоторые практические выводы. Так, плохое проникновение медленной волны к центру плазмы делает ее неэффективной для генерация тока в ИТЭРе; быстрая волна проникает лучше, однако рост приводит к её преждевременному затуханию; сильная зависимость поведения траекторий от полоидального угла в точке запуска принципиально ограничивает возможность использования узких спектров, с помощью которых предполагалась транспортировка ВЧ мощности внутрь плазмы [77]. Зти выводы в целом подтверждаются и детализируются при расчетах генерации тока с помощью более сложного кода [68], который включает в себя код расчета лучевых траекторий в качестве одной из составных частей. Мы однако не будем здесь останавливаться на этих вопросах. Вместо этого отметим, что при очевидных достоинствах, численный подход имеет и существенные недостатки. Главным из них является фактическая эмпиричность процедуры. Действительно, форма траекторий выглядит весьма сложной и запутанной (рис. 1,2) и численный расчет, выдавая лишь конечный результат, не позволяет понять причины того или иного их поведения. Кроме того, численнное решение уравнений не позволяет выявить в явном виде индивидуальную роль многочисленных факторов, влияющих на поведение волны. Все это делает целесообразным поиск аналитического подхода к задаче.","tags":"","loc":"page\\chapter_1\\chapter_1_1.html"},{"title":"Применение теории возмущений к уравнениям лучевых траекторий – FRTС project","text":"1.2 Применение теории возмущений к задаче о траекториях Принципиальной причиной сложного поведения нижнегибридных волн в тороидальной \nгеометрии является изменение вдоль траектории.\nГрубо говоря, определяется выражением , \nгде m и n тороидальиое волновые числа, R - расстояние до оси симметрии, q - запас устойчивости.\nЭто выражение, справедливое для плазмы с круглым сечением магнитных поверхностей, легко получается из (1.6),\nесли положить в нем . \nПри этом . Поэтому в дальнейшем, для наглядности, \nмы будем использовать обозначения m и n вместо и . Тороидальное волновое число является константой движения, \nв то время как , и могут изменяться вдоль траектории. \nПоскольку и - известные функции координат, \nглавная проблема заключается в эволюции полоидального импульса .\nПричиной несохранения является полоидальная неоднородность системы. \nТак, в цилиндрической плазме \n(то есть когда - постоянно, а магнитные поверхности имеют форму центрированных окружностей) \nгамильтониан не зависит от и является константой движения. \nФакторами, определяющими несохранение m являются тороидальность, которая характеризуется \nобратным аспектным отношением и некруговая форма магнитных поверхностей, которая в трехмоментном приближении задается функциями . Мы будем в дальнейшем принебрегать треугольностью ,\nпоскольку известно, что она не оказывает существенного влияния на поведение траекторий [78], \nхотя принципиально не составляет большой сложности учитывать любое число гармоник в разложении магнитной поверхности. В качестве первого шага выглядит естественным считать эти факторы малыми и рассматривать их как возмущение в уравнениях лучевых траекторий. Формально это означает, что мы полагаем , для удобства мы будем характеризовать их одним малым параметром .\nГамильтоновская функция после подстановки в нее выражений (1 -6), (1.7) для и является функцией компонент метрического тензора и тензора диэлектрической проницаемости . \nКомпоненты могут быть разложены по , что дает: , \nгде диагональный тензор с ненулевыми компонентами , , и . \nАналогичным образом могут быть разложены и компоненты . \nПодставляя эти разложения в уравнение (1.3) и \nсохраняя члены нулевого и первого порядка по получим где совпадает с гамильтоновской функцией цилиндрического приближения, \nа зависящий от угла член мал - . Для того, чтобы вычислить изменение m вдоль траектории удобно представить лучевые траектории в такой форме, \nчтобы являлось независимой переменной. \nЭта цель может быть достигнута, если решить уравнение (1.9) относительно импульса и \nнайти где определяет номер корня дисперсионного уравнения (1.9).\nТогда m и удовлетворяют каноническим уравнениям: В зависимости от п и m уравнение (1.9) может иметь 2 или 4 действительных корня. Два из них описывают медленные волны, распространяющиеся в противоположных направлениях, другая пара, если она существует, относится к быстрой моде. Уравнения (1.10) определяют траекторию междду точками пересечения корней Ра. Эти точки являются точками поворота траектории и соответствуют отражению, если оба корня относятся к одной моде и трансформации, если к разным. В дальнейшем мы для простоты записи будем опускать индекс , подразумевая, что подход справедлив для обеих мод. Новый гамильтониан Р также может быть разложен по - , где . \nФункция периодична по полоидальному углу 0 и ее можно разложить в ряд Фурье: .\nПри этом вклад тороидальности пропорционален оов0 и входит в первую гармонику, остальные слагаемые связаны с некруговой формой магнитных поверхностей. Поскольку в Фурье разложение уравнения магнитной поверхности мы ограничились двумя слагаемыми (пропорциональными смещению и эллиптичности), \nто и в разложение с точностью до может быть оставлено два слагаемых. Решение системы (1.10) мы будем осуществлять последовательными приближениями по параметру порядке \nпо этому параметру . В нулевом порядке по этому параметру мы имеем где а - начальные значения переменных. Теперь, действуя по теории возмущений и учитывая, что изменение m является величиной порядка ,\nмы можем при его вычислении считать m постоянным , а - взятым в нулевом приближении. Тогда, в первом поряке по получим: Это выражение, вообще говоря, и есть итог непосредственного применения теории возмущений. \nЕстественно, оно справедливо при ; в следующем параграфе мы попытаемся \"улучшить\" его, расширив диапазон допустимых значений . \nОднако сперва используем описанный подход для того, чтобы получить явную формулу для изменения между периферийной точкой запуска и первой точкой поворота траектории в эллиптическом токамаке. Мы  будем рассматривать медленную волну, предполагая для начала, что она не испытывает на первом проходе трансформации в быструю моду. \nВ этом случае можно использовать электростатическое дисперсионное уравнение: Вообще говоря электростатическое приближение применимо при , но оказывается, что оно дает удовлетворительные результаты вплоть до значений , соответствующих трансформации быстрой и медленной волн. Кроме того, в рамках этого приближения можно определить, произойдет на самом деле трансформация или нет.\nВведем для удобства новые переменные, обозначив , , .\nПодставляя уравнения (1.6), (1.7) для и электростатическое дисперсионное уравнение (1.12), получим\nквадратное уравнение для . Решая его относительно в первом порядке по имеем где Знак ± здесь зависит от направления тороидального тока, тороидального магнитного поля и знака тороидального волнового числа, \nто есть от знака произведения составляющих компонент метрического тензора имеем из (1.4) : Для определенности будем считать, что частота волны ш в несколько раз превышает значение центральной нижнегибридной\nсоответствующих трансформации быстрой и медленной волн. Кроме того, в рамках этого приближения можно определить, произойдет на самом деле трансформация или нет.\nВведем для удобства новые переменные, обозначив р/а- р,\nт/п-р. и Р/п-Р. Подставляя уравнения (1.6), (1.7) для к± и к электростатическое дисперсионное уравнение (1.12), получим\nквадратное уравнение для п0. Решая его относительно п_ в первом Г   г порядке по 8 имеем\nр=±р0+р1 ,\nРО(Ц,Р) = / Ф(р)(Ц+ч)2-|хг/рЙ   (1.13)\nР1 (p,p,6)=\nгде ®=-'Q/eI(a/Roq)2.\nЗнак ± здесь зависит от направления тороидального тока, тороидального магнитного поля и знака тороидального волнового числа, то есть от знака произведения (IB&#94;n). Для линейных по 8 составляющих компонент метрического тензора имеем из (1.4) :\ng&#94; = -2Д' 0080+ (Лр)' (1 -00826)\ng,L= Л (1+00826)\n22  (1.14)\n<33= 28роов6\ng&#94; 2=Д'sin6+(Л+Л'р/2)в!п26\nДля определенности будем считать, что частота волны ш в несколько раз превышает значение центральной нижнегибридной соответствующих трансформации быстрой и медленной волн. Кроме того, в рамках этого приближения можно определить, произойдет на самом деле трансформация или нет.\nВведем для удобства новые переменные, обозначив р/а- р,\nт/п-р. и Р/п-Р. Подставляя уравнения (1.6), (1.7) для к± и к электростатическое дисперсионное уравнение (1.12), получим\nквадратное уравнение для п0. Решая его относительно п_ в первом Г   г порядке по 8 имеем\nр=±р0+р1 ,\nРО(Ц,Р) = / Ф(р)(Ц+ч)2-|хг/рЙ   (1.13)\nР1 (p,p,6)=\nгде ®=-'Q/eI(a/Roq)2.\nЗнак ± здесь зависит от направления тороидального тока, тороидального магнитного поля и знака тороидального волнового числа, то есть от знака произведения (IB&#94;n). Для линейных по 8 составляющих компонент метрического тензора имеем из (1.4) :\ng&#94; = -2Д' 0080+ (Лр)' (1 -00826)\ng,L= Л (1+00826)\n22  (1.14)\n<33= 28роов6\ng&#94; 2=Д'sin6+(Л+Л'р/2)в!п26\nДля определенности будем считать, что частота волны ш в несколько раз превышает значение центральной нижнегибридной Тогда мы можем пренебречь зависимостью 8 от 0.\nПолагая начальное значение полоидального волнового числа ц.=0 (это справедливо для волн, запускаемых с помощью стандартного \"грилла\") и подставляя (1.13), (1.14) в (1.11) получим:\nQ(p)= f уф(р' )dp' , (A' +£p)coe(Q±Q)+(Ap)/cos(20±2Q) }dp (1.16)\nРо\nИнтегрирование здесь должно производиться между радиальными координатами точки запуска траектории р&#94; и точки ее первого поворота р°, которые могут быть определены в нулевом приближении из уравнения Ф=0. Уравнение (1.16) удобно представить в форме с амплитудой и фазой: Ц°- а1в1п(±0+ф1) + &#94;а?з1п(±20+Ф2) и, таким образом, задача нахождения сводится к простому интегрированию для определения а1, а2, Ф1, Ф2< По известному |4° глубина проникновения р° может быть пересчитана с лучшей точностью как меньший (на интервале [0,1]) корень уравнения:\np0q(p0)v4(p°)\n±|1 = ± 1 тр°/ Ф(р°) Наконец изменение N дается выражением, следующим из (1.6): AN ц =N|| (p,°/q (р° )+6оов0о) В качестве конкретного примера рассмотрим конфигурацию с простыми модельными профилями:\n«(р)-чо(1+(а-1)р2)\nФ(РМО ■■ 1-Р2-— 2   И-’9)\n[(1 + (Q-1 )Р2]\nА(р)=АаР2 • А(р).-Лар ,\nгде Q=q1/qQ, Ф(у=Ф(О). В этом случае интеграл (1.15) для □ легко берется после замены переменной интегрирования p=einT , \nчто дает в результате\nП(р)= угр {ч&#94;З arotg - т}   (1.20) Нужно отметить, что эта формула неверна при р=0, поскольку при этом члены с т-»0 дают в интеграл конечный вклад, который в данном случае равен тс. Мы в дальнейшем будем его игнорировать, поскольку он лишь отражает особенность полярной системы координат, когда изменеие угла вдоль траекторий, проходящих по разные стороны от центра, отличатся на 2ТС.\nПодставляя (1.20) в (1.16), после некоторых преобразований конечный результат для амплитуд и фаз можно выразить через две функции Тиф, зависящие от двух переменных\nZ=V&#94;O/Q= V(-7]0/Ei0) a/qa и Q=Qa/Qo\nПри этом\na1«(A'+e)QI(z,Q),   ао= Л QI(2z,Q),\n1 а *- а    (1.21)\nф,=ф(г,О),  ф2«ф(22,0)\nФункции I и ф могут быть представлены в виде:\n1= /л&#94;А? ,  ф=агсгё(А1/А2), где\nТС/2    ,,\nA&#94; = f совх sin'x sintf dx\n°   (1.22)\nТС/2    о\nA2=f совх sin x cos'O <ix\nzQ.-.— Q(x) , Q+1 графики этих функций показаны на рис.За»36. Кривые (1) и (3) на этих рисунках соответствуют предельным случаям Q=l и 0~<ю , таким образом кривая для любого конкретного профиля q находится между ними. Как следует из (1 .21 ), (1.22) при Q»1 функции Тиф становятся практически независимыми от этого параметра, так что уже при Q£3 о хорошей точностью можно пользоваться предельной кривой С ростом z функции Тиф достигают своих предельных","tags":"","loc":"page\\chapter_1\\chapter_1_2.html"},{"title":"Метод построения сохраняющего фазовый объем дискретного отображения и его применение к задаче о распространении нижнегибридных волн – FRTС project","text":"§1.3 Метод построения сохраняющего фазовый объем дискретного отображения и его применение к задаче о распространении нижнегибридных волн","tags":"","loc":"page\\chapter_1\\chapter_1_3.html"},{"title":"Глава 2 – FRTС project","text":"СОДЕРЖАНИЕ ВВЕДЕНИЕ Глава 1 . Глава 2 . ОБЩИЕ СВОЙСТВА НИЖНЕГИБРИДНЫХ ВОЛН В ТОРОИДАЛЬНОЙ ПЛАЗМЕ §2.1    Структура доступного фазового пространства §2.2    Дискретное отображение для нижнегибридных волн... §2.3    Схема функционирования отображения §2.4 Исследование свойств нижнегибридных волн с\nпомощью дискретного отображения §2.5    Предельные случаи движения. §2.6 Общая картина распространения и затухания волн\nв нижнегибридном диапазоне частот Глава 3. ПОЛОИДАЛЬНЫЙ РЕЗОНАНС §3-1 Причины возникновения резонанса §3.2 Анализ волновых уравнений в окрестности особой точки §3.3 Возможность использования полоидального резонанса для нагрева плазмы в токамаках с малым аспект\nным отношением ЗАКЛЮЧЕНИЕ ЛИТЕРАТУРА [1]:","tags":"","loc":"page\\chapter_2\\index.html"},{"title":"Структура доступного фазового пространства – FRTС project","text":"§2.1    Структура доступного фазового пространства §2.2    Дискретное отображение для нижнегибридных волн...","tags":"","loc":"page\\chapter_2\\chapter_2_1.html"},{"title":"Дискретное отображение для нижнегибридных волн... – FRTС project","text":"This page is second in the list, despite its filename being\nlexographically first.","tags":"","loc":"page\\chapter_2\\chapter_2_2.html"}]}